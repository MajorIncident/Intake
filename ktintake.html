<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>KT Intake</title>

<!--
[contract] start
EDITING CONTRACT for ChatGPT & humans:
- Keep these anchors intact. Prefer unified diffs (*** Begin Patch / *** End Patch) that edit INSIDE the relevant anchors only.
- Do not remove tokens: {OBJECT} / {DEVIATION}.
- Keep function names/signatures for copy to ASCII intact.
- Avoid structural rewrites unless requested; keep single-file layout.
Anchors present:
  [styles] [vars] [header] [section:preface] [subtitle]
  [section:impact] [section:table]
  [script] [rows] [script:table-build] [script:preface-refs]
  [script:tokens] [script:init] [script:export] [script:storage] [script:toast]
[contract] end
-->

<!-- [styles] start -->
<style>
  /* [vars] start */
  :root{
    /* Apple-like daytime palette */
    --bg:#f5f7fb;
    --panel:#ffffff;
    --ink:#0c1220;
    --muted:#5b6475;
    --line:#e6eaf2;
    --band:#f6f8fc;
    --accent:#007aff;

    /* Layout */
    --qcol-w:10.5rem;     /* narrow KT Question column */
    --ta-fs:15px;         /* textarea font size */
    --ta-min-h:380px;     /* taller by default */
    --radius:14px;
    --shadow:0 8px 24px rgba(12,18,32,.08), 0 1px 0 rgba(255,255,255,.6) inset;
    --speed:.22s;
  }
  /* [vars] end */

  html,body{height:100%;}
  body{
    margin:0; background:var(--bg); color:var(--ink);
    font-family:"SF Pro Text","SF Pro Display",-apple-system,system-ui,"Segoe UI",Roboto,"Helvetica Neue",Arial,sans-serif;
    font-size:15px; line-height:1.6; letter-spacing:-0.01em;
  }
  header{
    max-width:1240px; margin:22px auto 8px; padding:0 12px;
    display:flex; gap:12px; align-items:center; justify-content:space-between;
  }
  .header-title{display:flex; flex-direction:column; gap:4px; flex:1;}
  h1#docTitle{font-size:22px; font-weight:800; margin:0; letter-spacing:-0.01em; white-space:pre-wrap;}
  .subtle{color:var(--muted); font-size:12px;}
  .btn{
    appearance:none; border:1px solid var(--line); background:var(--accent); color:#fff;
    padding:10px 14px; border-radius:12px; cursor:pointer; font-weight:600;
    transition:transform var(--speed), box-shadow var(--speed), border-color var(--speed);
    box-shadow:0 6px 18px rgba(0,122,255,.18);
  }
  .btn:hover{transform:translateY(-1px);}
  .header-actions{display:flex; align-items:center; gap:10px; flex-wrap:wrap; justify-content:flex-end;}
  .steps-button{
    appearance:none; border:1px solid #dfe5f2; background:#f6f8ff; color:#1d2845;
    padding:9px 14px; border-radius:12px; font-weight:600; font-size:13px;
    display:inline-flex; align-items:center; gap:8px; cursor:pointer;
    transition:background var(--speed), border-color var(--speed), transform var(--speed), box-shadow var(--speed);
  }
  .steps-button:hover{background:#eef3ff; transform:translateY(-1px);}
  .steps-button:focus{outline:none; border-color:var(--accent); box-shadow:0 0 0 3px rgba(0,122,255,.18);}
  .steps-button span.shortcut{color:#6b768a; font-size:12px;}
  .steps-badge{
    display:inline-flex; align-items:center; justify-content:center;
    padding:6px 12px; border-radius:999px; background:#eef3ff; color:#1d2845;
    font-weight:600; font-size:13px; min-width:88px; font-variant-numeric:tabular-nums;
  }
  .steps-badge[hidden]{display:none;}
  .steps-backdrop{
    position:fixed; inset:0; background:rgba(12,18,32,.32);
    opacity:0; pointer-events:none; transition:opacity var(--speed);
    z-index:80;
  }
  .steps-backdrop.is-open{opacity:1; pointer-events:auto;}
  .steps-drawer{
    position:fixed; top:0; right:0; height:100%; width:400px; max-width:100%;
    background:#ffffff; border-left:1px solid #dfe5f2; box-shadow:-20px 0 48px rgba(12,18,32,.18);
    transform:translateX(100%); transition:transform var(--speed);
    z-index:90; display:flex; flex-direction:column;
  }
  .steps-drawer.is-open{transform:translateX(0);}
  .steps-drawer__panel{display:flex; flex-direction:column; height:100%;}
  .steps-drawer__header{
    padding:24px; border-bottom:1px solid #ecf0f8;
    background:linear-gradient(180deg,#f8faff 0%,#ffffff 60%);
    display:flex; flex-direction:column; gap:12px;
  }
  .steps-drawer__title-row{display:flex; align-items:center; justify-content:space-between; gap:12px;}
  .steps-drawer__title{margin:0; font-size:18px; font-weight:700; color:#1d2845; letter-spacing:-0.01em;}
  .steps-drawer__progress{font-size:14px; font-weight:600; color:#3b4962;}
  .steps-drawer__body{flex:1; overflow:auto; padding:24px; display:flex; flex-direction:column; gap:18px;}
  .steps-category{border:1px solid #e2e7f3; border-radius:14px; background:#f8faff; padding:0; overflow:hidden;}
  .steps-category summary{list-style:none;}
  .steps-category summary::-webkit-details-marker{display:none;}
  .steps-category__header{
    display:flex; align-items:center; justify-content:space-between; gap:12px;
    padding:16px 18px; cursor:pointer; position:relative;
  }
  .steps-category__header:focus{outline:none; box-shadow:0 0 0 3px rgba(0,122,255,.18); border-radius:10px;}
  .steps-category__header-text{display:flex; flex-direction:column; gap:4px;}
  .steps-category__phase{font-size:12px; font-weight:700; letter-spacing:.08em; text-transform:uppercase; color:#6b768a;}
  .steps-category__name{font-size:15px; font-weight:600; color:#1d2845; letter-spacing:-0.01em;}
  .steps-category__chevron{
    width:22px; height:22px; border-radius:999px; background:#eef3ff;
    display:inline-flex; align-items:center; justify-content:center; font-size:11px;
    color:#3b4962; transition:transform var(--speed);
  }
  .steps-category[open] .steps-category__chevron{transform:rotate(180deg);}
  .steps-category__items{padding:12px 18px 18px; display:flex; flex-direction:column; gap:12px; background:#ffffff;}
  .steps-item{display:flex; align-items:flex-start; gap:12px;}
  .steps-item input[type="checkbox"]{
    appearance:none; width:20px; height:20px; border-radius:6px;
    border:2px solid #cdd6eb; background:#ffffff; cursor:pointer;
    display:inline-flex; align-items:center; justify-content:center;
    transition:background var(--speed), border-color var(--speed), box-shadow var(--speed);
  }
  .steps-item input[type="checkbox"]:focus{outline:none; box-shadow:0 0 0 3px rgba(0,122,255,.18);}
  .steps-item input[type="checkbox"]:checked{background:#0f864a; border-color:#0f864a;}
  .steps-item input[type="checkbox"]:checked::after{content:'✓'; font-size:13px; font-weight:700; color:#ffffff;}
  .steps-item label{font-size:14px; font-weight:600; color:#1d2845; cursor:pointer; line-height:1.55;}
  .steps-item input[type="checkbox"]:checked + label{color:#0f5b2f;}
  .steps-drawer__footer{padding:16px 24px; border-top:1px solid #ecf0f8; background:#ffffff; display:flex; justify-content:flex-end;}
  .steps-drawer__close-btn{
    appearance:none; border:1px solid #dfe5f2; background:#f6f8ff; color:#1d2845;
    padding:9px 16px; border-radius:10px; font-weight:600; cursor:pointer;
    transition:background var(--speed), border-color var(--speed);
  }
  .steps-drawer__close-btn:hover{background:#eef3ff;}
  .steps-drawer__close-btn:focus{outline:none; border-color:var(--accent); box-shadow:0 0 0 3px rgba(0,122,255,.18);}
  @media (max-width:640px){
    .steps-drawer{width:100%; border-radius:0; box-shadow:none;}
  }
  body.steps-drawer-open{overflow:hidden;}
  .wrap{max-width:1240px; margin:0 auto 40px; padding:0 12px;}
  h2#docSubtitle{margin:12px 0 8px; font-size:16px; font-weight:700; color:#2a3957; white-space:pre-wrap;}

  .card{
    background:var(--panel); border:1px solid var(--line); border-radius:var(--radius); box-shadow:var(--shadow);
    padding:20px 22px 24px; margin:0 0 32px;
  }
  .card h3{
    margin:0 0 16px;
    font-family:"SF Pro Display","SF Pro Text",-apple-system,system-ui,ui-sans-serif;
    font-size:15px; font-weight:700; letter-spacing:.32px; text-transform:uppercase; color:#1d2845;
  }
  .preface-stack{display:flex; flex-direction:column;}
  .grid{ display:grid; gap:12px; }
  .grid.cols-2{ grid-template-columns:1fr 1fr; }
  .grid.cols-3{ grid-template-columns:1fr 1fr 1fr; }
  .containment-grid .contain-status{ grid-column:span 2; }
  .containment-radios{ display:flex; flex-wrap:wrap; gap:12px; }
  .radio-option{ display:flex; align-items:center; gap:6px; }
  .comm-grid{ grid-template-columns:1fr 1fr auto; align-items:end; }
  .comm-grid .field{ margin:0; }
  .comm-grid .field label{ margin-bottom:4px; }
  .comm-grid.comm-grid--single{ grid-template-columns:1fr; }
  .comm-log-toggle{ margin-top:8px; align-self:flex-start; display:inline-flex; align-items:center; }
  .inline{ display:flex; align-items:center; gap:12px; flex-wrap:wrap; }
  .chipset{ display:flex; gap:8px; flex-wrap:wrap; }
  .chipset .chip{ position:relative; display:flex; align-items:center; gap:6px; }
  .chipset .chip label{ display:inline-flex; align-items:center; justify-content:center; padding:8px 12px; border-radius:999px; border:1px solid #dfe5f2; background:#f7f9ff; font-weight:600; font-size:13px; color:#1d2845; cursor:pointer; transition:border-color var(--speed), box-shadow var(--speed), background var(--speed); }
  .chipset .chip input[type="checkbox"]{ position:absolute; top:0; left:0; opacity:0; pointer-events:none; width:1px; height:1px; }
  .chipset .chip input[type="checkbox"]:focus + label{ border-color:var(--accent); box-shadow:0 0 0 3px rgba(0,122,255,.18); }
  .chipset .chip input[type="checkbox"]:checked + label{ border-color:var(--accent); background:rgba(0,122,255,.1); color:var(--accent); }
  .chip-label{ font-weight:700; color:#1d2845; min-width:150px; flex:0 0 auto; }
  .caption{ margin:-6px 0 16px; font-size:12px; color:var(--muted); }
  .gap-24{ gap:24px; }
  .field label{display:block; font-weight:700; margin-bottom:6px;}
  .field small{display:block; color:var(--muted); margin-top:4px;}
  fieldset.field{border:0; padding:0; margin:0;}
  fieldset.field legend{font-weight:700; margin-bottom:6px; font-size:14px; color:#1d2845;}
  .field textarea, .field input[type="text"]{
    width:100%; box-sizing:border-box;
    font:15px/1.55 ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
    color:var(--ink); background:#f9fbff;
    border:1px solid #dfe5f2; border-radius:12px; padding:12px 14px; outline:none;
    transition:border-color var(--speed), box-shadow var(--speed), background var(--speed);
  }
  .field textarea{min-height:140px; resize:vertical;}
  .field input[type="text"]{height:44px;}
  .field input[readonly]{background:#f4f6fb; color:#3b4962;}
  .field input[type="time"], .field select{
    width:100%; box-sizing:border-box; height:44px;
    font:15px/1.55 "SF Pro Text","SF Pro Display",-apple-system,system-ui,"Segoe UI",Roboto,"Helvetica Neue",Arial,sans-serif;
    color:var(--ink); background:#f9fbff;
    border:1px solid #dfe5f2; border-radius:12px; padding:8px 12px; outline:none;
    transition:border-color var(--speed), box-shadow var(--speed), background var(--speed);
  }
  .field input[type="time"]:focus, .field select:focus{border-color:var(--accent); box-shadow:0 0 0 4px rgba(0,122,255,.18); background:#fff;}
  .btn-mini{
    appearance:none; border:1px solid #dfe5f2; background:#eef3ff; color:var(--accent);
    padding:8px 12px; border-radius:10px; cursor:pointer; font-weight:600; font-size:13px;
    transition:transform var(--speed), box-shadow var(--speed), border-color var(--speed);
    box-shadow:0 4px 12px rgba(0,122,255,.12);
  }
  .btn-mini:hover{transform:translateY(-1px);}
  .btn-mini:focus{outline:none; border-color:var(--accent); box-shadow:0 0 0 4px rgba(0,122,255,.18);}
  .btn-mini.btn-ghost{
    background:#f7f9ff; color:#3b4962; border-color:#e2e7f3; box-shadow:none;
  }
  .btn-mini.btn-ghost:hover{background:#eef3ff;}
  .btn-mini.btn-danger{
    background:#ffeceb; color:#c0362c; border-color:#ffc3bb; box-shadow:0 4px 12px rgba(255,107,74,.12);
  }
  .btn-mini.btn-danger:hover{background:#ffdcd4;}
  .field textarea::placeholder, .field input::placeholder{color:#8b93a4;}
  .field textarea:focus, .field input:focus{border-color:var(--accent); box-shadow:0 0 0 4px rgba(0,122,255,.18); background:#fff;}

  .card.communication-due{ border-color:#ff9a8a; background:linear-gradient(180deg,#fff4f2 0%,#ffffff 35%); box-shadow:0 10px 28px rgba(255,107,74,.18); }
  .communication-due .countdown{ color:#d91f11; }

  .cadence-group{ display:flex; gap:8px; flex-wrap:wrap; }
  .cadence-option{ position:relative; }
  .cadence-option input[type="radio"]{ position:absolute; inset:0; opacity:0; }
  .cadence-option span{ display:inline-flex; align-items:center; justify-content:center; padding:8px 14px; border-radius:999px; border:1px solid #dfe5f2; background:#f7f9ff; font-weight:600; font-size:13px; color:#1d2845; cursor:pointer; transition:border-color var(--speed), box-shadow var(--speed), background var(--speed); }
  .cadence-option input[type="radio"]:focus + span{ border-color:var(--accent); box-shadow:0 0 0 3px rgba(0,122,255,.18); }
  .cadence-option input[type="radio"]:checked + span{ border-color:var(--accent); background:rgba(0,122,255,.1); color:var(--accent); }

  .comm-actions{ gap:10px; justify-content:flex-start; }
  .comm-actions .countdown{ font-weight:600; color:#2a3957; min-width:96px; }

  .comm-alert{ margin-top:10px; padding:10px 12px; border-radius:12px; background:#fff2f0; border:1px solid #ffd0c7; color:#b71c1c; font-weight:600; display:flex; align-items:center; gap:8px; }

  .comm-log{ list-style:none; padding:0; margin:12px 0 0; display:flex; flex-direction:column; gap:8px; }
  .comm-log li{ display:flex; justify-content:space-between; align-items:center; gap:12px; padding:10px 12px; border-radius:12px; background:#f7f9ff; border:1px solid #e2e7f3; font-size:13px; }
  .comm-log__type{ font-weight:700; text-transform:uppercase; letter-spacing:.04em; color:#1d2845; }
  .comm-log__time{ font-variant-numeric:tabular-nums; color:#2a3957; }
  .comm-log__message{ flex:1; color:#3b4962; font-size:12px; }
  .comm-log__empty{ justify-content:flex-start; color:#7a8398; font-style:italic; }

  /* Impact strip */
  .impact{ padding:18px; }
  .impact > h3{
    margin:0 0 18px;
    font-size:17px;
    font-weight:700;
    letter-spacing:-0.02em;
    color:#1f2b40;
    font-family:"SF Pro Display","SF Pro Text",-apple-system,system-ui,"Segoe UI",Roboto,"Helvetica Neue",Arial,sans-serif;
  }
  .impact .field{padding:4px 0;}
  .impact .field h3{
    margin:0 0 6px;
    font-size:15px;
    font-weight:600;
    letter-spacing:-0.015em;
    color:#22324b;
    font-family:"SF Pro Display","SF Pro Text",-apple-system,system-ui,"Segoe UI",Roboto,"Helvetica Neue",Arial,sans-serif;
  }
  .impact .field label{
    font-size:13px;
    font-weight:600;
    letter-spacing:-0.01em;
    color:#3b4962;
    margin-bottom:8px;
  }
  .impact .field small{
    font-size:12px;
    line-height:1.55;
    letter-spacing:0;
  }
  .impact textarea{
    font-family:"SF Pro Text","SF Pro Display",-apple-system,system-ui,"Segoe UI",Roboto,"Helvetica Neue",Arial,sans-serif;
    font-size:14px;
    line-height:1.6;
    letter-spacing:-0.01em;
  }

  /* Table */
  table{
    table-layout:fixed;
    
    width:100%; border-collapse:separate; border-spacing:0; overflow:hidden; border-radius:var(--radius);
    background:var(--panel); border:1px solid var(--line); box-shadow:var(--shadow);
  }
  thead th{
    word-wrap:break-word;
    white-space:normal;
    
    position:sticky; top:0; z-index:3;
    background:linear-gradient(180deg, #ffffff, #fafbfe);
    color:#0c1220; text-align:left; font-size:12px; letter-spacing:.4px;
    padding:12px; border-bottom:1px solid var(--line);
  }
  tbody td, tbody th{
    border-bottom:1px solid var(--line); vertical-align:top; padding:10px 8px; transition:background-color var(--speed);
  }
  tbody tr:last-child td, tbody tr:last-child th{border-bottom:0;}
  tbody tr:hover td, tbody tr:hover th{background-color:#fafbfe;}
  tbody th{
    width:var(--qcol-w); max-width:var(--qcol-w); min-width:var(--qcol-w);
    white-space:normal; word-break:break-word; font-weight:700; color:#0c1220;
  }
  .cause-list{display:flex; flex-direction:column; gap:16px; margin-top:12px; margin-bottom:18px;}
  .cause-empty{padding:18px; border:1px dashed #dfe5f2; border-radius:12px; background:#f9fbff; color:#5b6475; font-style:italic;}
  .cause-card{
    border:1px solid #e2e7f3; border-radius:14px; background:linear-gradient(180deg,#ffffff 0%,#f8faff 100%);
    padding:18px 20px; display:flex; flex-direction:column; gap:12px; position:relative;
  }
  .cause-card[data-editing="true"]{border-color:var(--accent); box-shadow:0 0 0 4px rgba(0,122,255,.12);}
  .cause-card[data-failed="true"]{border-color:#ffb3a9; box-shadow:0 0 0 4px rgba(255,107,74,.16);}
  .cause-card__header{display:flex; justify-content:space-between; align-items:flex-start; gap:12px;}
  .cause-card__meta{display:flex; flex-direction:column; gap:4px;}
  .cause-card__title{font-weight:700; font-size:14px; color:#1d2845; letter-spacing:.02em;}
  .cause-card__status{font-size:12px; color:var(--muted); letter-spacing:.02em;}
  .cause-card__indicators{display:flex; flex-direction:column; align-items:flex-end; gap:6px;}
  .cause-card__chip{display:inline-flex; align-items:center; justify-content:center; padding:6px 12px; border-radius:999px; font-weight:600; font-size:12px; letter-spacing:.03em; text-transform:uppercase; border:1px solid transparent; background:#f2f4fb; color:#3b4962;}
  .cause-card__chip[data-status="not-tested"]{background:#f2f4fb; color:#3b4962; border-color:#dfe5f2;}
  .cause-card__chip[data-status="testing"]{background:#fff6e6; color:#7b4b00; border-color:#f3d2a2;}
  .cause-card__chip[data-status="explained"]{background:#e6f9ef; color:#0f5b2f; border-color:#b8e8cd;}
  .cause-card__chip[data-status="failed"]{background:#ffe8e6; color:#b71c1c; border-color:#ffb3a9;}
  .cause-card__chip[data-status="draft"]{background:#f5f7fb; color:#6b768a; border-color:#e2e7f3;}
  .cause-card__chip[data-status="no-evidence"]{background:#eef3ff; color:#1d2845; border-color:#d5def5;}
  .cause-card__failure{display:inline-flex; align-items:center; gap:6px; padding:4px 10px; border-radius:999px; font-weight:600; font-size:12px; letter-spacing:.02em; background:#ffe8e6; color:#b71c1c; border:1px solid #ffb3a9;}
  .cause-card__failure::before{content:'✕'; font-size:13px; line-height:1;}
  .cause-card__assumptions{display:inline-flex; align-items:center; gap:6px; padding:4px 10px; border-radius:999px; font-weight:600; font-size:12px; letter-spacing:.02em; background:#f1f4ff; color:#1d2845; border:1px solid #d5def5;}
  .cause-card__assumptions::before{content:'∑'; font-size:13px; line-height:1; color:#3b4d7a;}
  .cause-card__summary{margin:0; font-size:14px; line-height:1.6; color:#1f2b40;}
  .cause-card__helper{margin-top:-6px;}
  .cause-card__actions{display:flex; gap:6px; flex-wrap:wrap; justify-content:flex-end;}
  .cause-card__actions .btn-mini{padding-inline:12px;}
  .cause-card__form{display:grid; gap:14px;}
  .cause-card__form .field textarea{min-height:120px;}
  .cause-controls{display:flex; gap:8px; flex-wrap:wrap; margin-top:4px;}
  .cause-test{border-top:1px solid #e2e7f3; padding-top:14px; display:flex; flex-direction:column; gap:12px;}
  .cause-test__intro{margin:0; font-size:13px; color:#3b4962;}
  .cause-eval-row{border:1px solid #e3e8f5; border-radius:12px; background:#f9fbff; padding:14px; display:flex; flex-direction:column; gap:12px;}
  .cause-eval-question-text{font-weight:600; font-size:13px; color:#1f2b40;}
  .cause-evidence-wrap{display:grid; gap:10px; grid-template-columns:repeat(auto-fit, minmax(180px,1fr));}
  .cause-evidence-block{display:flex; flex-direction:column; gap:4px; padding:10px; border-radius:10px; background:#ffffff; border:1px solid #e6ebf5;}
  .cause-evidence-label{font-size:11px; text-transform:uppercase; letter-spacing:.08em; color:#7a8398; font-weight:700;}
  .cause-evidence-text{font-size:13px; line-height:1.5; color:#22324b; white-space:pre-line;}
  .cause-eval-inputs{display:flex; flex-direction:column; gap:12px;}
  .cause-eval-options{display:flex; flex-wrap:wrap; gap:8px;}
  .cause-eval-option{appearance:none; border:1px solid #dfe5f2; background:#ffffff; color:#1d2845; font-weight:600; font-size:13px; padding:8px 14px; border-radius:999px; cursor:pointer; transition:background var(--speed), border-color var(--speed), color var(--speed), box-shadow var(--speed);}
  .cause-eval-option:hover{border-color:var(--accent);}
  .cause-eval-option:focus{outline:none; border-color:var(--accent); box-shadow:0 0 0 4px rgba(0,122,255,.18);}
  .cause-eval-option.is-selected{background:rgba(0,122,255,.12); border-color:var(--accent); color:var(--accent); box-shadow:0 6px 16px rgba(0,122,255,.12);}
  .cause-eval-note{display:flex; flex-direction:column; gap:6px;}
  .cause-eval-note[hidden]{display:none;}
  .cause-eval-inputs .field textarea{min-height:120px;}
  .cause-evidence-empty{padding:12px; border-radius:10px; background:#f7f9ff; color:#5b6475; font-size:13px;}
  @media (max-width:720px){
    .cause-card{padding:16px;}
  }
  .band th{
    padding:12px; font-weight:800; color:#2a3957;
    background:linear-gradient(180deg, var(--band), #ffffff);
    border-top:1px solid var(--line); border-bottom:1px solid var(--line);
  }
  .band th span{opacity:.85; font-weight:600; color:#6b768a}
  textarea.tableta{
    width:100%; min-height:var(--ta-min-h); resize:vertical; box-sizing:border-box;
    font:var(--ta-fs)/1.55 ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
    color:var(--ink); background:#f9fbff;
    border:1px solid #dfe5f2; border-radius:12px; padding:12px 14px; outline:none;
    transition:border-color var(--speed), box-shadow var(--speed), background var(--speed);
  }
  textarea.tableta::placeholder{color:#8b93a4;}
  textarea.tableta:focus{border-color:var(--accent); box-shadow:0 0 0 4px rgba(0,122,255,.18); background:#ffffff;}

  /* Toast */
  .toast{
    position:fixed; right:18px; bottom:18px; background:#0f1a10; color:#dff5e1; border:1px solid #164f19;
    padding:10px 12px; border-radius:12px; opacity:0; transform:translateY(10px); transition:.25s; pointer-events:none; box-shadow:var(--shadow);
  }
  .toast.show{opacity:1; transform:translateY(0);}
</style>
<!-- [styles] end -->
</head>
<body>
  <!-- [header] start -->
  <header>
    <div class="header-title">
      <h1 id="docTitle">KT Intake</h1>
    </div>
    <div class="header-actions">
      <button type="button" class="steps-button" id="stepsBtn" aria-haspopup="dialog" aria-controls="stepsDrawer" aria-expanded="false">
        <span>Steps</span>
        <span class="shortcut">Alt+S</span>
      </button>
      <span class="steps-badge" id="stepsCompletedLabel" aria-live="polite">0 of 28</span>
      <button class="btn" id="genSummaryBtn" onclick="onGenerateSummary()">Generate Summary</button>
    </div>
  </header>
  <!-- [header] end -->

  <div class="wrap">
    <!-- [section:preface] start -->
    <section class="preface-stack">
      <div class="card">
        <h3>Bridge Activation</h3>
        <p class="caption">Capture only what’s needed to activate the bridge and set comms cadence.</p>
        <div class="grid cols-3">
          <div class="field">
            <label for="bridgeOpenedUtc">Bridge opened (UTC)</label>
            <div class="inline">
              <input type="text" id="bridgeOpenedUtc" readonly aria-readonly="true" />
              <button type="button" class="btn-mini" id="bridgeSetNowBtn" aria-label="Stamp bridge opened time">Set Now</button>
            </div>
          </div>
          <div class="field">
            <label for="icName">Incident Commander</label>
            <input type="text" id="icName" placeholder="" />
          </div>
          <div class="field">
            <label for="bcName">Bridge Coordinator</label>
            <input type="text" id="bcName" placeholder="" />
          </div>
        </div>
        <div class="grid cols-3">
          <div class="field">
            <label for="semOpsName">SEM/Ops Lead</label>
            <input type="text" id="semOpsName" placeholder="" />
          </div>
          <div class="field">
            <label for="severity">Severity</label>
            <select id="severity">
              <option value="">Select severity</option>
              <option value="S1">S1</option>
              <option value="S2">S2</option>
              <option value="S3">S3</option>
            </select>
          </div>
        </div>
      </div>

      <div class="card" id="problem-summary">
        <h3>Problem Summary</h3>
        <div class="grid">
          <div class="field">
            <label for="oneLine">In one sentence, what is broken for you right now?</label>
            <textarea id="oneLine" placeholder=""></textarea>
          </div>
        </div>
      </div>

      <div class="card" id="evidence-objects">
        <h3>Evidence &amp; Object</h3>
        <div class="inline">
          <span class="chip-label">Detection Source</span>
          <div class="chipset" role="group" aria-label="Detection Source">
            <div class="chip">
              <input type="checkbox" id="detectMonitoring" />
              <label for="detectMonitoring">Monitoring</label>
            </div>
            <div class="chip">
              <input type="checkbox" id="detectUserReport" />
              <label for="detectUserReport">User Report</label>
            </div>
            <div class="chip">
              <input type="checkbox" id="detectAutomation" />
              <label for="detectAutomation">Automation</label>
            </div>
            <div class="chip">
              <input type="checkbox" id="detectOther" />
              <label for="detectOther">Other</label>
            </div>
          </div>
        </div>
        <div class="inline">
          <span class="chip-label">Evidence Collected</span>
          <div class="chipset" role="group" aria-label="Evidence Collected">
            <div class="chip">
              <input type="checkbox" id="evScreenshot" />
              <label for="evScreenshot">Screenshot</label>
            </div>
            <div class="chip">
              <input type="checkbox" id="evLogs" />
              <label for="evLogs">Logs</label>
            </div>
            <div class="chip">
              <input type="checkbox" id="evMetrics" />
              <label for="evMetrics">Metrics</label>
            </div>
            <div class="chip">
              <input type="checkbox" id="evRepro" />
              <label for="evRepro">Repro</label>
            </div>
            <div class="chip">
              <input type="checkbox" id="evOther" />
              <label for="evOther">Other</label>
            </div>
          </div>
        </div>
        <div class="grid cols-2">
          <div class="field">
            <label for="proof">What proves a deviation exists?</label>
            <small>Examples: alerts, error messages, metric spikes/drops, log lines, screenshots, reproducible steps.</small>
            <textarea id="proof" placeholder=""></textarea>
          </div>
          <div class="field">
            <label for="objectPrefill">What is the specific object being affected?</label>
            <small>Hardware name and model, Function/Module/Method, Container/Service/API, datastore/volume/bucket/table, network element, identity/policy/role, pipeline/job.</small>
            <textarea id="objectPrefill" placeholder=""></textarea>
          </div>
        </div>
      </div>

      <div class="card" id="baseline-current">
        <h3>Baseline vs Current</h3>
        <div class="grid cols-2">
          <div class="field">
            <label id="labelHealthy" for="healthy">What does healthy look like here?</label>
            <small>What was the expected behavior?</small>
            <textarea id="healthy" placeholder=""></textarea>
          </div>
          <div class="field">
            <label id="labelNow" for="now">What is happening now?</label>
            <small>What has been verified and measured vs same baseline (same metrics as above)? What symptom is being presented?</small>
            <textarea id="now" placeholder=""></textarea>
          </div>
        </div>
      </div>
    </section>
    <!-- [section:preface] end -->

    <!-- [subtitle] start -->
    <h2 id="docSubtitle">Describe The Problem</h2>
    <!-- [subtitle] end -->

    <!-- [section:impact] start -->
    <div class="card impact">
      <h3>Impact</h3>
      <div class="grid cols-3 containment-grid">
        <fieldset class="field contain-status">
          <legend>Containment Status</legend>
          <div class="containment-radios" role="radiogroup" aria-label="Containment Status">
            <div class="radio-option">
              <input type="radio" id="containNone" name="containStatus" value="none" />
              <label for="containNone">No action yet</label>
            </div>
            <div class="radio-option">
              <input type="radio" id="containMitigation" name="containStatus" value="mitigation" />
              <label for="containMitigation">Temporary mitigation applied</label>
            </div>
            <div class="radio-option">
              <input type="radio" id="containRestore" name="containStatus" value="restore" />
              <label for="containRestore">Full restoration in progress</label>
            </div>
          </div>
        </fieldset>
        <div class="field">
          <label for="containDesc">Containment Description</label>
          <input type="text" id="containDesc" placeholder="What immediate step reduces risk?" />
        </div>
      </div>
      <div class="grid cols-3 gap-24">
        <div class="field">
          <h3>Current Impact</h3>
          <label for="impactNow">Current Impact</label>
          <small>Who/what is affected now? Quantify: users/tenants/regions, transactions failing, SLI/SLO deltas (avail %, p95/p99, error %), data at risk (loss/corruption/exposure), workarounds.</small>
          <textarea id="impactNow" placeholder=""></textarea>
        </div>
        <div class="field">
          <h3>Future Impact</h3>
          <label for="impactFuture">Future Impact</label>
          <small>If unresolved what happens? Blast radius growth, SLO/SLA breach, revenue/penalties, compliance, backlog/consumer lag, churn, on-call fatigue.</small>
          <textarea id="impactFuture" placeholder=""></textarea>
        </div>
        <div class="field">
          <h3>Timeframe</h3>
          <label for="impactTime">Timeframe</label>
          <small>When will the Future Impact become Current Impact? (Best Estimate). What deadlines/SLAs do we need to be aware of?</small>
          <textarea id="impactTime" placeholder=""></textarea>
        </div>
      </div>
    </div>
    <!-- [section:impact] end -->

    <div class="card" id="commControlsCard">
      <h3>Communication Cadence &amp; Log</h3>
      <fieldset class="field" id="communication-cadence">
        <legend id="commCadenceLegend">Communication cadence</legend>
        <div class="cadence-group" id="commCadenceGroup" role="radiogroup" aria-labelledby="commCadenceLegend">
          <label class="cadence-option">
            <input type="radio" name="commCadence" value="10" />
            <span>10 min</span>
          </label>
          <label class="cadence-option">
            <input type="radio" name="commCadence" value="15" />
            <span>15 min</span>
          </label>
          <label class="cadence-option">
            <input type="radio" name="commCadence" value="20" />
            <span>20 min</span>
          </label>
          <label class="cadence-option">
            <input type="radio" name="commCadence" value="30" />
            <span>30 min</span>
          </label>
          <label class="cadence-option">
            <input type="radio" name="commCadence" value="60" />
            <span>Hourly</span>
          </label>
        </div>
        <small>Pick how often updates should be broadcast. Logging a communication restarts the timer and reminder.</small>
      </fieldset>
      <div class="inline comm-actions">
        <button type="button" class="btn-mini" id="commInternalStampBtn" aria-label="Log internal communication">Log internal update</button>
        <button type="button" class="btn-mini" id="commExternalStampBtn" aria-label="Log external communication">Log external update</button>
        <button type="button" class="btn-mini" id="generateAiSummaryBtn" aria-label="Generate AI Summary">Generate AI Summary</button>
        <button type="button" class="btn-mini" id="commAIPromptBtn" aria-label="Use AI to draft communications">Use AI to create comms</button>
        <span class="countdown" id="commCountdown" aria-live="polite"></span>
      </div>
      <div class="comm-alert" id="commDueAlert" role="alert" hidden></div>
      <div class="grid comm-grid comm-grid--single">
        <div class="field">
          <label for="commNextUpdateTime">Next update scheduled for</label>
          <input type="time" id="commNextUpdateTime" />
        </div>
      </div>
      <div class="field" id="communication-log">
        <label for="commLogList">Communication log</label>
        <ul id="commLogList" class="comm-log" aria-live="polite" aria-label="Communication log"></ul>
        <button type="button" class="btn-mini comm-log-toggle" id="commLogToggleBtn" hidden aria-expanded="false">Show all</button>
      </div>
    </div>

    <!-- [section:table] start -->
    <p class="subtle" id="kt-is-is-not">Problem Analysis</p>

    <table id="ktTable" aria-label="KT IS / IS NOT intake table">
<colgroup>
  <col style="width:18%;">
  <col style="width:21%;">
  <col style="width:21%;">
  <col style="width:20%;">
  <col style="width:20%;">
</colgroup>

      <thead>
        <tr>
          <th scope="col">KT Question</th>
          <th scope="col">IS <span class="subtle">— facts only</span></th>
          <th scope="col">IS NOT <span class="subtle">— similar &amp; reasonable and could be but is not occuring</span></th>
          <th scope="col">Distinctions <span class="subtle">— Unique characteristics about the IS</span></th>
          <th scope="col">Changes <span class="subtle">— Changes that happened in on around or about each Distinction</span></th>
        </tr>
      </thead>
      <tbody id="tbody"></tbody>
    </table>
    <!-- [section:table] end -->


    <div id="possible-causes" tabindex="-1"></div>
    <div class="card" id="possibleCausesCard">
      <h3>Possible Causes</h3>
      <p class="caption">Capture hypotheses and pressure test them against the KT IS / IS NOT evidence. Start with the suspect, accusation, and impact; then walk each cause through the table.</p>
      <div id="causeList" class="cause-list" aria-live="polite"></div>
      <div class="cause-controls">
        <button type="button" class="btn-mini" id="addCauseBtn">Add Possible Cause</button>
      </div>
    </div>


    <!-- [section:summary] start -->
    <div class="card" id="summaryCard" style="display:none;">
      <h3>Copy &amp; Paste Summary</h3>
      <pre id="summaryPre" style="white-space:pre-wrap;font:13px/1.6 monospace;margin:0;"></pre>
    </div>
    <!-- [section:summary] end -->

  </div>

  <div class="steps-backdrop" id="stepsBackdrop" aria-hidden="true"></div>
  <aside class="steps-drawer" id="stepsDrawer" role="dialog" aria-modal="true" aria-labelledby="stepsDrawerTitle" aria-hidden="true" tabindex="-1">
    <div class="steps-drawer__panel">
      <header class="steps-drawer__header">
        <div class="steps-drawer__title-row">
          <h3 class="steps-drawer__title" id="stepsDrawerTitle">Incident Steps</h3>
          <div class="steps-drawer__progress" id="stepsDrawerProgress">0 of 28 completed</div>
        </div>
      </header>
      <div class="steps-drawer__body" id="stepsList" role="group" aria-label="Incident steps checklist"></div>
      <footer class="steps-drawer__footer">
        <button type="button" class="steps-drawer__close-btn" id="stepsCloseBtn">Close</button>
      </footer>
    </div>
  </aside>

  <div id="toast" class="toast" role="status" aria-live="polite"></div>

<!-- [script] start -->
<script>
/* [rows] start */
/* =================== Core data & prompts (KT Problem Analysis) =================== */
/* Use {OBJECT} / {DEVIATION} tokens anywhere you want auto-fill. */
const ROWS = [
  { band: "WHAT", note: "Define the problem precisely (Object & Deviation)." },

  {
    q: "WHAT — Specific Object/Thing is having the {DEVIATION}",
    isPH:
      "What specific object has {DEVIATION}?",
    notPH:
      "What similar objects could reasonably have, but do NOT have {DEVIATION}?"
  },
  {
    q: "WHAT — Specific Deviation does the {OBJECT} have?",
    isPH:
      "What exactly is the deviation that has been confirmed?",
    notPH:
      "What reasonable symptoms could the {OBJECT} have had, but we have verified are NOT present?"
  },

  { band: "WHERE", note: "Locate the problem (geography/topology and on the object)." },

  {
    q: "WHERE — is the {OBJECT} geographically/topology when the {DEVIATION} occurs?",
    isPH:
      "Where is {OBJECT} when {DEVIATION} occurs?",
    notPH:
      "Where would you reasonably expect the {OBJECT} could have been when the {DEVIATION} was observed but we do NOT see it?"
  },
  {
    q: "WHERE — On the {OBJECT} is the {DEVIATION} observed?",
    isPH:
      "Where on {OBJECT} is {DEVIATION} observed?",
    notPH:
      "What neighboring parts on the {OBJECT} do NOT show {DEVIATION}?"
  },

  { band: "WHEN", note: "Timing and Description" },

  {
    q: "WHEN — Was the {DEVIATION} First observed for {OBJECT}",
    isPH:
      "When was {DEVIATION} first observed for {OBJECT}? (date/time/zone)",
    notPH:
      "When was the last known good for {OBJECT}? When reasonably could we have observed other {DEVIATION} on {OBJECT} but we did not?"
  },
  {
    q: "WHEN — Since was the first time has {DEVIATION} been logged? What Pattern?",
    isPH:
      "Since first occurrence, when does {DEVIATION} re-occur?\n• What Pattern (continuous/periodic/sporadic/one time)",
    notPH:
      "What Similar windows/patterns of times is the {OBJECT} not having {DEVIATION}?"
  },
  {
    q: "WHEN — Describe using words When the {DEVIATION} was first seen",
    isPH:
      "At what point in {OBJECT}’s life-cycle did {DEVIATION} appear?\n• Use words like before, during, or after to describe these times and consider multiple lifecycles",
    notPH:
      "What Adjacent life-cycle moments could we have reasonably caught or observed the {DEVIATION} but we did not?"
  },

  { band: "EXTENT", note: "How big is it? Magnitude, count, scope, trend." },

  {
    q: "EXTENT — What is the population or size of {OBJECT} affected?",
    isPH:
      "How many {OBJECT}s have {DEVIATION}?\nTrend (↑/↓/stable)?",
    notPH:
      "What population or Comparable object sets have not been affected"
  },
  {
    q: "EXTENT — What is the size of a single {DEVIATION}?",
    isPH:
      "How big is a single {DEVIATION} on {OBJECT}?\nTrend (↑/↓/stable)?",
    notPH:
      "What sizes could the {DEVIATION} reasonably have been but were not?"
  },
  {
    q: "EXTENT — How many {DEVIATION} are occuring on each {OBJECT}?",
    isPH:
      "How many instances of {DEVIATION} per {OBJECT}?\nTrend (↑/↓/stable)?",
    notPH:
      "Reasonably, how many instances of {DEVIATION} could have occured per {OBJECT} but did not?"
  },
];

/* [rows] end */

/* [script:table-build] start */
/* =================== Build table & dynamic tokens =================== */
const tbody = document.getElementById('tbody');
const rowsBuilt = [];
let possibleCauses = [];
const CAUSE_STATUSES = {
  DRAFT: 'draft',
  NOT_TESTED: 'not-tested',
  TESTING: 'testing',
  EXPLAINED: 'explained',
  FAILED: 'failed'
};
const CAUSE_STATUS_LABELS = {
  [CAUSE_STATUSES.DRAFT]: 'Draft hypothesis',
  [CAUSE_STATUSES.NOT_TESTED]: 'Not tested yet',
  [CAUSE_STATUSES.TESTING]: 'Testing in progress',
  [CAUSE_STATUSES.EXPLAINED]: 'Explains evidence',
  [CAUSE_STATUSES.FAILED]: 'Failed testing'
};
const CAUSE_FINDING_MODES = {
  UNKNOWN: 'unknown',
  YES: 'yes',
  FAIL: 'fail',
  ASSUMPTION: 'assumption'
};

function createCauseId(){
  return `cause-${Date.now().toString(36)}-${Math.random().toString(36).slice(2,8)}`;
}

function normalizeCauseStatus(value){
  const allowed = Object.values(CAUSE_STATUSES);
  if(typeof value === 'string'){
    const normalized = value.trim().toLowerCase();
    if(allowed.includes(normalized)){
      return normalized;
    }
  }
  return CAUSE_STATUSES.DRAFT;
}

function createEmptyCause(){
  return {
    id: createCauseId(),
    name: '',
    hypothesis: '',
    impact: '',
    assumptions: '',
    status: CAUSE_STATUSES.DRAFT,
    editing: true,
    findings: {}
  };
}

function ensurePossibleCausesUI(){
  causeList = document.getElementById('causeList');
  addCauseBtn = document.getElementById('addCauseBtn');
  if(addCauseBtn && !addCauseBtn.dataset.bound){
    addCauseBtn.addEventListener('click', ()=>{
      const cause = createEmptyCause();
      possibleCauses.push(cause);
      renderCauses();
      updateCauseEvidencePreviews();
      if(typeof saveToStorage === 'function'){
        saveToStorage();
      }
      focusFirstEditableCause();
      const anchor = document.getElementById('possible-causes');
      if(anchor){
        try{
          anchor.focus({ preventScroll:true });
        }catch(_){
          anchor.focus();
        }
        anchor.scrollIntoView({ behavior:'smooth', block:'start' });
      }
    });
    addCauseBtn.dataset.bound = 'true';
  }
}

function renderCauses(){
  ensurePossibleCausesUI();
  if(!causeList) return;
  causeList.innerHTML = '';
  if(!Array.isArray(possibleCauses) || !possibleCauses.length){
    const empty = document.createElement('div');
    empty.className = 'cause-empty';
    empty.textContent = 'No possible causes added yet.';
    causeList.appendChild(empty);
    return;
  }
  const indexSnapshot = [...rowsBuilt.keys()];
  possibleCauses.forEach((cause, idx)=>{
    const card = buildCauseCard(cause, idx, indexSnapshot);
    causeList.appendChild(card);
  });
  updateCauseEvidencePreviews();
}

function buildCauseCard(cause, index, indexSnapshot){
  const card = document.createElement('article');
  card.className = 'cause-card';
  card.dataset.causeId = cause.id;
  card.dataset.editing = cause.editing ? 'true' : 'false';
  card.dataset.failed = causeHasFailure(cause) ? 'true' : 'false';

  const header = document.createElement('div');
  header.className = 'cause-card__header';

  const meta = document.createElement('div');
  meta.className = 'cause-card__meta';
  const titleEl = document.createElement('div');
  titleEl.className = 'cause-card__title';
  const progressEl = document.createElement('div');
  progressEl.className = 'cause-card__status';

  const indicators = document.createElement('div');
  indicators.className = 'cause-card__indicators';
  const statusChip = document.createElement('span');
  statusChip.className = 'cause-card__chip';
  const failureBadge = document.createElement('span');
  failureBadge.className = 'cause-card__failure';
  failureBadge.textContent = 'Failed evidence check';
  const assumptionBadge = document.createElement('span');
  assumptionBadge.className = 'cause-card__assumptions';

  indicators.append(statusChip, failureBadge, assumptionBadge);

  const actions = document.createElement('div');
  actions.className = 'cause-card__actions';
  const toggleBtn = document.createElement('button');
  toggleBtn.type = 'button';
  toggleBtn.className = 'btn-mini btn-ghost';
  const removeBtn = document.createElement('button');
  removeBtn.type = 'button';
  removeBtn.className = 'btn-mini btn-danger';
  removeBtn.textContent = 'Remove';

  actions.append(toggleBtn, removeBtn);

  meta.append(titleEl, progressEl);
  header.append(meta, indicators, actions);

  const summaryEl = document.createElement('p');
  summaryEl.className = 'cause-card__summary';

  const form = document.createElement('div');
  form.className = 'cause-card__form';

  const suspectField = document.createElement('div');
  suspectField.className = 'field';
  const suspectLabel = document.createElement('label');
  suspectLabel.textContent = 'Suspect / Component';
  const suspectInput = document.createElement('input');
  suspectInput.type = 'text';
  suspectInput.value = cause.name || '';
  suspectField.append(suspectLabel, suspectInput);

  const hypothesisField = document.createElement('div');
  hypothesisField.className = 'field';
  const hypothesisLabel = document.createElement('label');
  hypothesisLabel.textContent = 'Hypothesis / Accusation';
  const hypothesisTextarea = document.createElement('textarea');
  hypothesisTextarea.value = cause.hypothesis || '';
  hypothesisField.append(hypothesisLabel, hypothesisTextarea);

  const impactField = document.createElement('div');
  impactField.className = 'field';
  const impactLabel = document.createElement('label');
  impactLabel.textContent = 'Impact if true';
  const impactTextarea = document.createElement('textarea');
  impactTextarea.value = cause.impact || '';
  impactField.append(impactLabel, impactTextarea);

  const assumptionsField = document.createElement('div');
  assumptionsField.className = 'field';
  const assumptionsLabel = document.createElement('label');
  assumptionsLabel.textContent = 'Assumptions to verify';
  const assumptionsTextarea = document.createElement('textarea');
  assumptionsTextarea.value = cause.assumptions || '';
  assumptionsField.append(assumptionsLabel, assumptionsTextarea);

  const statusField = document.createElement('fieldset');
  statusField.className = 'field';
  const statusLegend = document.createElement('legend');
  statusLegend.textContent = 'Current evaluation';
  const statusSelect = document.createElement('select');
  [
    { value: CAUSE_STATUSES.DRAFT, label: 'Draft hypothesis' },
    { value: CAUSE_STATUSES.NOT_TESTED, label: 'Not tested yet' },
    { value: CAUSE_STATUSES.TESTING, label: 'Testing in progress' },
    { value: CAUSE_STATUSES.EXPLAINED, label: 'Explains evidence' },
    { value: CAUSE_STATUSES.FAILED, label: 'Failed testing' }
  ].forEach(opt=>{
    const option = document.createElement('option');
    option.value = opt.value;
    option.textContent = opt.label;
    statusSelect.appendChild(option);
  });
  statusSelect.value = normalizeCauseStatus(cause.status);
  statusField.append(statusLegend, statusSelect);

  form.append(suspectField, hypothesisField, impactField, assumptionsField, statusField);

  const evidenceSection = document.createElement('div');
  evidenceSection.className = 'cause-test';
  const evidenceIntro = document.createElement('p');
  evidenceIntro.className = 'cause-test__intro';
  evidenceIntro.textContent = 'Compare this cause against the KT IS / IS NOT evidence.';
  evidenceSection.appendChild(evidenceIntro);

  const evidenceEmpty = document.createElement('div');
  evidenceEmpty.className = 'cause-evidence-empty';
  evidenceEmpty.textContent = 'Fill in the KT table above to evaluate evidence for this cause.';
  evidenceSection.appendChild(evidenceEmpty);

  indexSnapshot.forEach(rowIndex=>{
    const row = rowsBuilt[rowIndex];
    if(!row) return;
    const rowKey = getRowKeyByIndex(rowIndex);
    const finding = peekCauseFinding(cause, rowKey) || null;
    const evidenceRow = document.createElement('div');
    evidenceRow.className = 'cause-eval-row';
    evidenceRow.dataset.rowIndex = String(rowIndex);
    evidenceRow.dataset.rowKey = rowKey;

    const questionText = document.createElement('div');
    questionText.className = 'cause-eval-question-text';
    questionText.textContent = row?.th?.textContent?.trim() || fillTokens(row?.def?.q || `Row ${rowIndex+1}`);

    const evidenceWrap = document.createElement('div');
    evidenceWrap.className = 'cause-evidence-wrap';
    const blocks = [
      { label:'IS', role:'is' },
      { label:'IS NOT', role:'is-not' },
      { label:'Distinctions', role:'dist' },
      { label:'Changes', role:'chg' }
    ];
    blocks.forEach(info=>{
      const block = document.createElement('div');
      block.className = 'cause-evidence-block';
      const blockLabel = document.createElement('div');
      blockLabel.className = 'cause-evidence-label';
      blockLabel.textContent = info.label;
      const blockText = document.createElement('div');
      blockText.className = 'cause-evidence-text';
      blockText.dataset.evidenceRole = info.role;
      blockText.textContent = '—';
      block.append(blockLabel, blockText);
      evidenceWrap.appendChild(block);
    });

    const inputsWrap = document.createElement('div');
    inputsWrap.className = 'cause-eval-inputs';
    const optionsWrap = document.createElement('div');
    optionsWrap.className = 'cause-eval-options';
    const noteWrap = document.createElement('div');
    noteWrap.className = 'field cause-eval-note';
    const noteLabel = document.createElement('label');
    noteLabel.textContent = 'Evidence notes';
    const noteTextarea = document.createElement('textarea');
    noteTextarea.value = findingNote(finding);
    noteWrap.append(noteLabel, noteTextarea);

    const optionConfigs = [
      { value: CAUSE_FINDING_MODES.YES, label: 'Explains evidence' },
      { value: CAUSE_FINDING_MODES.ASSUMPTION, label: 'Needs assumption' },
      { value: CAUSE_FINDING_MODES.FAIL, label: 'Fails evidence' },
      { value: CAUSE_FINDING_MODES.UNKNOWN, label: 'Not evaluated' }
    ];
    optionConfigs.forEach(config=>{
      const btn = document.createElement('button');
      btn.type = 'button';
      btn.className = 'cause-eval-option';
      btn.dataset.mode = config.value;
      btn.textContent = config.label;
      if(config.value === findingMode(finding) || (!findingMode(finding) && config.value === CAUSE_FINDING_MODES.UNKNOWN)){
        btn.classList.add('is-selected');
      }
      btn.addEventListener('click', ()=>{
        const next = config.value;
        const entry = ensureFinding(cause, rowKey);
        entry.mode = next;
        if(next === CAUSE_FINDING_MODES.UNKNOWN && !findingNote(entry).trim()){
          delete cause.findings[rowKey];
        }
        optionsWrap.querySelectorAll('.cause-eval-option').forEach(other=>{
          other.classList.toggle('is-selected', other === btn);
        });
        refreshHeader();
        if(typeof saveToStorage === 'function'){
          saveToStorage();
        }
      });
      optionsWrap.appendChild(btn);
    });

    autoResize(noteTextarea);
    noteTextarea.addEventListener('input', ()=>{
      const entry = ensureFinding(cause, rowKey);
      entry.note = noteTextarea.value;
      autoResize(noteTextarea);
      if(!findingMode(entry) && !entry.note.trim()){
        delete cause.findings[rowKey];
      }
      refreshHeader();
      if(typeof saveToStorage === 'function'){
        saveToStorage();
      }
    });

    inputsWrap.append(optionsWrap, noteWrap);

    evidenceRow.append(questionText, evidenceWrap, inputsWrap);
    evidenceSection.appendChild(evidenceRow);
  });

  card.append(header, summaryEl, form, evidenceSection);

  function refreshHeader(){
    const displayIndex = index + 1;
    titleEl.textContent = cause.name?.trim() ? cause.name.trim() : `Possible Cause ${displayIndex}`;
    summaryEl.textContent = buildHypothesisSentence(cause);
    const indexes = evidencePairIndexes();
    const hasEvidence = indexes.length > 0;
    const chipValue = hasEvidence ? normalizeCauseStatus(cause.status) : 'no-evidence';
    statusChip.dataset.status = chipValue;
    statusChip.textContent = causeStatusLabel(cause);
    const failure = causeHasFailure(cause);
    card.dataset.failed = failure ? 'true' : 'false';
    failureBadge.hidden = !failure;
    const assumptionsTotal = countCauseAssumptions(cause);
    if(assumptionsTotal > 0){
      assumptionBadge.textContent = `${assumptionsTotal} assumption${assumptionsTotal===1?'':'s'}`;
      assumptionBadge.hidden = false;
    }else{
      assumptionBadge.hidden = true;
    }
    progressEl.textContent = causeProgressSummary ? causeProgressSummary(cause) : '';
    toggleBtn.textContent = cause.editing ? 'Done' : 'Edit';
  }

  toggleBtn.addEventListener('click', ()=>{
    cause.editing = !cause.editing;
    card.dataset.editing = cause.editing ? 'true' : 'false';
    refreshHeader();
    if(cause.editing){
      const firstField = card.querySelector('input, textarea, select');
      firstField?.focus();
    }
    if(typeof saveToStorage === 'function'){
      saveToStorage();
    }
  });

  removeBtn.addEventListener('click', ()=>{
    const idx = possibleCauses.findIndex(item=>item && item.id === cause.id);
    if(idx !== -1){
      possibleCauses.splice(idx, 1);
      renderCauses();
      updateCauseEvidencePreviews();
      if(typeof saveToStorage === 'function'){
        saveToStorage();
      }
    }
  });

  suspectInput.addEventListener('input', ()=>{
    cause.name = suspectInput.value;
    cause.editing = true;
    refreshHeader();
    if(typeof saveToStorage === 'function'){
      saveToStorage();
    }
  });

  [hypothesisTextarea, impactTextarea, assumptionsTextarea].forEach(textarea=>{
    autoResize(textarea);
  });

  hypothesisTextarea.addEventListener('input', ()=>{
    cause.hypothesis = hypothesisTextarea.value;
    cause.editing = true;
    autoResize(hypothesisTextarea);
    refreshHeader();
    if(typeof saveToStorage === 'function'){
      saveToStorage();
    }
  });

  impactTextarea.addEventListener('input', ()=>{
    cause.impact = impactTextarea.value;
    cause.editing = true;
    autoResize(impactTextarea);
    refreshHeader();
    if(typeof saveToStorage === 'function'){
      saveToStorage();
    }
  });

  assumptionsTextarea.addEventListener('input', ()=>{
    cause.assumptions = assumptionsTextarea.value;
    cause.editing = true;
    autoResize(assumptionsTextarea);
    refreshHeader();
    if(typeof saveToStorage === 'function'){
      saveToStorage();
    }
  });

  statusSelect.addEventListener('change', ()=>{
    cause.status = normalizeCauseStatus(statusSelect.value);
    cause.editing = true;
    refreshHeader();
    if(typeof saveToStorage === 'function'){
      saveToStorage();
    }
  });

  refreshHeader();
  card._refreshHeader = refreshHeader;
  return card;
}

function updateCauseEvidencePreviews(){
  if(!causeList) return;
  possibleCauses.forEach(cause=>{
    const card = causeList.querySelector(`.cause-card[data-cause-id="${cause.id}"]`);
    if(!card) return;
    const rows = card.querySelectorAll('.cause-eval-row');
    let visible = 0;
    rows.forEach(rowEl=>{
      const index = Number.parseInt(rowEl.dataset.rowIndex || '-1', 10);
      const data = rowsBuilt[index];
      if(!data){
        rowEl.hidden = true;
        return;
      }
      const isText = inlineText(data.isTA?.value || '');
      const notText = inlineText(data.notTA?.value || '');
      const distText = inlineText(data.distTA?.value || '');
      const chgText = inlineText(data.chgTA?.value || '');
      const hasContent = !!(isText || notText || distText || chgText);
      rowEl.hidden = !hasContent;
      if(hasContent) visible++;
      rowEl.querySelector('[data-evidence-role="is"]').textContent = isText || '—';
      rowEl.querySelector('[data-evidence-role="is-not"]').textContent = notText || '—';
      rowEl.querySelector('[data-evidence-role="dist"]').textContent = distText || '—';
      rowEl.querySelector('[data-evidence-role="chg"]').textContent = chgText || '—';

      const rowKey = rowEl.dataset.rowKey;
      const finding = peekCauseFinding(cause, rowKey);
      const mode = findingMode(finding);
      const note = findingNote(finding);
      const buttons = rowEl.querySelectorAll('.cause-eval-option');
      buttons.forEach(btn=>{
        const targetMode = btn.dataset.mode;
        const isUnknown = !mode && targetMode === CAUSE_FINDING_MODES.UNKNOWN;
        btn.classList.toggle('is-selected', targetMode === mode || isUnknown);
      });
      const noteArea = rowEl.querySelector('textarea');
      if(noteArea && noteArea.value !== note){
        noteArea.value = note;
        autoResize(noteArea);
      }
    });
    const empty = card.querySelector('.cause-evidence-empty');
    if(empty){
      empty.hidden = visible > 0;
    }
    card._refreshHeader?.();
  });
}

function focusFirstEditableCause(){
  requestAnimationFrame(()=>{
    if(!causeList) return;
    const target = possibleCauses.find(cause=>cause && cause.editing);
    if(!target) return;
    const card = causeList.querySelector(`.cause-card[data-cause-id="${target.id}"]`);
    if(!card) return;
    const field = card.querySelector('input, textarea, select');
    field?.focus();
  });
}

function peekCauseFinding(cause, key){
  if(!cause || !cause.findings || typeof key !== 'string') return null;
  return cause.findings[key] || null;
}

function ensureFinding(cause, key){
  if(!cause) return { mode:'', note:'' };
  if(!cause.findings) cause.findings = {};
  if(!cause.findings[key]){
    cause.findings[key] = { mode: CAUSE_FINDING_MODES.UNKNOWN, note: '' };
  }
  return cause.findings[key];
}

function findingMode(entry){
  if(!entry) return '';
  const value = typeof entry.mode === 'string' ? entry.mode.trim().toLowerCase() : '';
  if(value === CAUSE_FINDING_MODES.YES || value === CAUSE_FINDING_MODES.FAIL || value === CAUSE_FINDING_MODES.ASSUMPTION){
    return value;
  }
  return '';
}

function findingNote(entry){
  if(!entry) return '';
  return typeof entry.note === 'string' ? entry.note : '';
}

function causeStatusLabel(cause){
  const status = normalizeCauseStatus(cause?.status);
  return CAUSE_STATUS_LABELS[status] || CAUSE_STATUS_LABELS[CAUSE_STATUSES.DRAFT];
}

function buildHypothesisSentence(cause){
  if(!cause) return '';
  const parts = [];
  if(cause.name && cause.name.trim()) parts.push(cause.name.trim());
  if(cause.hypothesis && cause.hypothesis.trim()) parts.push(cause.hypothesis.trim());
  if(cause.impact && cause.impact.trim()) parts.push(`Impact: ${cause.impact.trim()}`);
  return parts.length ? parts.join(' — ') : 'Describe why this could be the cause and the impact if confirmed.';
}

function countAssumptionFindings(cause){
  if(!cause || !cause.findings) return 0;
  return Object.values(cause.findings).reduce((total, entry)=>{
    return total + (findingMode(entry) === CAUSE_FINDING_MODES.ASSUMPTION ? 1 : 0);
  }, 0);
}

function countCauseAssumptions(cause){
  if(!cause) return 0;
  const lines = splitLines(cause.assumptions); // already trims and filters
  return lines.length + countAssumptionFindings(cause);
}

function causeHasFailure(cause){
  if(!cause) return false;
  if(normalizeCauseStatus(cause.status) === CAUSE_STATUSES.FAILED) return true;
  return Object.values(cause.findings || {}).some(entry=>findingMode(entry) === CAUSE_FINDING_MODES.FAIL);
}

function countCompletedEvidence(cause, indexes){
  if(!cause || !Array.isArray(indexes)) return 0;
  let count = 0;
  indexes.forEach(index=>{
    const key = getRowKeyByIndex(index);
    const entry = peekCauseFinding(cause, key);
    const mode = findingMode(entry);
    if(mode === CAUSE_FINDING_MODES.YES || mode === CAUSE_FINDING_MODES.FAIL){
      count++;
    }
  });
  return count;
}

function getRowKeyByIndex(index){
  const row = rowsBuilt[index];
  if(!row) return `row-${index}`;
  const base = typeof row.def?.q === 'string' ? row.def.q : `row-${index}`;
  return base;
}

function evidencePairIndexes(){
  const indexes = [];
  rowsBuilt.forEach((row, index)=>{
    if(!row) return;
    const hasContent = [row.isTA, row.notTA, row.distTA, row.chgTA].some(el=>el && el.value && el.value.trim());
    if(hasContent){
      indexes.push(index);
    }
  });
  return indexes;
}

function serializeCauses(){
  if(!Array.isArray(possibleCauses)) return [];
  return possibleCauses.map(cause=>({
    id: cause.id,
    name: cause.name || '',
    hypothesis: cause.hypothesis || '',
    impact: cause.impact || '',
    assumptions: cause.assumptions || '',
    status: normalizeCauseStatus(cause.status),
    editing: !!cause.editing,
    findings: serializeFindings(cause.findings)
  }));
}

function serializeFindings(map){
  const out = {};
  if(!map || typeof map !== 'object') return out;
  Object.entries(map).forEach(([key, entry])=>{
    const mode = findingMode(entry);
    const note = findingNote(entry);
    if(mode || note.trim()){
      out[key] = { mode, note };
    }
  });
  return out;
}

function deserializeCauses(list){
  if(!Array.isArray(list)) return [];
  return list.map(item=>{
    const cause = createEmptyCause();
    cause.id = typeof item?.id === 'string' ? item.id : createCauseId();
    cause.name = typeof item?.name === 'string' ? item.name : '';
    cause.hypothesis = typeof item?.hypothesis === 'string' ? item.hypothesis : '';
    cause.impact = typeof item?.impact === 'string' ? item.impact : '';
    cause.assumptions = typeof item?.assumptions === 'string' ? item.assumptions : '';
    cause.status = normalizeCauseStatus(item?.status);
    cause.editing = !!item?.editing;
    cause.findings = deserializeFindings(item?.findings);
    return cause;
  });
}

function deserializeFindings(map){
  const out = {};
  if(!map || typeof map !== 'object') return out;
  Object.entries(map).forEach(([key, entry])=>{
    const mode = findingMode(entry);
    const note = findingNote(entry);
    if(mode || note.trim()){
      out[key] = { mode, note };
    }
  });
  return out;
}
let objectIS = null;     // first WHAT → IS
let deviationIS = null;  // second WHAT → IS
let objectISDirty = false;
let deviationISDirty = false;

function mkBand(title, note){
  const tr = document.createElement('tr'); tr.className='band';
  const th = document.createElement('th'); th.colSpan = 5; th.innerHTML = `${title} <span>— ${note}</span>`;
  tr.appendChild(th); return tr;
}
function mkRow(def, i){
  const tr = document.createElement('tr'); tr.dataset.row = i;
  const th = document.createElement('th'); th.scope='row'; th.textContent = fillTokens(def.q);

  const tdIS = document.createElement('td');
  const tdNOT = document.createElement('td');
  const tdDIST = document.createElement('td');
  const tdCHG = document.createElement('td');

  const isTA  = document.createElement('textarea'); isTA.className='tableta';
  const notTA = document.createElement('textarea'); notTA.className='tableta';
  const distTA= document.createElement('textarea'); distTA.className='tableta';
  const chgTA = document.createElement('textarea'); chgTA.className='tableta';

  isTA.placeholder   = fillTokens(def.isPH || "");
  notTA.placeholder  = mkIsNotPH(fillTokens(def.notPH || ""), "");
  distTA.placeholder = mkDistPH("", "");
  chgTA.placeholder  = mkChangePH("");

  const refreshIsNotPH = ()=> notTA.placeholder = mkIsNotPH(fillTokens(def.notPH||""), isTA.value);
  const refreshDistPH  = ()=> distTA.placeholder = mkDistPH(isTA.value, notTA.value);
  const refreshChgPH   = ()=> chgTA.placeholder  = mkChangePH(distTA.value);

  [isTA,notTA,distTA,chgTA].forEach(t=>{
    autoResize(t);
    t.addEventListener('input', ()=>{
      autoResize(t);
      if(t===isTA){
        refreshIsNotPH();
        refreshDistPH();
      }else if(t===notTA){
        refreshDistPH();
      }else if(t===distTA){
        refreshChgPH();
      }
      saveToStorage();
      if(t===isTA || t===notTA){
        renderCauses();
      }else{
        updateCauseEvidencePreviews();
      }
    });
  });

  tdIS.appendChild(isTA); tdNOT.appendChild(notTA); tdDIST.appendChild(distTA); tdCHG.appendChild(chgTA);
  tr.append(th, tdIS, tdNOT, tdDIST, tdCHG);

  rowsBuilt.push({tr, th, def, isTA, notTA, distTA, chgTA});
  return tr;
}
function initTable(){
  let dataRowCount = 0;
  ROWS.forEach((def)=>{
    if(def.band){ tbody.appendChild(mkBand(def.band, def.note||'')); }
    else{
      const tr = mkRow(def, ++dataRowCount);
      tbody.appendChild(tr);
      if(dataRowCount===1) objectIS   = rowsBuilt[rowsBuilt.length-1].isTA;  // first data row IS
      if(dataRowCount===2) deviationIS= rowsBuilt[rowsBuilt.length-1].isTA;  // second data row IS
    }
  });

  [objectIS, deviationIS].forEach(el=>{
    el.addEventListener('input', ()=>{
      if(el===objectIS) objectISDirty = true;
      if(el===deviationIS) deviationISDirty = true;
      refreshAllTokenizedText();
      updateTitlesAndLabels();
      saveToStorage();
    });
  });
}
/* [script:table-build] end */

/* [script:preface-refs] start */
/* =================== Preface helpers & H1/H2 =================== */
const oneLine = document.getElementById('oneLine');
const proof = document.getElementById('proof');
const objectPrefill = document.getElementById('objectPrefill');
const healthy = document.getElementById('healthy');
const now = document.getElementById('now');

const bridgeOpenedUtc = document.getElementById('bridgeOpenedUtc');
const bridgeSetNowBtn = document.getElementById('bridgeSetNowBtn');
const icName = document.getElementById('icName');
const bcName = document.getElementById('bcName');
const semOpsName = document.getElementById('semOpsName');
const severity = document.getElementById('severity');

const detectMonitoring = document.getElementById('detectMonitoring');
const detectUserReport = document.getElementById('detectUserReport');
const detectAutomation = document.getElementById('detectAutomation');
const detectOther = document.getElementById('detectOther');

const evScreenshot = document.getElementById('evScreenshot');
const evLogs = document.getElementById('evLogs');
const evMetrics = document.getElementById('evMetrics');
const evRepro = document.getElementById('evRepro');
const evOther = document.getElementById('evOther');

const labelHealthy = document.getElementById('labelHealthy');
const labelNow = document.getElementById('labelNow');

const docTitle = document.getElementById('docTitle');
const docSubtitle = document.getElementById('docSubtitle');

const impactNow = document.getElementById('impactNow');
const impactFuture = document.getElementById('impactFuture');
const impactTime = document.getElementById('impactTime');

const containNone = document.getElementById('containNone');
const containMitigation = document.getElementById('containMitigation');
const containRestore = document.getElementById('containRestore');
const containDesc = document.getElementById('containDesc');

const commInternalStampBtn = document.getElementById('commInternalStampBtn');
const commExternalStampBtn = document.getElementById('commExternalStampBtn');
const commNextUpdateTime = document.getElementById('commNextUpdateTime');
const commControlsCard = document.getElementById('commControlsCard');
const commCadenceGroup = document.getElementById('commCadenceGroup');
const commCadenceRadios = commCadenceGroup ? [...commCadenceGroup.querySelectorAll('input[name="commCadence"]')] : [];
const commCountdown = document.getElementById('commCountdown');
const commDueAlert = document.getElementById('commDueAlert');
const commLogList = document.getElementById('commLogList');
const commLogToggleBtn = document.getElementById('commLogToggleBtn');
let causeList = document.getElementById('causeList');
let addCauseBtn = document.getElementById('addCauseBtn');

let commLog = [];
let commCadence = '';
let commNextDueIso = '';
let cadenceTimerId = null;
let dueToastShown = false;
let commShowAll = false;

[oneLine, proof, objectPrefill, healthy, now].forEach(el=>{
  el.addEventListener('input', ()=>{
    // If the table fields are empty, seed them from preface
    if(el===objectPrefill && objectIS && !objectIS.value.trim()){
      objectIS.value = el.value.trim(); autoResize(objectIS);
      refreshAllTokenizedText();
    }
    if(el===now && deviationIS && !deviationIS.value.trim()){
      deviationIS.value = el.value.trim(); autoResize(deviationIS);
      refreshAllTokenizedText();
    }
    if(el===oneLine && deviationIS && !deviationIS.value.trim()){
      deviationIS.value = el.value.trim(); autoResize(deviationIS);
      refreshAllTokenizedText();
    }
    updateTitlesAndLabels();
    saveToStorage();
  });
  el.addEventListener('keyup', syncMirror);
  el.addEventListener('change', ()=>syncMirror(true));
});

[icName, bcName, semOpsName].forEach(el=>{
  if(el){ el.addEventListener('input', saveToStorage); }
});
[severity].forEach(el=>{
  if(el){ el.addEventListener('change', saveToStorage); }
});

if(commNextUpdateTime){
  commNextUpdateTime.addEventListener('change', ()=>{
    applyManualDueValue(commNextUpdateTime.value);
    saveToStorage();
  });
}

if(commCadenceRadios.length){
  commCadenceRadios.forEach(radio=>{
    radio.addEventListener('change', ()=>{
      if(!radio.checked) return;
      commCadence = radio.value;
      dueToastShown = false;
      if(commLog.length){
        const lastIso = commLog[0]?.ts;
        if(lastIso){
          const base = new Date(lastIso);
          if(!Number.isNaN(base.valueOf())){
            const mins = getCadenceMinutes();
            if(mins){
              base.setMinutes(base.getMinutes() + mins);
              setNextDue(base);
            }
          }
        }
      }
      scheduleCadenceTick();
      saveToStorage();
    });
  });
}

[
  detectMonitoring,
  detectUserReport,
  detectAutomation,
  detectOther,
  evScreenshot,
  evLogs,
  evMetrics,
  evRepro,
  evOther,
  containNone,
  containMitigation,
  containRestore
].forEach(el=>{ if(el){ el.addEventListener('change', saveToStorage); } });

if(containDesc){ containDesc.addEventListener('input', saveToStorage); }

if(bridgeSetNowBtn){
  bridgeSetNowBtn.addEventListener('click', ()=>{
    bridgeOpenedUtc.value = new Date().toISOString();
    saveToStorage();
    bridgeOpenedUtc.focus();
  });
}

if(commInternalStampBtn){
  commInternalStampBtn.addEventListener('click', ()=>logCommunication('internal'));
}

if(commExternalStampBtn){
  commExternalStampBtn.addEventListener('click', ()=>logCommunication('external'));
}

if(commLogToggleBtn){
  commLogToggleBtn.addEventListener('click', ()=>{
    commShowAll = !commShowAll;
    updateCommLogUI();
  });
}

updateCommLogUI();
scheduleCadenceTick();

function getCadenceMinutes(){
  const mins = parseInt(commCadence, 10);
  return Number.isFinite(mins) ? mins : null;
}

function updateCadenceRadios(){
  if(!commCadenceRadios.length) return;
  commCadenceRadios.forEach(radio=>{
    radio.checked = radio.value === commCadence;
  });
}

function toTimeValue(date){
  if(!(date instanceof Date) || Number.isNaN(date.valueOf())) return '';
  const h = String(date.getHours()).padStart(2,'0');
  const m = String(date.getMinutes()).padStart(2,'0');
  return `${h}:${m}`;
}

function isoFromTimeValue(value){
  if(!value) return '';
  const parts = value.split(':');
  if(parts.length < 2) return '';
  const [hh, mm] = parts.map(Number);
  if(Number.isNaN(hh) || Number.isNaN(mm)) return '';
  const now = new Date();
  const candidate = new Date(now);
  candidate.setHours(hh, mm, 0, 0);
  if(candidate.getTime() <= now.getTime()){
    candidate.setDate(candidate.getDate() + 1);
  }
  return candidate.toISOString();
}

function toggleCommDue(isDue){
  if(commControlsCard){
    commControlsCard.classList.toggle('communication-due', !!isDue);
  }
  if(commDueAlert){
    if(isDue){
      commDueAlert.textContent = 'Next communication is due now. Reconfirm updates.';
      commDueAlert.hidden = false;
    }else{
      commDueAlert.textContent = '';
      commDueAlert.hidden = true;
    }
  }
}

function formatCountdown(ms){
  const totalSeconds = Math.max(0, Math.round(ms/1000));
  const mins = Math.floor(totalSeconds/60);
  const secs = totalSeconds % 60;
  if(mins >= 60){
    const hours = Math.floor(mins/60);
    const rem = mins % 60;
    return `${hours}h ${rem}m`;
  }
  if(mins > 0){
    return `${mins}m ${String(secs).padStart(2,'0')}s`;
  }
  return `${secs}s`;
}

function updateCommLogUI(){
  if(!commLogList) return;
  commLogList.innerHTML = '';
  if(!commLog.length){
    const li = document.createElement('li');
    li.className = 'comm-log__empty';
    li.textContent = 'No communications logged yet.';
    commLogList.appendChild(li);
    if(commLogToggleBtn){
      commLogToggleBtn.hidden = true;
      commLogToggleBtn.setAttribute('aria-expanded', 'false');
    }
    return;
  }
  const limit = 6;
  const entries = commShowAll ? commLog : commLog.slice(0, limit);
  entries.forEach(entry=>{
    const li = document.createElement('li');
    const typeSpan = document.createElement('span');
    typeSpan.className = 'comm-log__type';
    typeSpan.textContent = entry.type === 'external' ? 'External' : 'Internal';
    li.appendChild(typeSpan);
    if(entry.message){
      const messageSpan = document.createElement('span');
      messageSpan.className = 'comm-log__message';
      messageSpan.textContent = entry.message;
      li.appendChild(messageSpan);
    }
    const timeEl = document.createElement('time');
    timeEl.className = 'comm-log__time';
    if(entry.ts){
      const d = new Date(entry.ts);
      if(!Number.isNaN(d.valueOf())){
        timeEl.dateTime = entry.ts;
        timeEl.textContent = d.toLocaleString([], { hour:'2-digit', minute:'2-digit', second:'2-digit', hour12:false });
      }else{
        timeEl.textContent = entry.ts;
      }
    }
    li.appendChild(timeEl);
    commLogList.appendChild(li);
  });
  if(commLogToggleBtn){
    const hasExtra = commLog.length > limit;
    commLogToggleBtn.hidden = !hasExtra;
    if(hasExtra){
      commLogToggleBtn.textContent = commShowAll ? 'Show less' : 'Show all';
      commLogToggleBtn.setAttribute('aria-expanded', commShowAll ? 'true' : 'false');
    }else{
      commLogToggleBtn.setAttribute('aria-expanded', 'false');
    }
  }
}

function setNextDue(date){
  if(!(date instanceof Date) || Number.isNaN(date.valueOf())) return;
  commNextDueIso = date.toISOString();
  const val = toTimeValue(date);
  if(commNextUpdateTime){ commNextUpdateTime.value = val; }
  dueToastShown = false;
  scheduleCadenceTick();
}

function applyManualDueValue(value){
  if(!value){
    commNextDueIso = '';
    dueToastShown = false;
    if(commNextUpdateTime){ commNextUpdateTime.value = ''; }
    toggleCommDue(false);
    if(commCountdown){ commCountdown.textContent = ''; }
    return;
  }
  const iso = isoFromTimeValue(value);
  if(!iso) return;
  commNextDueIso = iso;
  if(commNextUpdateTime){ commNextUpdateTime.value = value; }
  toggleCommDue(false);
  dueToastShown = false;
  scheduleCadenceTick();
  updateCadenceState();
}

function updateCadenceState(){
  if(!commCountdown) return;
  if(!commNextDueIso){
    commCountdown.textContent = '';
    toggleCommDue(false);
    return;
  }
  const now = new Date();
  const due = new Date(commNextDueIso);
  if(Number.isNaN(due.valueOf())){
    commCountdown.textContent = '';
    toggleCommDue(false);
    return;
  }
  const diff = due.getTime() - now.getTime();
  if(diff <= 0){
    commCountdown.textContent = 'Due now';
    toggleCommDue(true);
    if(!dueToastShown){
      dueToastShown = true;
      if(typeof showToast === 'function'){ showToast('Next communication is due now.'); }
    }
    return;
  }
  commCountdown.textContent = `Next in ${formatCountdown(diff)}`;
  toggleCommDue(false);
}

function scheduleCadenceTick(){
  if(cadenceTimerId){ clearInterval(cadenceTimerId); }
  cadenceTimerId = setInterval(updateCadenceState, 15000);
  updateCadenceState();
}

function logCommunication(type, message=''){
  const now = new Date();
  const iso = now.toISOString();
  const entry = { type, ts: iso };
  if(typeof message === 'string' && message.trim()){
    entry.message = message.trim();
  }
  commLog.unshift(entry);
  commLog = commLog.slice(0, 20);
  commShowAll = false;
  updateCommLogUI();
  const mins = getCadenceMinutes();
  if(mins){
    const due = new Date(now);
    due.setMinutes(due.getMinutes() + mins);
    setNextDue(due);
  }
  saveToStorage();
}
/* [script:preface-refs] end */

/* ===== Steps Checklist ===== */
const STEPS_ITEMS_KEY = 'steps.items';
const STEPS_DRAWER_KEY = 'steps.drawerOpen';
const STEPS_PHASES = [
  { id:'A', label:'Activate & Frame' },
  { id:'B', label:'Hypothesize, Test & Communicate' },
  { id:'C', label:'Evaluate & Decide' },
  { id:'D', label:'Restore, Validate & Close Comms Loop' },
  { id:'E', label:'Handover & Close' }
];
const STEP_DEFINITIONS = [
  { id:'1', phase:'A', label:'Pre-analysis completed' },
  { id:'2', phase:'A', label:'Incident Commander assigned' },
  { id:'3', phase:'A', label:'Step 1 reviewed by BC' },
  { id:'4', phase:'A', label:'Problem statement created' },
  { id:'5', phase:'A', label:'Bridge options considered' },
  { id:'6', phase:'A', label:'Bridges opened and responders invited' },
  { id:'7', phase:'A', label:'Bridge etiquette, roles, and guidelines outlined' },
  { id:'8', phase:'A', label:'Current actions documented (Who/What/When)' },
  { id:'9', phase:'A', label:'Quick spec answers captured' },
  { id:'10', phase:'A', label:'Last changes, monitoring, and dependencies investigated' },
  { id:'11', phase:'A', label:'Attendees optimized' },
  { id:'12', phase:'B', label:'Possible causes developed' },
  { id:'13', phase:'B', label:'Testing actions documented (Who/What/When)' },
  { id:'14', phase:'B', label:'Micro-experiments/tests conducted' },
  { id:'15', phase:'B', label:'Containment options identified' },
  { id:'16', phase:'B', label:'Comms written, reviewed, and sent' },
  { id:'17', phase:'B', label:'Attendees optimized for next action' },
  { id:'18', phase:'C', label:'Possible causes evaluated and distinctions identified' },
  { id:'19', phase:'C', label:'Most probable cause identified' },
  { id:'20', phase:'C', label:'Restoration/rollback/workaround selected' },
  { id:'21', phase:'C', label:'Attendees optimized for decision' },
  { id:'22', phase:'C', label:'Verification and risk plan created' },
  { id:'23', phase:'D', label:'Restoration actions documented (Who/What/When)' },
  { id:'24', phase:'D', label:'Service validated internally and externally' },
  { id:'25', phase:'D', label:'Restoration comms sent' },
  { id:'26', phase:'E', label:'Handover template prepared (PIR/problem)' },
  { id:'27', phase:'E', label:'Downstream issues from fix assessed' },
  { id:'28', phase:'E', label:'Participants released and bridge closed' }
];

let stepsBtn = null;
let stepsCompletedLabel = null;
let stepsDrawer = null;
let stepsBackdrop = null;
let stepsList = null;
let stepsCloseBtn = null;
let stepsDrawerProgress = null;
let stepsItems = STEP_DEFINITIONS.map(def=>({ id:def.id, phase:def.phase, label:def.label, checked:false }));
let stepsDrawerOpen = false;
let stepsReady = false;
let stepsReturnFocus = null;

function parseJsonSafe(value){
  if(!value) return null;
  try{
    return JSON.parse(value);
  }catch(_){
    return null;
  }
}

function hydrateStepsFromLocalStorage(){
  const storedItems = parseJsonSafe(localStorage.getItem(STEPS_ITEMS_KEY));
  const map = new Map();
  if(Array.isArray(storedItems)){
    storedItems.forEach(item=>{
      if(!item || item.id === undefined) return;
      const key = String(item.id);
      map.set(key, {
        checked: !!item.checked,
        label: typeof item.label === 'string' ? item.label : ''
      });
    });
  }
  stepsItems = STEP_DEFINITIONS.map(def=>{
    const stored = map.get(def.id);
    return {
      id: def.id,
      phase: def.phase,
      label: stored && stored.label ? stored.label : def.label,
      checked: stored ? !!stored.checked : false
    };
  });
  const storedDrawer = parseJsonSafe(localStorage.getItem(STEPS_DRAWER_KEY));
  if(typeof storedDrawer === 'boolean'){
    stepsDrawerOpen = storedDrawer;
  }
}

function saveStepsItemsToLocalStorage(){
  try{
    const payload = stepsItems.map(item=>({ id:item.id, label:item.label, checked:!!item.checked }));
    localStorage.setItem(STEPS_ITEMS_KEY, JSON.stringify(payload));
  }catch(_){ /* ignore */ }
}

function saveStepsDrawerStateToLocalStorage(){
  try{
    localStorage.setItem(STEPS_DRAWER_KEY, JSON.stringify(!!stepsDrawerOpen));
  }catch(_){ /* ignore */ }
}

function getStepsCounts(){
  const total = stepsItems.length;
  const completed = stepsItems.filter(item=>item.checked).length;
  return { total, completed };
}

function formatStepsBadge(){
  const { total, completed } = getStepsCounts();
  return `${completed} of ${total}`;
}

function formatStepsDrawerProgress(){
  const { total, completed } = getStepsCounts();
  return `${completed} of ${total} completed`;
}

function updateStepsProgressUI(){
  const badgeText = formatStepsBadge();
  if(stepsCompletedLabel){
    stepsCompletedLabel.textContent = badgeText;
  }
  if(stepsDrawerProgress){
    stepsDrawerProgress.textContent = formatStepsDrawerProgress();
  }
}

function getDrawerFocusables(){
  if(!stepsDrawer) return [];
  const nodes = stepsDrawer.querySelectorAll('button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])');
  return [...nodes].filter(el=>{
    if(el.hasAttribute('disabled')) return false;
    if(el.getAttribute('aria-hidden') === 'true') return false;
    const rect = el.getBoundingClientRect();
    return rect.width > 0 && rect.height > 0;
  });
}

function renderStepsList(){
  if(!stepsList) return;
  stepsList.innerHTML = '';
  const grouped = new Map();
  stepsItems.forEach(step=>{
    if(!grouped.has(step.phase)){
      grouped.set(step.phase, []);
    }
    grouped.get(step.phase).push(step);
  });
  STEPS_PHASES.forEach(phase=>{
    const items = grouped.get(phase.id);
    if(!items || !items.length) return;
    const details = document.createElement('details');
    details.className = 'steps-category';
    details.open = true;
    const summary = document.createElement('summary');
    summary.className = 'steps-category__header';
    const textWrap = document.createElement('div');
    textWrap.className = 'steps-category__header-text';
    const phaseEl = document.createElement('span');
    phaseEl.className = 'steps-category__phase';
    phaseEl.textContent = `Phase ${phase.id}`;
    const nameEl = document.createElement('span');
    nameEl.className = 'steps-category__name';
    nameEl.textContent = phase.label;
    textWrap.appendChild(phaseEl);
    textWrap.appendChild(nameEl);
    const chevron = document.createElement('span');
    chevron.className = 'steps-category__chevron';
    chevron.setAttribute('aria-hidden', 'true');
    chevron.textContent = '⌄';
    summary.appendChild(textWrap);
    summary.appendChild(chevron);
    details.appendChild(summary);
    const container = document.createElement('div');
    container.className = 'steps-category__items';
    items.forEach(step=>{
      const row = document.createElement('div');
      row.className = 'steps-item';
      const checkbox = document.createElement('input');
      checkbox.type = 'checkbox';
      checkbox.id = `step-${step.id}`;
      checkbox.dataset.stepId = step.id;
      checkbox.checked = !!step.checked;
      const label = document.createElement('label');
      label.htmlFor = checkbox.id;
      label.textContent = step.label;
      checkbox.addEventListener('change', handleStepToggle);
      row.appendChild(checkbox);
      row.appendChild(label);
      container.appendChild(row);
    });
    details.appendChild(container);
    stepsList.appendChild(details);
  });
}

function handleStepToggle(event){
  const checkbox = event.currentTarget;
  if(!checkbox || !checkbox.dataset) return;
  const stepId = checkbox.dataset.stepId;
  const step = stepsItems.find(item=>item.id === stepId);
  if(!step) return;
  step.checked = !!checkbox.checked;
  updateStepsProgressUI();
  saveStepsItemsToLocalStorage();
  if(stepsReady){
    saveToStorage();
  }
  const message = step.checked ? `Step checked: ${step.label}` : `Step unchecked: ${step.label}`;
  logCommunication('internal', message);
}

function handleStepsDrawerKeydown(event){
  if(event.key !== 'Tab') return;
  const focusables = getDrawerFocusables();
  if(!focusables.length){
    event.preventDefault();
    if(stepsCloseBtn){ stepsCloseBtn.focus(); }
    return;
  }
  const index = focusables.indexOf(document.activeElement);
  if(event.shiftKey){
    if(index <= 0){
      event.preventDefault();
      focusables[focusables.length - 1].focus();
    }
  }else{
    if(index === focusables.length - 1){
      event.preventDefault();
      focusables[0].focus();
    }
  }
}

function handleStepsGlobalKeydown(event){
  const key = typeof event.key === 'string' ? event.key.toLowerCase() : '';
  if(key === 's' && event.altKey && !event.ctrlKey && !event.metaKey){
    event.preventDefault();
    toggleStepsDrawer();
    return;
  }
  if(event.key === 'Escape' && stepsDrawerOpen){
    event.preventDefault();
    closeStepsDrawer();
  }
}

function setStepsDrawer(open, options={}){
  const shouldOpen = !!open;
  const skipFocus = !!options.skipFocus;
  const skipSave = !!options.skipSave;
  if(shouldOpen && !stepsDrawerOpen){
    stepsReturnFocus = document.activeElement instanceof HTMLElement ? document.activeElement : null;
  }
  stepsDrawerOpen = shouldOpen;
  if(stepsDrawer){
    stepsDrawer.classList.toggle('is-open', shouldOpen);
    stepsDrawer.setAttribute('aria-hidden', shouldOpen ? 'false' : 'true');
  }
  if(stepsBackdrop){
    stepsBackdrop.classList.toggle('is-open', shouldOpen);
    stepsBackdrop.setAttribute('aria-hidden', shouldOpen ? 'false' : 'true');
  }
  if(stepsBtn){
    stepsBtn.setAttribute('aria-expanded', shouldOpen ? 'true' : 'false');
  }
  document.body.classList.toggle('steps-drawer-open', shouldOpen);
  if(shouldOpen){
    if(!skipFocus){
      const focusables = getDrawerFocusables();
      const target = focusables.length ? focusables[0] : stepsCloseBtn || stepsDrawer;
      requestAnimationFrame(()=>{ target?.focus?.(); });
    }
  }else{
    const target = stepsBtn || stepsReturnFocus;
    if(!skipFocus){
      requestAnimationFrame(()=>{ target?.focus?.(); });
    }
    stepsReturnFocus = null;
  }
  if(stepsDrawerProgress){
    stepsDrawerProgress.textContent = formatStepsDrawerProgress();
  }
  if(!skipSave){
    saveStepsDrawerStateToLocalStorage();
    if(stepsReady){
      saveToStorage();
    }
  }
}

function openStepsDrawer(){ setStepsDrawer(true); }
function closeStepsDrawer(){ setStepsDrawer(false); }
function toggleStepsDrawer(){ setStepsDrawer(!stepsDrawerOpen); }

function exportStepsState(){
  return {
    items: stepsItems.map(item=>({ id:item.id, label:item.label, checked:!!item.checked })),
    drawerOpen: !!stepsDrawerOpen
  };
}

function importStepsState(data){
  if(!data) return;
  let incoming = null;
  if(Array.isArray(data.items)){
    incoming = data.items;
  }else if(Array.isArray(data.steps)){
    incoming = data.steps;
  }
  if(Array.isArray(incoming)){
    const map = new Map();
    incoming.forEach(item=>{
      if(!item) return;
      const key = item.id !== undefined ? String(item.id) : (item.stepId !== undefined ? String(item.stepId) : '');
      if(!key) return;
      map.set(key, {
        checked: !!item.checked,
        label: typeof item.label === 'string' ? item.label : (typeof item.title === 'string' ? item.title : '')
      });
    });
    stepsItems = STEP_DEFINITIONS.map(def=>{
      const stored = map.get(def.id);
      return {
        id: def.id,
        phase: def.phase,
        label: stored && stored.label ? stored.label : def.label,
        checked: stored ? !!stored.checked : false
      };
    });
  }
  if(typeof data.drawerOpen === 'boolean'){
    stepsDrawerOpen = data.drawerOpen;
  }else if(typeof data.open === 'boolean'){
    stepsDrawerOpen = data.open;
  }
  renderStepsList();
  updateStepsProgressUI();
  setStepsDrawer(stepsDrawerOpen, { skipFocus:true, skipSave:true });
  saveStepsItemsToLocalStorage();
  saveStepsDrawerStateToLocalStorage();
}

function initStepsFeature(){
  stepsBtn = document.getElementById('stepsBtn');
  stepsCompletedLabel = document.getElementById('stepsCompletedLabel');
  stepsDrawer = document.getElementById('stepsDrawer');
  stepsBackdrop = document.getElementById('stepsBackdrop');
  stepsList = document.getElementById('stepsList');
  stepsCloseBtn = document.getElementById('stepsCloseBtn');
  stepsDrawerProgress = document.getElementById('stepsDrawerProgress');

  hydrateStepsFromLocalStorage();
  renderStepsList();
  updateStepsProgressUI();
  setStepsDrawer(stepsDrawerOpen, { skipFocus:true, skipSave:true });

  if(stepsBtn){ stepsBtn.addEventListener('click', toggleStepsDrawer); }
  if(stepsCloseBtn){ stepsCloseBtn.addEventListener('click', closeStepsDrawer); }
  if(stepsBackdrop){ stepsBackdrop.addEventListener('click', closeStepsDrawer); }
  if(stepsDrawer){ stepsDrawer.addEventListener('keydown', handleStepsDrawerKeydown); }
  document.addEventListener('keydown', handleStepsGlobalKeydown);
  stepsReady = true;
}

/* [script:tokens] start */
function firstSnippet(v){
  const s = (v||'').trim();
  if(!s) return '';
  // Return the first line or sentence, up to 120 chars (not just one char)
  const first = s.split(/\n|\. /)[0];
  return first.length > 120 ? first.slice(0,120) : first;
}
function compactOneLine(str, max=90){
  const s = (str||'').trim().replace(/\s+/g,' ');
  return s.length>max ? s.slice(0,max-1)+'…' : s;
}
function getObjectFull(){
  return (objectPrefill.value || objectIS?.value || '').trim();
}
function getDeviationFull(){
  // Treat "What is happening now?" as the deviation for the problem statement.
  return (now.value || deviationIS?.value || '').trim();
}
function objectAnchor(){
  // Use a compact anchor for labels (not the full paragraph to keep labels readable)
  const src = getObjectFull() || 'the object';
  return compactOneLine(src, 80);
}
function fillTokens(text){
  const obj = firstSnippet(objectIS?.value)    || firstSnippet(getObjectFull()) || 'the object';
  const dev = firstSnippet(deviationIS?.value) || firstSnippet(getDeviationFull()) || 'the deviation';
  return (text||'').replace(/\{OBJECT\}/g, '“'+obj+'”').replace(/\{DEVIATION\}/g, '“'+dev+'”');
}
function mkIsNotPH(baseCopy, isVal){
  const base = (baseCopy||'').trim();
  const isSnippet = firstSnippet(isVal);
  if(isSnippet){
    const prompt = fillTokens(``);
    return base ? `${prompt}\n\n${base}` : prompt;
  }
  return base || fillTokens('');
}
function mkDistPH(isVal, notVal){
  const base = fillTokens('');
  const isSnippet = firstSnippet(isVal);
  const notSnippet = firstSnippet(notVal);
  const parts = [];
  if(isSnippet){ parts.push(`What is different, odd, special, or uniquely true about “${isSnippet}”?`); }
  if(notSnippet){ parts.push(`Only list traits that are not shared by “${notSnippet}”`); }
  const lead = parts.length ? parts.join(' ') + '' : '';
  return lead ? `${lead}\n${base}` : base;
}
function mkChangePH(distText){
  const base = fillTokens('');
  const distSnippet = firstSnippet(distText);
  if(distSnippet){
    return `What changed in, on, around, or about “${distSnippet}”, Ask this question for each distinction listed.\n${base}`;
  }
  return base;
}
function refreshAllTokenizedText(){
  rowsBuilt.forEach(({th, def, isTA, notTA})=>{
    th.textContent = fillTokens(def.q);
    isTA.placeholder  = fillTokens(def.isPH||"");
    notTA.placeholder = mkIsNotPH(fillTokens(def.notPH||""), isTA.value);
  });
  updateCauseEvidencePreviews();
}
function updateTitlesAndLabels(){
  const objFull = getObjectFull();
  const devFull = getDeviationFull();
  const objAnch = objectAnchor();

  if(objFull && devFull){
    // H1/H2 use the FULL text as requested (concatenated)
    docTitle.textContent = `${objFull} — ${devFull}`;
    docSubtitle.textContent = `What is happening now to ${objAnch}: ${devFull}`;
    document.title = `${compactOneLine(objFull, 50)} — ${compactOneLine(devFull, 50)} · KT Intake`;
  }else{
    docTitle.textContent = "KT Intake";
    docSubtitle.textContent = "Describe Problem";
    document.title = "KT Intake";
  }

  // Dynamic labels for Healthy/Now
  labelNow.textContent = objAnch ? `What is happening now to ${objAnch}?` : "What is happening now?";
  labelHealthy.textContent = objAnch ? `What does healthy look like here for ${objAnch}?` : "What does healthy look like?";

  // (Optional) adjust placeholders subtly to reflect anchor
  if(objAnch){
    now.placeholder = ``;
    healthy.placeholder = ``;
  }
}
/* [script:tokens] end */


/* ===== Mirror Sync (robust against extensions/overlays) ===== */
let _mirrorTick = null;
let _lastPrefObj = "";
let _lastPrefNow = "";
function syncMirror(force=false){
  try{
    const curObj = getObjectFull();
    const curNow = getDeviationFull();
    let changed = false;
    if(force || curObj !== _lastPrefObj){
      _lastPrefObj = curObj;
      if(objectIS && !objectISDirty){
        if(objectIS.value !== curObj){
          objectIS.value = curObj;
          autoResize(objectIS);
          changed = true;
        }
      }
    }
    if(force || curNow !== _lastPrefNow){
      _lastPrefNow = curNow;
      if(deviationIS && !deviationISDirty){
        if(deviationIS.value !== curNow){
          deviationIS.value = curNow;
          autoResize(deviationIS);
          changed = true;
        }
      }
    }
    if(changed || force){
      refreshAllTokenizedText();
      updateTitlesAndLabels();
      saveToStorage();
    }
  }catch(e){ /* no-op */ }
}
/* [script:init] start */
function autoResize(el){
  if(!el || el.tagName !== 'TEXTAREA') return;
  el.style.height = 'auto';
  const attr = parseInt(el.getAttribute('data-min-height') || '', 10);
  const varMin = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--ta-min-h'), 10);
  const fallback = Number.isFinite(varMin) ? varMin : 140;
  const minH = Number.isFinite(attr) ? attr : fallback;
  const base = Number.isFinite(attr) ? attr : 140;
  el.style.height = Math.max(minH, el.scrollHeight, base) + 'px';
}
function init(){
  initTable();
  ensurePossibleCausesUI();
  renderCauses();
  initStepsFeature();
  restoreFromStorage();
  if(bridgeOpenedUtc && !bridgeOpenedUtc.value.trim()){
    bridgeOpenedUtc.value = new Date().toISOString();
    saveToStorage();
  }
  refreshAllTokenizedText();
  updateTitlesAndLabels();
  // Kick off periodic sync to capture extension-driven edits (e.g., Grammarly)
  if(!_mirrorTick){ _mirrorTick = setInterval(syncMirror, 300); }
  // Do an immediate sync so existing values populate
  syncMirror(true);
}
init();
/* [script:init] end */

/* [script:export] start */

/* =================== Summary Export (executive style, chat-friendly) =================== */

function ensureSummaryCard(){
  let card = document.getElementById('summaryCard');
  if(!card){
    const wrap = document.querySelector('.wrap');
    card = document.createElement('div');
    card.className = 'card';
    card.id = 'summaryCard';
    const h = document.createElement('h3'); h.textContent = 'Copy & Paste Summary';
    const pre = document.createElement('pre'); pre.id='summaryPre'; pre.style.whiteSpace='pre-wrap'; pre.style.font='13px/1.6 monospace'; pre.style.margin='0';
    card.appendChild(h); card.appendChild(pre);
    wrap.appendChild(card);
  }
  return card;
}

// Normalize user text into a single logical string for table cells (we’ll wrap visually in the table).
function inlineText(s){
  const v=(s||'').trim();
  if(!v) return '—';
  return v
    .split(/\r?\n/)
    .map(x=>x.trim())
    .filter(Boolean)
    .join(' · ');
}

function inlineSummaryText(s){
  const lines = splitLines(s);
  if(!lines.length) return '';
  return lines.join(' · ');
}

function summaryLine(label, value){
  const text = inlineSummaryText(value);
  if(!text) return '';
  return `${label}: ${text}`;
}

function summaryLineRaw(label, value){
  const text = (value||'').trim();
  if(!text) return '';
  return `${label}: ${text}`;
}

function summaryBullet(label, value){
  const text = inlineSummaryText(value);
  if(!text) return '';
  return `• ${label}: ${text}`;
}

function summaryBulletRaw(label, value){
  const text = (value||'').trim();
  if(!text) return '';
  return `• ${label}: ${text}`;
}

function joinSummaryLines(lines){
  return lines.filter(line=>line && line.trim().length).join('\n');
}

function splitLines(text){
  const v=(text||'').trim();
  if(!v) return [];
  return v.split(/\r?\n/).map(line=>line.trim()).filter(Boolean);
}

function formatLabeledList(label, lines){
  if(!lines.length) return '';
  if(lines.length === 1) return `${label}: ${lines[0]}`;
  const bullets = lines.map(line=>`  • ${line}`).join('\n');
  return `${label}:\n${bullets}`;
}

function formatDistinctionChanges(distLines, changeLines){
  const len = Math.max(distLines.length, changeLines.length);
  if(len === 0) return '';
  if(len === 1){
    const left = distLines[0] || '—';
    const right = changeLines[0] || '—';
    return `Distinctions → Changes: ${left} → ${right}`;
  }
  const pairs = [];
  for(let i=0;i<len;i++){
    const left = distLines[i] || '—';
    const right = changeLines[i] || '—';
    pairs.push(`  • ${left} → ${right}`);
  }
  return ['Distinctions → Changes:', ...pairs].join('\n');
}

function formatChipsetSelections(list){
  const selected = list.filter(item=>item.el?.checked).map(item=>item.label);
  return selected.length ? selected.join(', ') : '';
}

function containmentStatusText(){
  const status = getContainmentStatus();
  if(status==='mitigation') return 'Temporary mitigation applied';
  if(status==='restore') return 'Full restoration in progress';
  if(status==='none') return 'No action yet';
  return '';
}

function latestCommEntry(type){
  if(!Array.isArray(commLog)) return null;
  return commLog.find(entry=>entry && entry.type === type && entry.ts);
}

function formatCommTimestamp(ts){
  if(!ts) return '';
  const d = new Date(ts);
  if(Number.isNaN(d.valueOf())) return ts;
  return d.toISOString();
}

function formatCommSummaryLine(type, label){
  const entry = latestCommEntry(type);
  if(!entry) return '';
  const ts = formatCommTimestamp(entry.ts);
  return ts ? `${label}: ${ts}` : '';
}

function nextUpdateSummaryLine(){
  if(commNextDueIso){
    const d = new Date(commNextDueIso);
    if(!Number.isNaN(d.valueOf())){
      return `Next Update: ${d.toISOString()}`;
    }
    return `Next Update: ${commNextDueIso}`;
  }
  if(commNextUpdateTime?.value){
    return `Next Update: ${commNextUpdateTime.value}`;
  }
  return '';
}

function causeProgressSummary(cause){
  const eligibleIndexes = evidencePairIndexes();
  const total = eligibleIndexes.length;
  if(total === 0) return 'No KT evidence pairs captured yet';
  const answered = countCompletedEvidence(cause, eligibleIndexes);
  if(causeHasFailure(cause)){
    return `${answered}/${total} evidence checks • Failed on at least one check`;
  }
  return `${answered}/${total} evidence checks complete`;
}

function formatCauseFindingsSummary(cause){
  if(!cause || !cause.findings) return '';
  const eligibleIndexes = evidencePairIndexes();
  if(!eligibleIndexes.length) return '';
  const sections = [];
  eligibleIndexes.forEach(index=>{
    const row = rowsBuilt[index];
    const key = getRowKeyByIndex(index);
    const entry = peekCauseFinding(cause, key);
    if(!entry) return;
    const mode = findingMode(entry);
    const note = findingNote(entry);
    if(!mode && !note.trim()) return;
    const label = row?.th?.textContent?.trim() || fillTokens(row?.def?.q || `Row ${index+1}`);
    const lines = [`  • ${label}`];
    if(mode === CAUSE_FINDING_MODES.ASSUMPTION){
      lines.push(`    - Assumptions needed: ${inlineText(note)}`);
    }else if(mode === CAUSE_FINDING_MODES.YES){
      lines.push(`    - Explains evidence: ${inlineText(note)}`);
    }else if(mode === CAUSE_FINDING_MODES.FAIL){
      lines.push(`    - Fails because: ${inlineText(note)}`);
    }else if(note.trim()){
      lines.push(`    - Notes: ${inlineText(note)}`);
    }
    sections.push(lines.join('\n'));
  });
  return sections.length ? ['Evidence walkthrough:', ...sections].join('\n') : '';
}

function formatPossibleCausesSummary(){
  if(!possibleCauses.length){
    return 'No possible causes captured.';
  }
  const blocks = possibleCauses.map((cause, index)=>{
    const header = `• Possible Cause ${index+1}: ${buildHypothesisSentence(cause)}`;
    const status = `  Status: ${causeStatusLabel(cause)}`;
    const progress = `  Progress: ${causeProgressSummary(cause)}`;
    const failureLine = causeHasFailure(cause) ? '  Result: Failed testing on at least one evidence check' : '';
    const assumptionCount = countCauseAssumptions(cause);
    const assumptionLine = assumptionCount ? `  Assumptions noted: ${assumptionCount}` : '';
    const evidence = formatCauseFindingsSummary(cause);
    return [header, status, progress, failureLine, assumptionLine, evidence].filter(Boolean).join('\n');
  });
  return blocks.join('\n\n');
}

function formatStepsSummary(){
  if(!Array.isArray(stepsItems) || !stepsItems.length) return '';
  const { total, completed } = getStepsCounts();
  const lines = [`Completed: ${completed}/${total}`];
  const open = stepsItems.filter(step=>!step.checked);
  if(open.length){
    lines.push('Open Items:');
    open.forEach(step=>{
      lines.push(`  • Step ${step.id} — ${step.label}`);
    });
  }
  return lines.join('\n');
}

/* ---------- Executive summary builder ---------- */
function buildSummaryText(){
  const title = document.getElementById('docTitle').textContent.trim();
  const subtitle = document.getElementById('docSubtitle').textContent.trim();

  const detectionSummary = formatChipsetSelections([
    {el: detectMonitoring, label: 'Monitoring'},
    {el: detectUserReport, label: 'User Report'},
    {el: detectAutomation, label: 'Automation'},
    {el: detectOther, label: 'Other'}
  ]);

  const evidenceSummary = formatChipsetSelections([
    {el: evScreenshot, label: 'Screenshot'},
    {el: evLogs, label: 'Logs'},
    {el: evMetrics, label: 'Metrics'},
    {el: evRepro, label: 'Repro'},
    {el: evOther, label: 'Other'}
  ]);

  // === Preface (inline answers) ===
  const prefaceLines = [
    summaryBullet('One-line', oneLine.value),
    summaryBullet('Evidence/Proof', proof.value),
    summaryBullet('Specific Object', objectPrefill.value || (objectIS?.value||'')),
    summaryBullet('Healthy Baseline', healthy.value),
    summaryBullet('Current State (What is happening now?)', now.value),
    summaryBulletRaw('Detection Source', detectionSummary),
    summaryBulletRaw('Evidence Collected', evidenceSummary)
  ];
  const preface = joinSummaryLines(prefaceLines);

  // === Impact (inline answers) ===
  const impactLines = [
    summaryLine('Current Impact', impactNow.value),
    summaryLine('Future Impact', impactFuture.value),
    summaryLine('Timeframe', impactTime.value)
  ];
  const imp = joinSummaryLines(impactLines);

  const containmentLines = [
    summaryLineRaw('Status', containmentStatusText()),
    summaryLine('Description', containDesc?.value)
  ];
  const containment = joinSummaryLines(containmentLines);

  const communications = joinSummaryLines([
    formatCommSummaryLine('internal', 'Last Internal Update'),
    formatCommSummaryLine('external', 'Last External Update'),
    nextUpdateSummaryLine()
  ]);

  // === KT Table as chat-friendly blocks per question ===
  const rowsOut = [];
  let pendingBand = '';

  [...tbody.querySelectorAll('tr')].forEach(tr=>{
    if(tr.classList.contains('band')){
      pendingBand = `== ${tr.textContent.trim()} ==`;
      return;
    }
    const q = tr.querySelector('th').textContent.trim();
    const t = tr.querySelectorAll('textarea');
    const isLines = splitLines(t[0].value);
    const notLines = splitLines(t[1].value);
    const distLines = splitLines(t[2].value);
    const changeLines = splitLines(t[3].value);

    // Question header
    const sections = [
      formatLabeledList('IS', isLines),
      formatLabeledList('IS NOT', notLines),
      formatDistinctionChanges(distLines, changeLines)
    ].filter(Boolean);
    if(!sections.length) return;
    if(pendingBand){
      rowsOut.push(pendingBand);
      pendingBand = '';
    }
    rowsOut.push(`Q: ${q}`);
    sections.forEach(section=>rowsOut.push(section));
  });

  const ktOut = rowsOut.filter(line=>line && line.trim().length).join('\n\n');

  // === Compose (minimal blank lines between major sections) ===
  const sectionsOut = [];
  if(title.trim()){ sectionsOut.push(title.trim()); }
  if(subtitle.trim()){ sectionsOut.push(subtitle.trim()); }
  function pushSection(label, body){
    const content = (body||'').trim();
    if(!content) return;
    if(sectionsOut.length){ sectionsOut.push(''); }
    sectionsOut.push(label);
    sectionsOut.push(content);
  }

  const bridgeLines = [
    summaryLineRaw('Bridge Opened (UTC)', bridgeOpenedUtc?.value),
    summaryLineRaw('Incident Commander', icName?.value),
    summaryLineRaw('Bridge Coordinator', bcName?.value),
    summaryLineRaw('SEM/Ops Lead', semOpsName?.value),
    summaryLineRaw('Severity', severity?.value)
  ];
  const bridge = joinSummaryLines(bridgeLines);

  pushSection('— Bridge Activation —', bridge);
  pushSection('— Preface —', preface);
  pushSection('— Containment —', containment);
  pushSection('— Impact —', imp);
  pushSection('— Communications —', communications);
  const stepsSummary = formatStepsSummary();
  if(stepsSummary.trim().length){
    pushSection('— Steps Checklist —', stepsSummary);
  }
  const causes = formatPossibleCausesSummary();
  if(causes.trim().length){
    pushSection('— Possible Causes —', causes);
  }
  if(ktOut.trim().length){
    pushSection('— KT IS / IS NOT —', ktOut);
  }

  return sectionsOut.join('\n');
}



const PROMPT_PREAMBLE = `You are ChatGPT acting as an incident communications specialist.
Following NIST SP 800-61, ISO/IEC 27035, and ITIL major incident best practices, craft two communication log entries:
one for internal stakeholders and one for external customers.
Each entry should include recommended tone, key talking points, risk framing, and next steps.
Use the incident context below to tailor the guidance.`;

/**
 * Unified summary generator.
 * @param {string} kind   - e.g., "summary" (reserved for extensibility)
 * @param {string} aiType - if "ai summary", prepend expert instructions
 */
async function generateSummary(kind='summary', aiType=''){
  void kind; // reserved for future use

  const baseText = buildSummaryText();

  let output = baseText;
  const normalizedType = typeof aiType === 'string' ? aiType.trim().toLowerCase() : '';
  if(normalizedType === 'ai summary'){
    const expertPrefix = `You are an expert in:

Incident Management (ITIL 4, ISO 20000-1, ISO 27001)

Major Incident communication (NIST SP 800-61 emergency comms best practices)

Kepner-Tregoe Situation Appraisal and IS / IS NOT problem analysis

Executive communication (clear, concise, jargon-free)

Your task is to take the information I paste after this prompt and produce two separate communication messages:

✅ Output #1 — INTERNAL COMMUNICATION UPDATE (for leadership & technical teams)

Audience: internal — executives, stakeholders, engineering teams
Goal: alignment and clarity on what is known / unknown / next steps

Format using these headings:

Incident Name / Reference ID:
Current Status: (e.g., Major Incident Active – Priority 1)
Situation Appraisal (KT format):

Concerns / issues identified

Priorities (what should be worked on first and why)

IS / IS NOT Analysis (KT format):

IS: (confirmed facts)

IS NOT: (ruled out variables)

What we know / What we don’t know yet:
Immediate actions taken:
Next steps / owners / ETAs:
Decision / ask for leadership: (if relevant)
Planned internal update cadence: (e.g., every 30 mins)

Keep the tone concise, factual, non-emotional. Avoid speculation and blame.

✅ Output #2 — EXTERNAL COMMUNICATION UPDATE (for customers / business users)

Audience: external — end users, customers, executives
Goal: confidence, clarity, and reduced anxiety — without technical noise

Format using these headings:

Status: (plain language, no acronyms)
Impact: (what users experience, scope of impact)
What we are doing: (reassurance + action)
What you need to do: (if anything)
Next update: (time commitment)

Follow these rules:

Do not include internal details or root cause speculation.

Be plain language. Example: instead of "database replication latency," say "our systems are not syncing data correctly."

Keep the update short, calm, and confident.

Tone guideline:

“Clear, factual, and reassuring.”

When generating both updates:

✔ Apply KT thinking (no assumptions — separate Known vs. Unknown)
✔ Apply ITIL/ISO/NIST best practices (clarity, ownership, cadence, impact)
✔ Prioritize accuracy > completeness

I will paste all the known information next. Analyze it and reply with the two formatted communications. Do not ask clarifying questions; make reasonable assumptions and proceed.`;
    output = `${expertPrefix}\n\n${baseText}`;
  }else if(normalizedType === 'prompt preamble'){
    output = `${PROMPT_PREAMBLE}\n\n${baseText}`;
  }

  const card = ensureSummaryCard();
  const pre = document.getElementById('summaryPre');
  if(pre){ pre.textContent = output; }
  if(card){ card.style.display = 'block'; }

  try{
    if(window.isSecureContext && navigator.clipboard && navigator.clipboard.writeText){
      await navigator.clipboard.writeText(output);
      if(typeof showToast==='function'){ showToast('Summary updated & copied. It’s also shown below.'); }
    }else{
      if(typeof showToast==='function'){ showToast('Summary updated. Clipboard blocked — copy it from the bottom.'); }
    }
  }catch(_){
    if(typeof showToast==='function'){ showToast('Summary updated. Clipboard blocked — copy it from the bottom.'); }
  }
}

async function runSummaryFlow({usePromptPreamble=false}={}){
  const aiType = usePromptPreamble ? 'prompt preamble' : '';
  return generateSummary('summary', aiType);
}

async function onGenerateSummary(){
  return generateSummary('summary', '');
}

async function onGenerateAIPrompt(){
  return generateSummary('summary', 'prompt preamble');
}

document.addEventListener('DOMContentLoaded', function(){
  var btn = document.getElementById('genSummaryBtn');
  if(btn){ btn.addEventListener('click', onGenerateSummary); }
  var aiPromptBtn = document.getElementById('commAIPromptBtn');
  if(aiPromptBtn){ aiPromptBtn.addEventListener('click', onGenerateAIPrompt); }
  var aiSummaryBtn = document.getElementById('generateAiSummaryBtn');
  if(aiSummaryBtn){ aiSummaryBtn.addEventListener('click', function(){ generateSummary('summary', 'ai summary'); }); }
});

/* [script:export] end */

/* [script:storage] start */
/* =================== Autosave =================== */
const STORAGE_KEY='kt-intake-full-v2';
function getContainmentStatus(){
  if(containMitigation?.checked) return 'mitigation';
  if(containRestore?.checked) return 'restore';
  if(containNone?.checked) return 'none';
  return '';
}
function saveToStorage(){
  const data={ pre:{ oneLine:oneLine.value, proof:proof.value, objectPrefill:objectPrefill.value, healthy:healthy.value, now:now.value },
               impact:{ now:impactNow.value, future:impactFuture.value, time:impactTime.value },
               ops:{
                 bridgeOpenedUtc:bridgeOpenedUtc?.value||'',
                 icName:icName?.value||'',
                 bcName:bcName?.value||'',
                 semOpsName:semOpsName?.value||'',
                 severity:severity?.value||'',
                 detectMonitoring:!!detectMonitoring?.checked,
                 detectUserReport:!!detectUserReport?.checked,
                 detectAutomation:!!detectAutomation?.checked,
                 detectOther:!!detectOther?.checked,
                 evScreenshot:!!evScreenshot?.checked,
                 evLogs:!!evLogs?.checked,
                 evMetrics:!!evMetrics?.checked,
                 evRepro:!!evRepro?.checked,
                 evOther:!!evOther?.checked,
                 containStatus:getContainmentStatus(),
                 containDesc:containDesc?.value||'',
                 commNextUpdateTime:commNextUpdateTime?.value||'',
                 commCadence:commCadence||'',
                 commLog:commLog.slice(0,20),
                 commNextDueIso:commNextDueIso||''
               },
               table:[],
               causes: serializeCauses(),
               steps: exportStepsState() };
  [...tbody.querySelectorAll('tr')].forEach(tr=>{
    if(tr.classList.contains('band')){ data.table.push({band: tr.textContent.trim()}); return; }
    const t=tr.querySelectorAll('textarea');
    data.table.push({q: tr.querySelector('th').textContent.trim(), is:t[0].value, no:t[1].value, di:t[2].value, ch:t[3].value});
  });
  localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
}
function restoreFromStorage(){
  const raw = localStorage.getItem(STORAGE_KEY); if(!raw) return;
  const data = JSON.parse(raw);
  if(data.pre){
    oneLine.value=data.pre.oneLine||''; proof.value=data.pre.proof||'';
    objectPrefill.value=data.pre.objectPrefill||''; healthy.value=data.pre.healthy||'';
    now.value=data.pre.now||'';
    [oneLine,proof,objectPrefill,healthy,now].forEach(autoResize);
    if(objectPrefill.value && objectIS && !objectIS.value) { objectIS.value=objectPrefill.value; autoResize(objectIS); }
    if(now.value && deviationIS && !deviationIS.value) { deviationIS.value=now.value; autoResize(deviationIS); }
  }
  if(data.impact){
    impactNow.value=data.impact.now||''; impactFuture.value=data.impact.future||''; impactTime.value=data.impact.time||'';
    [impactNow,impactFuture,impactTime].forEach(autoResize);
  }
  if(data.ops){
    if(bridgeOpenedUtc){ bridgeOpenedUtc.value=data.ops.bridgeOpenedUtc||''; }
    if(icName){ icName.value=data.ops.icName||''; }
    if(bcName){ bcName.value=data.ops.bcName||''; }
    if(semOpsName){ semOpsName.value=data.ops.semOpsName||''; }
    if(severity){ severity.value=data.ops.severity||''; }
    if(detectMonitoring){ detectMonitoring.checked=!!data.ops.detectMonitoring; }
    if(detectUserReport){ detectUserReport.checked=!!data.ops.detectUserReport; }
    if(detectAutomation){ detectAutomation.checked=!!data.ops.detectAutomation; }
    if(detectOther){ detectOther.checked=!!data.ops.detectOther; }
    if(evScreenshot){ evScreenshot.checked=!!data.ops.evScreenshot; }
    if(evLogs){ evLogs.checked=!!data.ops.evLogs; }
    if(evMetrics){ evMetrics.checked=!!data.ops.evMetrics; }
    if(evRepro){ evRepro.checked=!!data.ops.evRepro; }
    if(evOther){ evOther.checked=!!data.ops.evOther; }
    if(containDesc){ containDesc.value=data.ops.containDesc||''; }
    if(typeof data.ops.containStatus==='string'){
      const status = data.ops.containStatus;
      if(containNone){ containNone.checked = status==='none'; }
      if(containMitigation){ containMitigation.checked = status==='mitigation'; }
      if(containRestore){ containRestore.checked = status==='restore'; }
    }
    if(commNextUpdateTime){ commNextUpdateTime.value=data.ops.commNextUpdateTime||''; }
    commCadence = typeof data.ops.commCadence==='string' ? data.ops.commCadence : commCadence;
    if(Array.isArray(data.ops.commLog)){
      commLog = data.ops.commLog.filter(entry=>entry && typeof entry.type==='string' && typeof entry.ts==='string');
    }
    commNextDueIso = typeof data.ops.commNextDueIso==='string' ? data.ops.commNextDueIso : commNextDueIso;
    dueToastShown = false;
    updateCadenceRadios();
    updateCommLogUI();
    if(commNextDueIso){
      const due = new Date(commNextDueIso);
      if(!Number.isNaN(due.valueOf())){
        const val = toTimeValue(due);
        if(val){
          if(commNextUpdateTime){ commNextUpdateTime.value = val; }
        }
      }
    }else if(commNextUpdateTime && commNextUpdateTime.value){
      applyManualDueValue(commNextUpdateTime.value);
    }else{
      updateCadenceState();
    }
  }
  if(Array.isArray(data.table)){
    let i=0;
    [...tbody.querySelectorAll('tr')].forEach(tr=>{
      if(tr.classList.contains('band')) return;
      const rec = data.table.find(d=>d.q===tr.querySelector('th').textContent.trim() && !d.band) || data.table[i++];
      if(!rec) return;
      const t = tr.querySelectorAll('textarea');
      t[0].value=rec.is||''; t[1].value=rec.no||''; t[2].value=rec.di||''; t[3].value=rec.ch||'';
      t.forEach(autoResize);
    });
  }
  if(Array.isArray(data.causes)){
    possibleCauses = deserializeCauses(data.causes);
  }else{
    possibleCauses = [];
  }
  ensurePossibleCausesUI();
  renderCauses();
  if(possibleCauses.some(cause=>cause && cause.editing)){
    focusFirstEditableCause();
  }
  updateCauseEvidencePreviews();
  scheduleCadenceTick();
  if(data.steps){
    importStepsState(data.steps);
  }
}
/* [script:storage] end */

/* [script:toast] start */
function showToast(msg){
  const toast = document.getElementById('toast');
  toast.textContent = msg;
  toast.className = 'toast show';
  setTimeout(()=>toast.classList.remove('show'), 2200);
}
/* [script:toast] end */
</script>
<!-- [script] end -->
</body>
</html>
