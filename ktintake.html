<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>KT Intake</title>

<!--
[contract] start
EDITING CONTRACT for ChatGPT & humans:
- Keep these anchors intact. Prefer unified diffs (*** Begin Patch / *** End Patch) that edit INSIDE the relevant anchors only.
- Do not remove tokens: {OBJECT} / {DEVIATION}.
- Keep function names/signatures for copy to ASCII intact.
- Avoid structural rewrites unless requested; keep single-file layout.
Anchors present:
  [styles] [vars] [header] [section:preface] [subtitle]
  [section:impact] [section:table]
  [script] [rows] [script:table-build] [script:preface-refs]
  [script:tokens] [script:init] [script:export] [script:storage] [script:toast]
[contract] end
-->

<!-- [styles] start -->
<style>
  /* [vars] start */
  :root{
    /* Apple-like daytime palette */
    --bg:#f5f7fb;
    --panel:#ffffff;
    --ink:#0c1220;
    --muted:#5b6475;
    --line:#e6eaf2;
    --band:#f6f8fc;
    --accent:#007aff;

    /* Layout */
    --qcol-w:10.5rem;     /* narrow KT Question column */
    --ta-fs:15px;         /* textarea font size */
    --ta-min-h:380px;     /* taller by default */
    --radius:14px;
    --shadow:0 8px 24px rgba(12,18,32,.08), 0 1px 0 rgba(255,255,255,.6) inset;
    --speed:.22s;
  }
  /* [vars] end */

  html,body{height:100%;}
  body{
    margin:0; background:var(--bg); color:var(--ink);
    font-family:"SF Pro Text","SF Pro Display",-apple-system,system-ui,"Segoe UI",Roboto,"Helvetica Neue",Arial,sans-serif;
    font-size:15px; line-height:1.6; letter-spacing:-0.01em;
  }
  header{
    max-width:1240px; margin:22px auto 8px; padding:0 12px;
    display:flex; gap:12px; align-items:center; justify-content:space-between;
  }
  .header-title{display:flex; flex-direction:column; gap:4px; flex:1;}
  h1#docTitle{font-size:22px; font-weight:800; margin:0; letter-spacing:-0.01em; white-space:pre-wrap;}
  .subtle{color:var(--muted); font-size:12px;}
  .btn{
    appearance:none; border:1px solid var(--line); background:var(--accent); color:#fff;
    padding:10px 14px; border-radius:12px; cursor:pointer; font-weight:600;
    transition:transform var(--speed), box-shadow var(--speed), border-color var(--speed);
    box-shadow:0 6px 18px rgba(0,122,255,.18);
  }
  .btn:hover{transform:translateY(-1px);}
  .header-actions{display:flex; align-items:center; gap:10px; flex-wrap:wrap; justify-content:flex-end;}
  .steps-toggle-btn{
    appearance:none; border:1px solid #dfe5f2; background:#f6f8ff; color:#1d2845;
    padding:9px 12px; border-radius:12px; cursor:pointer; font-weight:600; font-size:13px;
    display:inline-flex; align-items:center; gap:8px;
    transition:background var(--speed), border-color var(--speed), box-shadow var(--speed), transform var(--speed);
  }
  .steps-toggle-btn:hover{background:#eef3ff; transform:translateY(-1px);}
  .steps-toggle-btn:focus{outline:none; border-color:var(--accent); box-shadow:0 0 0 3px rgba(0,122,255,.18);}
  .steps-toggle-btn .emoji{font-size:16px; line-height:1;}
  .steps-chip{
    appearance:none; border:1px solid #dfe5f2; background:#ffffff; color:#1d2845;
    padding:9px 14px; border-radius:999px; cursor:pointer; font-weight:600; font-size:13px;
    display:inline-flex; align-items:center; gap:8px; position:relative;
    transition:background var(--speed), border-color var(--speed), box-shadow var(--speed), transform var(--speed);
  }
  .steps-chip:hover{transform:translateY(-1px);}
  .steps-chip:focus{outline:none; border-color:var(--accent); box-shadow:0 0 0 3px rgba(0,122,255,.18);}
  .steps-chip[data-tone="low"]{background:#f6f8ff; color:#1d2845; border-color:#dfe5f2;}
  .steps-chip[data-tone="mid"]{background:#eef6ff; color:#0b3a6d; border-color:#a9d1ff;}
  .steps-chip[data-tone="high"]{background:#e6f9ef; color:#0f5b2f; border-color:#a8e2c3;}
  .steps-chip__progress{display:inline-flex; align-items:center; gap:4px;}
  .steps-chip__badge{
    display:inline-flex; align-items:center; justify-content:center;
    padding:2px 8px; border-radius:999px; background:#ffede9; color:#b0291c;
    font-size:11px; font-weight:700; letter-spacing:.04em; text-transform:uppercase;
  }
  .steps-chip__badge[hidden]{display:none;}

  .steps-panel{
    position:fixed; inset:0; display:flex; justify-content:flex-end;
    pointer-events:none; z-index:80;
  }
  .steps-panel[aria-hidden="true"]{visibility:hidden;}
  .steps-panel__scrim{
    flex:1; background:rgba(12,18,32,.24); opacity:0; transition:opacity var(--speed);
  }
  .steps-panel__container{
    width:420px; max-width:calc(100% - 60px); background:#ffffff; border-radius:16px 0 0 16px;
    border:1px solid #dfe5f2; box-shadow:0 24px 48px rgba(12,18,32,.18);
    transform:translateX(24px); opacity:0; transition:transform var(--speed), opacity var(--speed);
    display:flex; flex-direction:column;
  }
  .steps-panel[data-open="true"]{pointer-events:auto;}
  .steps-panel[data-open="true"] .steps-panel__scrim{opacity:1;}
  .steps-panel[data-open="true"] .steps-panel__container{transform:translateX(0); opacity:1;}
  .steps-panel__header{
    padding:20px 24px 16px; display:flex; flex-direction:column; gap:12px;
    border-bottom:1px solid #ecf0f8; background:linear-gradient(180deg,#f8faff 0%,#ffffff 40%);
    position:sticky; top:0; z-index:3;
  }
  .steps-panel__title-row{display:flex; align-items:center; justify-content:space-between; gap:12px;}
  .steps-panel__title-row h2{margin:0; font-size:18px; font-weight:700; letter-spacing:-0.01em; color:#1d2845;}
  .steps-panel__progress{font-size:14px; font-weight:600; color:#3b4962;}
  .steps-panel__search{display:flex; align-items:center; gap:10px;}
  .steps-panel__search input[type="search"]{
    flex:1; height:40px; border-radius:12px; border:1px solid #dfe5f2; padding:0 12px;
    font:14px/1.5 "SF Pro Text","SF Pro Display",-apple-system,system-ui,"Segoe UI",Roboto,"Helvetica Neue",Arial,sans-serif;
    background:#f7f9ff; color:#1d2845;
  }
  .steps-panel__search input[type="search"]:focus{outline:none; border-color:var(--accent); box-shadow:0 0 0 3px rgba(0,122,255,.18); background:#fff;}
  .steps-panel__close{
    appearance:none; border:1px solid #dfe5f2; background:#f6f8ff; color:#1d2845;
    padding:8px 12px; border-radius:10px; font-weight:600; cursor:pointer;
  }
  .steps-panel__close:hover{background:#eef3ff;}
  .steps-panel__close:focus{outline:none; border-color:var(--accent); box-shadow:0 0 0 3px rgba(0,122,255,.18);}
  .steps-panel__tabs{display:flex; gap:6px; padding:12px 24px 0; position:sticky; top:96px; background:#ffffff; z-index:2;}
  .steps-panel__tab{
    appearance:none; border:0; background:#eef3ff; color:#3b4962; font-weight:600; font-size:13px;
    padding:8px 14px; border-radius:12px; cursor:pointer; transition:background var(--speed), color var(--speed);
  }
  .steps-panel__tab[aria-selected="true"]{background:#1d49a7; color:#ffffff;}
  .steps-panel__content{flex:1; overflow:auto; padding:12px 24px 24px; display:flex; flex-direction:column; gap:20px;}
  .steps-panel__section{display:none; flex-direction:column; gap:20px;}
  .steps-panel__section[role="tabpanel"][data-active="true"]{display:flex;}

  .steps-checklist{display:grid; grid-template-columns:1fr; gap:16px;}
  @media(min-width:960px){
    .steps-checklist{grid-template-columns:1.1fr 1fr;}
  }
  .steps-list{display:flex; flex-direction:column; gap:12px;}
  .steps-phase{display:flex; flex-direction:column; gap:8px;}
  .steps-phase__title{font-size:12px; font-weight:700; letter-spacing:.08em; text-transform:uppercase; color:#6b768a; padding:0 4px;}
  .step-row{
    display:flex; align-items:flex-start; gap:12px; border:1px solid #e2e7f3; border-radius:12px; padding:12px;
    background:#ffffff; cursor:pointer; transition:border-color var(--speed), box-shadow var(--speed), background var(--speed);
  }
  .step-row[data-checked="true"]{border-color:#a8e2c3; background:#f1fbf5;}
  .step-row[data-selected="true"]{box-shadow:0 0 0 3px rgba(0,122,255,.18); border-color:var(--accent);}
  .step-row__checkbox{
    width:20px; height:20px; border-radius:6px; border:2px solid #d0d7eb; display:flex; align-items:center; justify-content:center;
    font-size:12px; font-weight:700; color:#ffffff; background:#ffffff; flex:0 0 20px; margin-top:2px;
    transition:background var(--speed), border-color var(--speed), color var(--speed);
  }
  .step-row[data-checked="true"] .step-row__checkbox{background:#0f864a; border-color:#0f864a;}
  .step-row__main{flex:1; display:flex; flex-direction:column; gap:6px;}
  .step-row__label{font-weight:600; font-size:14px; color:#1d2845;}
  .step-row__meta{display:flex; flex-wrap:wrap; gap:8px; font-size:12px; color:#5b6475;}
  .step-row__meta .chip{padding:4px 8px; border-radius:999px; background:#eef3ff; font-weight:600; letter-spacing:.02em;}
  .step-row__timestamp{font-variant-numeric:tabular-nums;}
  .step-row__note-preview{color:#3b4962; font-style:italic;}
  .steps-empty{padding:18px; border:1px dashed #dfe5f2; border-radius:12px; text-align:center; color:#6b768a; font-size:13px;}

  .steps-details{border:1px solid #e2e7f3; border-radius:12px; padding:16px; background:#f8faff; display:flex; flex-direction:column; gap:14px; min-height:220px;}
  .steps-details__header{display:flex; flex-direction:column; gap:6px;}
  .steps-details__title{font-size:16px; font-weight:700; color:#1d2845;}
  .steps-details__subtitle{font-size:13px; color:#3b4962;}
  .steps-details__field{display:flex; flex-direction:column; gap:6px;}
  .steps-details__field label{font-size:13px; font-weight:600; color:#1d2845;}
  .steps-details__field input[type="text"],
  .steps-details__field textarea,
  .steps-details__field select{
    border-radius:10px; border:1px solid #dfe5f2; padding:10px 12px;
    font:14px/1.55 "SF Pro Text","SF Pro Display",-apple-system,system-ui,"Segoe UI",Roboto,"Helvetica Neue",Arial,sans-serif;
    background:#ffffff; color:#1d2845;
  }
  .steps-details__field textarea{min-height:96px; resize:vertical;}
  .steps-details__field input:focus,
  .steps-details__field textarea:focus,
  .steps-details__field select:focus{outline:none; border-color:var(--accent); box-shadow:0 0 0 3px rgba(0,122,255,.18);}
  .steps-links{display:flex; flex-wrap:wrap; gap:8px;}
  .steps-link-btn{
    appearance:none; border:1px solid #dfe5f2; background:#ffffff; color:#1d2845;
    padding:6px 10px; border-radius:10px; font-weight:600; font-size:12px; cursor:pointer;
    transition:background var(--speed), border-color var(--speed);
  }
  .steps-link-btn:hover{background:#eef3ff; border-color:#a9c4f9;}
  .steps-link-btn:focus{outline:none; border-color:var(--accent); box-shadow:0 0 0 3px rgba(0,122,255,.18);}
  .steps-history{display:flex; flex-direction:column; gap:4px; font-size:12px; color:#5b6475;}
  .steps-history__item{font-variant-numeric:tabular-nums;}
  .steps-details__actions{display:flex; flex-wrap:wrap; gap:8px;}
  .steps-details__skip{
    appearance:none; border:1px dashed #ffb3a9; background:#fff5f3; color:#c0362c;
    padding:8px 12px; border-radius:10px; font-weight:600; cursor:pointer;
  }
  .steps-details__skip:hover{background:#ffe9e5;}
  .steps-details__status{display:flex; flex-direction:column; gap:4px; font-size:12px; color:#3b4962;}

  .steps-log{display:flex; flex-direction:column; gap:16px;}
  .steps-log__filters{display:grid; grid-template-columns:repeat(auto-fit, minmax(120px,1fr)); gap:12px;}
  .steps-log__filters label{display:flex; flex-direction:column; gap:6px; font-size:12px; font-weight:600; color:#1d2845;}
  .steps-log__filters select{height:40px; border-radius:10px; border:1px solid #dfe5f2; background:#ffffff; padding:0 10px; font:14px/1.5 "SF Pro Text","SF Pro Display",-apple-system,system-ui,"Segoe UI",Roboto,"Helvetica Neue",Arial,sans-serif; color:#1d2845;}
  .steps-log__filters select:focus{outline:none; border-color:var(--accent); box-shadow:0 0 0 3px rgba(0,122,255,.18);}
  .steps-log__list{display:flex; flex-direction:column; gap:10px;}
  .steps-log__item{border:1px solid #e2e7f3; border-radius:12px; padding:12px; background:#ffffff; display:flex; flex-direction:column; gap:6px;}
  .steps-log__item--manual{border-color:#d0d7eb;}
  .steps-log__item--step{border-color:#a9c4f9;}
  .steps-log__item--comms{border-color:#ffd0c7;}
  .steps-log__meta{display:flex; flex-wrap:wrap; gap:10px; font-size:12px; color:#5b6475; align-items:center;}
  .steps-log__title{font-size:13px; font-weight:600; color:#1d2845;}
  .steps-log__note{font-size:12px; color:#3b4962; white-space:pre-wrap;}
  .steps-manual{border:1px solid #dfe5f2; border-radius:12px; padding:14px; background:#f8faff; display:flex; flex-direction:column; gap:10px;}
  .steps-manual textarea{min-height:96px; border-radius:10px; border:1px solid #dfe5f2; padding:10px 12px; font:14px/1.55 "SF Pro Text","SF Pro Display",-apple-system,system-ui,"Segoe UI",Roboto,"Helvetica Neue",Arial,sans-serif;}
  .steps-manual textarea:focus{outline:none; border-color:var(--accent); box-shadow:0 0 0 3px rgba(0,122,255,.18);}
  .steps-manual__row{display:grid; grid-template-columns:repeat(auto-fit,minmax(120px,1fr)); gap:10px;}
  .steps-manual__row input,
  .steps-manual__row select{height:40px; border-radius:10px; border:1px solid #dfe5f2; padding:0 10px; font:14px/1.5 "SF Pro Text","SF Pro Display",-apple-system,system-ui,"Segoe UI",Roboto,"Helvetica Neue",Arial,sans-serif; color:#1d2845;}
  .steps-manual__row input:focus,
  .steps-manual__row select:focus{outline:none; border-color:var(--accent); box-shadow:0 0 0 3px rgba(0,122,255,.18);}
  .steps-manual__actions{display:flex; justify-content:flex-end;}

  .steps-suggestion{
    position:fixed; right:18px; bottom:86px; display:flex; align-items:center; gap:12px;
    background:#ffffff; border:1px solid #a9c4f9; border-radius:14px; padding:12px 16px;
    box-shadow:0 12px 28px rgba(29,73,167,.18); z-index:85; max-width:320px;
  }
  .steps-suggestion[hidden]{display:none;}
  .steps-suggestion__text{font-size:13px; color:#1d2845; font-weight:600;}
  .steps-suggestion__actions{display:flex; gap:8px;}
  .steps-suggestion__btn{
    appearance:none; border:1px solid var(--accent); background:var(--accent); color:#ffffff;
    padding:8px 12px; border-radius:10px; font-weight:600; cursor:pointer;
  }
  .steps-suggestion__btn:hover{opacity:.9;}
  .steps-suggestion__dismiss{
    appearance:none; border:1px solid #dfe5f2; background:#f6f8ff; color:#1d2845;
    padding:8px 10px; border-radius:10px; font-weight:600; cursor:pointer;
  }
  .steps-suggestion__dismiss:hover{background:#eef3ff;}

  .steps-modal{position:fixed; inset:0; display:flex; align-items:center; justify-content:center; z-index:120; background:rgba(12,18,32,.42);}
  .steps-modal[hidden]{display:none;}
  .steps-modal__card{background:#ffffff; border-radius:16px; padding:24px; max-width:420px; width:calc(100% - 48px); box-shadow:0 20px 48px rgba(12,18,32,.24); display:flex; flex-direction:column; gap:16px; border:1px solid #dfe5f2;}
  .steps-modal__title{margin:0; font-size:18px; font-weight:700; color:#1d2845;}
  .steps-modal__body{display:flex; flex-direction:column; gap:12px; font-size:14px; color:#3b4962;}
  .steps-modal__field{display:flex; flex-direction:column; gap:6px;}
  .steps-modal__field label{font-weight:600; font-size:13px;}
  .steps-modal__field input{height:40px; border-radius:10px; border:1px solid #dfe5f2; padding:0 10px; font:14px/1.5 "SF Pro Text","SF Pro Display",-apple-system,system-ui,"Segoe UI",Roboto,"Helvetica Neue",Arial,sans-serif; color:#1d2845;}
  .steps-modal__field textarea{min-height:88px; border-radius:10px; border:1px solid #dfe5f2; padding:10px 12px; font:14px/1.5 "SF Pro Text","SF Pro Display",-apple-system,system-ui,"Segoe UI",Roboto,"Helvetica Neue",Arial,sans-serif; color:#1d2845; resize:vertical;}
  .steps-modal__field input:focus{outline:none; border-color:var(--accent); box-shadow:0 0 0 3px rgba(0,122,255,.18);}
  .steps-modal__field textarea:focus{outline:none; border-color:var(--accent); box-shadow:0 0 0 3px rgba(0,122,255,.18);}
  .steps-modal__actions{display:flex; justify-content:flex-end; gap:8px;}
  .steps-modal__actions button{appearance:none; border-radius:10px; font-weight:600; padding:8px 14px; cursor:pointer;}
  .steps-modal__actions .btn-primary{background:var(--accent); color:#ffffff; border:1px solid var(--accent);}
  .steps-modal__actions .btn-secondary{background:#f6f8ff; color:#1d2845; border:1px solid #dfe5f2;}
  .steps-modal__actions .btn-danger{background:#ffe9e5; color:#b0291c; border:1px solid #ffb3a9;}

  .wrap{max-width:1240px; margin:0 auto 40px; padding:0 12px;}
  h2#docSubtitle{margin:12px 0 8px; font-size:16px; font-weight:700; color:#2a3957; white-space:pre-wrap;}

  .card{
    background:var(--panel); border:1px solid var(--line); border-radius:var(--radius); box-shadow:var(--shadow);
    padding:20px 22px 24px; margin:0 0 32px;
  }
  .card h3{
    margin:0 0 16px;
    font-family:"SF Pro Display","SF Pro Text",-apple-system,system-ui,ui-sans-serif;
    font-size:15px; font-weight:700; letter-spacing:.32px; text-transform:uppercase; color:#1d2845;
  }
  .preface-stack{display:flex; flex-direction:column;}
  .grid{ display:grid; gap:12px; }
  .grid.cols-2{ grid-template-columns:1fr 1fr; }
  .grid.cols-3{ grid-template-columns:1fr 1fr 1fr; }
  .containment-grid .contain-status{ grid-column:span 2; }
  .containment-radios{ display:flex; flex-wrap:wrap; gap:12px; }
  .radio-option{ display:flex; align-items:center; gap:6px; }
  .comm-grid{ grid-template-columns:1fr 1fr auto; align-items:end; }
  .comm-grid .field{ margin:0; }
  .comm-grid .field label{ margin-bottom:4px; }
  .comm-grid.comm-grid--single{ grid-template-columns:1fr; }
  .comm-log-toggle{ margin-top:8px; align-self:flex-start; display:inline-flex; align-items:center; }
  .inline{ display:flex; align-items:center; gap:12px; flex-wrap:wrap; }
  .chipset{ display:flex; gap:8px; flex-wrap:wrap; }
  .chipset .chip{ position:relative; display:flex; align-items:center; gap:6px; }
  .chipset .chip label{ display:inline-flex; align-items:center; justify-content:center; padding:8px 12px; border-radius:999px; border:1px solid #dfe5f2; background:#f7f9ff; font-weight:600; font-size:13px; color:#1d2845; cursor:pointer; transition:border-color var(--speed), box-shadow var(--speed), background var(--speed); }
  .chipset .chip input[type="checkbox"]{ position:absolute; top:0; left:0; opacity:0; pointer-events:none; width:1px; height:1px; }
  .chipset .chip input[type="checkbox"]:focus + label{ border-color:var(--accent); box-shadow:0 0 0 3px rgba(0,122,255,.18); }
  .chipset .chip input[type="checkbox"]:checked + label{ border-color:var(--accent); background:rgba(0,122,255,.1); color:var(--accent); }
  .chip-label{ font-weight:700; color:#1d2845; min-width:150px; flex:0 0 auto; }
  .caption{ margin:-6px 0 16px; font-size:12px; color:var(--muted); }
  .gap-24{ gap:24px; }
  .field label{display:block; font-weight:700; margin-bottom:6px;}
  .field small{display:block; color:var(--muted); margin-top:4px;}
  fieldset.field{border:0; padding:0; margin:0;}
  fieldset.field legend{font-weight:700; margin-bottom:6px; font-size:14px; color:#1d2845;}
  .field textarea, .field input[type="text"]{
    width:100%; box-sizing:border-box;
    font:15px/1.55 ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
    color:var(--ink); background:#f9fbff;
    border:1px solid #dfe5f2; border-radius:12px; padding:12px 14px; outline:none;
    transition:border-color var(--speed), box-shadow var(--speed), background var(--speed);
  }
  .field textarea{min-height:140px; resize:vertical;}
  .field input[type="text"]{height:44px;}
  .field input[readonly]{background:#f4f6fb; color:#3b4962;}
  .field input[type="time"], .field select{
    width:100%; box-sizing:border-box; height:44px;
    font:15px/1.55 "SF Pro Text","SF Pro Display",-apple-system,system-ui,"Segoe UI",Roboto,"Helvetica Neue",Arial,sans-serif;
    color:var(--ink); background:#f9fbff;
    border:1px solid #dfe5f2; border-radius:12px; padding:8px 12px; outline:none;
    transition:border-color var(--speed), box-shadow var(--speed), background var(--speed);
  }
  .field input[type="time"]:focus, .field select:focus{border-color:var(--accent); box-shadow:0 0 0 4px rgba(0,122,255,.18); background:#fff;}
  .btn-mini{
    appearance:none; border:1px solid #dfe5f2; background:#eef3ff; color:var(--accent);
    padding:8px 12px; border-radius:10px; cursor:pointer; font-weight:600; font-size:13px;
    transition:transform var(--speed), box-shadow var(--speed), border-color var(--speed);
    box-shadow:0 4px 12px rgba(0,122,255,.12);
  }
  .btn-mini:hover{transform:translateY(-1px);}
  .btn-mini:focus{outline:none; border-color:var(--accent); box-shadow:0 0 0 4px rgba(0,122,255,.18);}
  .btn-mini.btn-ghost{
    background:#f7f9ff; color:#3b4962; border-color:#e2e7f3; box-shadow:none;
  }
  .btn-mini.btn-ghost:hover{background:#eef3ff;}
  .btn-mini.btn-danger{
    background:#ffeceb; color:#c0362c; border-color:#ffc3bb; box-shadow:0 4px 12px rgba(255,107,74,.12);
  }
  .btn-mini.btn-danger:hover{background:#ffdcd4;}
  .field textarea::placeholder, .field input::placeholder{color:#8b93a4;}
  .field textarea:focus, .field input:focus{border-color:var(--accent); box-shadow:0 0 0 4px rgba(0,122,255,.18); background:#fff;}

  .card.communication-due{ border-color:#ff9a8a; background:linear-gradient(180deg,#fff4f2 0%,#ffffff 35%); box-shadow:0 10px 28px rgba(255,107,74,.18); }
  .communication-due .countdown{ color:#d91f11; }

  .cadence-group{ display:flex; gap:8px; flex-wrap:wrap; }
  .cadence-option{ position:relative; }
  .cadence-option input[type="radio"]{ position:absolute; inset:0; opacity:0; }
  .cadence-option span{ display:inline-flex; align-items:center; justify-content:center; padding:8px 14px; border-radius:999px; border:1px solid #dfe5f2; background:#f7f9ff; font-weight:600; font-size:13px; color:#1d2845; cursor:pointer; transition:border-color var(--speed), box-shadow var(--speed), background var(--speed); }
  .cadence-option input[type="radio"]:focus + span{ border-color:var(--accent); box-shadow:0 0 0 3px rgba(0,122,255,.18); }
  .cadence-option input[type="radio"]:checked + span{ border-color:var(--accent); background:rgba(0,122,255,.1); color:var(--accent); }

  .comm-actions{ gap:10px; justify-content:flex-start; }
  .comm-actions .countdown{ font-weight:600; color:#2a3957; min-width:96px; }

  .comm-alert{ margin-top:10px; padding:10px 12px; border-radius:12px; background:#fff2f0; border:1px solid #ffd0c7; color:#b71c1c; font-weight:600; display:flex; align-items:center; gap:8px; }

  .comm-log{ list-style:none; padding:0; margin:12px 0 0; display:flex; flex-direction:column; gap:8px; }
  .comm-log li{ display:flex; justify-content:space-between; align-items:center; gap:12px; padding:10px 12px; border-radius:12px; background:#f7f9ff; border:1px solid #e2e7f3; font-size:13px; }
  .comm-log__type{ font-weight:700; text-transform:uppercase; letter-spacing:.04em; color:#1d2845; }
  .comm-log__time{ font-variant-numeric:tabular-nums; color:#2a3957; }
  .comm-log__empty{ justify-content:flex-start; color:#7a8398; font-style:italic; }

  /* Impact strip */
  .impact{ padding:18px; }
  .impact > h3{
    margin:0 0 18px;
    font-size:17px;
    font-weight:700;
    letter-spacing:-0.02em;
    color:#1f2b40;
    font-family:"SF Pro Display","SF Pro Text",-apple-system,system-ui,"Segoe UI",Roboto,"Helvetica Neue",Arial,sans-serif;
  }
  .impact .field{padding:4px 0;}
  .impact .field h3{
    margin:0 0 6px;
    font-size:15px;
    font-weight:600;
    letter-spacing:-0.015em;
    color:#22324b;
    font-family:"SF Pro Display","SF Pro Text",-apple-system,system-ui,"Segoe UI",Roboto,"Helvetica Neue",Arial,sans-serif;
  }
  .impact .field label{
    font-size:13px;
    font-weight:600;
    letter-spacing:-0.01em;
    color:#3b4962;
    margin-bottom:8px;
  }
  .impact .field small{
    font-size:12px;
    line-height:1.55;
    letter-spacing:0;
  }
  .impact textarea{
    font-family:"SF Pro Text","SF Pro Display",-apple-system,system-ui,"Segoe UI",Roboto,"Helvetica Neue",Arial,sans-serif;
    font-size:14px;
    line-height:1.6;
    letter-spacing:-0.01em;
  }

  /* Table */
  table{
    table-layout:fixed;
    
    width:100%; border-collapse:separate; border-spacing:0; overflow:hidden; border-radius:var(--radius);
    background:var(--panel); border:1px solid var(--line); box-shadow:var(--shadow);
  }
  thead th{
    word-wrap:break-word;
    white-space:normal;
    
    position:sticky; top:0; z-index:3;
    background:linear-gradient(180deg, #ffffff, #fafbfe);
    color:#0c1220; text-align:left; font-size:12px; letter-spacing:.4px;
    padding:12px; border-bottom:1px solid var(--line);
  }
  tbody td, tbody th{
    border-bottom:1px solid var(--line); vertical-align:top; padding:10px 8px; transition:background-color var(--speed);
  }
  tbody tr:last-child td, tbody tr:last-child th{border-bottom:0;}
  tbody tr:hover td, tbody tr:hover th{background-color:#fafbfe;}
  tbody th{
    width:var(--qcol-w); max-width:var(--qcol-w); min-width:var(--qcol-w);
    white-space:normal; word-break:break-word; font-weight:700; color:#0c1220;
  }
  .cause-list{display:flex; flex-direction:column; gap:16px; margin-top:12px; margin-bottom:18px;}
  .cause-empty{padding:18px; border:1px dashed #dfe5f2; border-radius:12px; background:#f9fbff; color:#5b6475; font-style:italic;}
  .cause-card{
    border:1px solid #e2e7f3; border-radius:14px; background:linear-gradient(180deg,#ffffff 0%,#f8faff 100%);
    padding:18px 20px; display:flex; flex-direction:column; gap:12px; position:relative;
  }
  .cause-card[data-editing="true"]{border-color:var(--accent); box-shadow:0 0 0 4px rgba(0,122,255,.12);}
  .cause-card[data-failed="true"]{border-color:#ffb3a9; box-shadow:0 0 0 4px rgba(255,107,74,.16);}
  .cause-card__header{display:flex; justify-content:space-between; align-items:flex-start; gap:12px;}
  .cause-card__meta{display:flex; flex-direction:column; gap:4px;}
  .cause-card__title{font-weight:700; font-size:14px; color:#1d2845; letter-spacing:.02em;}
  .cause-card__status{font-size:12px; color:var(--muted); letter-spacing:.02em;}
  .cause-card__indicators{display:flex; flex-direction:column; align-items:flex-end; gap:6px;}
  .cause-card__chip{display:inline-flex; align-items:center; justify-content:center; padding:6px 12px; border-radius:999px; font-weight:600; font-size:12px; letter-spacing:.03em; text-transform:uppercase; border:1px solid transparent; background:#f2f4fb; color:#3b4962;}
  .cause-card__chip[data-status="not-tested"]{background:#f2f4fb; color:#3b4962; border-color:#dfe5f2;}
  .cause-card__chip[data-status="testing"]{background:#fff6e6; color:#7b4b00; border-color:#f3d2a2;}
  .cause-card__chip[data-status="explained"]{background:#e6f9ef; color:#0f5b2f; border-color:#b8e8cd;}
  .cause-card__chip[data-status="failed"]{background:#ffe8e6; color:#b71c1c; border-color:#ffb3a9;}
  .cause-card__chip[data-status="draft"]{background:#f5f7fb; color:#6b768a; border-color:#e2e7f3;}
  .cause-card__chip[data-status="no-evidence"]{background:#eef3ff; color:#1d2845; border-color:#d5def5;}
  .cause-card__failure{display:inline-flex; align-items:center; gap:6px; padding:4px 10px; border-radius:999px; font-weight:600; font-size:12px; letter-spacing:.02em; background:#ffe8e6; color:#b71c1c; border:1px solid #ffb3a9;}
  .cause-card__failure::before{content:'âœ•'; font-size:13px; line-height:1;}
  .cause-card__assumptions{display:inline-flex; align-items:center; gap:6px; padding:4px 10px; border-radius:999px; font-weight:600; font-size:12px; letter-spacing:.02em; background:#f1f4ff; color:#1d2845; border:1px solid #d5def5;}
  .cause-card__assumptions::before{content:'âˆ‘'; font-size:13px; line-height:1; color:#3b4d7a;}
  .cause-card__summary{margin:0; font-size:14px; line-height:1.6; color:#1f2b40;}
  .cause-card__helper{margin-top:-6px;}
  .cause-card__form{display:grid; gap:14px;}
  .cause-card__form .field textarea{min-height:120px;}
  .cause-controls{display:flex; gap:8px; flex-wrap:wrap; margin-top:4px;}
  .cause-test{border-top:1px solid #e2e7f3; padding-top:14px; display:flex; flex-direction:column; gap:12px;}
  .cause-test__intro{margin:0; font-size:13px; color:#3b4962;}
  .cause-eval-row{border:1px solid #e3e8f5; border-radius:12px; background:#f9fbff; padding:14px; display:flex; flex-direction:column; gap:12px;}
  .cause-eval-question-text{font-weight:600; font-size:13px; color:#1f2b40;}
  .cause-evidence-wrap{display:grid; gap:10px; grid-template-columns:repeat(auto-fit, minmax(180px,1fr));}
  .cause-evidence-block{display:flex; flex-direction:column; gap:4px; padding:10px; border-radius:10px; background:#ffffff; border:1px solid #e6ebf5;}
  .cause-evidence-label{font-size:11px; text-transform:uppercase; letter-spacing:.08em; color:#7a8398; font-weight:700;}
  .cause-evidence-text{font-size:13px; line-height:1.5; color:#22324b; white-space:pre-line;}
  .cause-eval-inputs{display:flex; flex-direction:column; gap:12px;}
  .cause-eval-options{display:flex; flex-wrap:wrap; gap:8px;}
  .cause-eval-option{appearance:none; border:1px solid #dfe5f2; background:#ffffff; color:#1d2845; font-weight:600; font-size:13px; padding:8px 14px; border-radius:999px; cursor:pointer; transition:background var(--speed), border-color var(--speed), color var(--speed), box-shadow var(--speed);}
  .cause-eval-option:hover{border-color:var(--accent);}
  .cause-eval-option:focus{outline:none; border-color:var(--accent); box-shadow:0 0 0 4px rgba(0,122,255,.18);}
  .cause-eval-option.is-selected{background:rgba(0,122,255,.12); border-color:var(--accent); color:var(--accent); box-shadow:0 6px 16px rgba(0,122,255,.12);}
  .cause-eval-note{display:flex; flex-direction:column; gap:6px;}
  .cause-eval-note[hidden]{display:none;}
  .cause-eval-inputs .field textarea{min-height:120px;}
  @media (max-width:720px){
    .cause-card{padding:16px;}
  }
  .band th{
    padding:12px; font-weight:800; color:#2a3957;
    background:linear-gradient(180deg, var(--band), #ffffff);
    border-top:1px solid var(--line); border-bottom:1px solid var(--line);
  }
  .band th span{opacity:.85; font-weight:600; color:#6b768a}
  textarea.tableta{
    width:100%; min-height:var(--ta-min-h); resize:vertical; box-sizing:border-box;
    font:var(--ta-fs)/1.55 ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
    color:var(--ink); background:#f9fbff;
    border:1px solid #dfe5f2; border-radius:12px; padding:12px 14px; outline:none;
    transition:border-color var(--speed), box-shadow var(--speed), background var(--speed);
  }
  textarea.tableta::placeholder{color:#8b93a4;}
  textarea.tableta:focus{border-color:var(--accent); box-shadow:0 0 0 4px rgba(0,122,255,.18); background:#ffffff;}

  /* Toast */
  .toast{
    position:fixed; right:18px; bottom:18px; background:#0f1a10; color:#dff5e1; border:1px solid #164f19;
    padding:10px 12px; border-radius:12px; opacity:0; transform:translateY(10px); transition:.25s; pointer-events:none; box-shadow:var(--shadow);
  }
  .toast.show{opacity:1; transform:translateY(0);}
</style>
<!-- [styles] end -->
</head>
<body>
  <!-- [header] start -->
  <header>
    <div class="header-title">
      <h1 id="docTitle">KT Intake</h1>
    </div>
    <div class="header-actions">
      <button type="button" class="steps-toggle-btn" id="stepsToggleBtn" aria-haspopup="dialog" aria-controls="stepsPanel">
        <span class="emoji" aria-hidden="true">ðŸ§­</span>
        <span>Steps</span>
        <span class="subtle">Alt+S</span>
      </button>
      <button type="button" class="steps-chip" id="stepsProgressChip" data-tone="low" aria-live="polite" aria-label="Steps progress" aria-controls="stepsPanel">
        <span class="steps-chip__progress"><span id="stepsChipText">Steps Â· 0/28 âœ“</span></span>
        <span class="steps-chip__badge" id="stepsChipBadge" hidden>Comms due</span>
      </button>
      <button class="btn" id="genSummaryBtn" onclick="onGenerateSummary()">Generate Summary</button>
    </div>
  </header>
  <div class="steps-panel" id="stepsPanel" aria-hidden="true">
    <div class="steps-panel__scrim" id="stepsPanelScrim" role="presentation"></div>
    <aside class="steps-panel__container" id="stepsPanelContainer" role="dialog" aria-modal="false" aria-labelledby="stepsPanelTitle">
      <header class="steps-panel__header">
        <div class="steps-panel__title-row">
          <h2 id="stepsPanelTitle">Steps</h2>
          <button type="button" class="steps-panel__close" id="stepsPanelCloseBtn" aria-label="Close steps panel">Close</button>
        </div>
        <div class="steps-panel__search">
          <div class="steps-panel__progress" id="stepsPanelProgress">0/28 âœ“</div>
          <input type="search" id="stepsSearchInput" placeholder="Search steps" aria-label="Search steps" />
        </div>
      </header>
      <div class="steps-panel__tabs" role="tablist">
        <button type="button" class="steps-panel__tab" id="stepsTabChecklist" role="tab" aria-controls="stepsChecklistPanel" aria-selected="true">Checklist</button>
        <button type="button" class="steps-panel__tab" id="stepsTabLog" role="tab" aria-controls="stepsLogPanel" aria-selected="false">Activity Log</button>
      </div>
      <div class="steps-panel__content">
        <section class="steps-panel__section" id="stepsChecklistPanel" role="tabpanel" aria-labelledby="stepsTabChecklist" data-active="true">
          <div class="steps-checklist">
            <div class="steps-list" id="stepsList" role="listbox" aria-label="Incident steps checklist"></div>
            <div class="steps-details" id="stepsDetails" aria-live="polite">Select a step to view details.</div>
          </div>
        </section>
        <section class="steps-panel__section" id="stepsLogPanel" role="tabpanel" aria-labelledby="stepsTabLog" data-active="false">
          <div class="steps-log">
            <div class="steps-log__filters">
              <label for="stepsLogTypeFilter">Type
                <select id="stepsLogTypeFilter">
                  <option value="all">All</option>
                  <option value="step">Steps</option>
                  <option value="manual">Manual</option>
                  <option value="comms">Comms</option>
                </select>
              </label>
              <label for="stepsLogStepFilter">Step
                <select id="stepsLogStepFilter">
                  <option value="all">All</option>
                </select>
              </label>
              <label for="stepsLogActorFilter">Actor
                <select id="stepsLogActorFilter">
                  <option value="all">All</option>
                </select>
              </label>
            </div>
            <div class="steps-log__list" id="stepsLogList" role="list"></div>
            <form class="steps-manual" id="stepsManualForm">
              <label for="stepsManualNote">Manual log entry
                <textarea id="stepsManualNote" placeholder="Add note for the activity log" required></textarea>
              </label>
              <div class="steps-manual__row">
                <label for="stepsManualStepSelect">Related Step
                  <select id="stepsManualStepSelect">
                    <option value="">None</option>
                  </select>
                </label>
                <label for="stepsManualActor">Actor
                  <input type="text" id="stepsManualActor" placeholder="Initials" />
                </label>
              </div>
              <div class="steps-manual__actions">
                <button type="submit" class="btn-mini">Save Log Entry</button>
              </div>
            </form>
          </div>
        </section>
      </div>
    </aside>
  </div>
  <div class="steps-suggestion" id="stepsSuggestionBanner" hidden>
    <div class="steps-suggestion__text" id="stepsSuggestionText">Check Step 16?</div>
    <div class="steps-suggestion__actions">
      <button type="button" class="steps-suggestion__btn" id="stepsSuggestionAction">Mark complete</button>
      <button type="button" class="steps-suggestion__dismiss" id="stepsSuggestionDismiss">Dismiss</button>
    </div>
  </div>
  <div class="steps-modal" id="stepsModal" hidden role="dialog" aria-modal="true" aria-labelledby="stepsModalTitle">
    <div class="steps-modal__card">
      <h3 class="steps-modal__title" id="stepsModalTitle"></h3>
      <div class="steps-modal__body" id="stepsModalBody"></div>
      <div class="steps-modal__actions" id="stepsModalActions"></div>
    </div>
  </div>
  <!-- [header] end -->

  <div class="wrap">
    <!-- [section:preface] start -->
    <section class="preface-stack">
      <div class="card">
        <h3>Bridge Activation</h3>
        <p class="caption">Capture only whatâ€™s needed to activate the bridge and set comms cadence.</p>
        <div class="grid cols-3">
          <div class="field">
            <label for="bridgeOpenedUtc">Bridge opened (UTC)</label>
            <div class="inline">
              <input type="text" id="bridgeOpenedUtc" readonly aria-readonly="true" />
              <button type="button" class="btn-mini" id="bridgeSetNowBtn" aria-label="Stamp bridge opened time">Set Now</button>
            </div>
          </div>
          <div class="field">
            <label for="icName">Incident Commander</label>
            <input type="text" id="icName" placeholder="" />
          </div>
          <div class="field">
            <label for="bcName">Bridge Coordinator</label>
            <input type="text" id="bcName" placeholder="" />
          </div>
        </div>
        <div class="grid cols-3">
          <div class="field">
            <label for="semOpsName">SEM/Ops Lead</label>
            <input type="text" id="semOpsName" placeholder="" />
          </div>
          <div class="field">
            <label for="severity">Severity</label>
            <select id="severity">
              <option value="">Select severity</option>
              <option value="S1">S1</option>
              <option value="S2">S2</option>
              <option value="S3">S3</option>
            </select>
          </div>
        </div>
      </div>

      <div class="card" id="problem-summary">
        <h3>Problem Summary</h3>
        <div class="grid">
          <div class="field">
            <label for="oneLine">In one sentence, what is broken for you right now?</label>
            <textarea id="oneLine" placeholder=""></textarea>
          </div>
        </div>
      </div>

      <div class="card" id="evidence-objects">
        <h3>Evidence &amp; Object</h3>
        <div class="inline">
          <span class="chip-label">Detection Source</span>
          <div class="chipset" role="group" aria-label="Detection Source">
            <div class="chip">
              <input type="checkbox" id="detectMonitoring" />
              <label for="detectMonitoring">Monitoring</label>
            </div>
            <div class="chip">
              <input type="checkbox" id="detectUserReport" />
              <label for="detectUserReport">User Report</label>
            </div>
            <div class="chip">
              <input type="checkbox" id="detectAutomation" />
              <label for="detectAutomation">Automation</label>
            </div>
            <div class="chip">
              <input type="checkbox" id="detectOther" />
              <label for="detectOther">Other</label>
            </div>
          </div>
        </div>
        <div class="inline">
          <span class="chip-label">Evidence Collected</span>
          <div class="chipset" role="group" aria-label="Evidence Collected">
            <div class="chip">
              <input type="checkbox" id="evScreenshot" />
              <label for="evScreenshot">Screenshot</label>
            </div>
            <div class="chip">
              <input type="checkbox" id="evLogs" />
              <label for="evLogs">Logs</label>
            </div>
            <div class="chip">
              <input type="checkbox" id="evMetrics" />
              <label for="evMetrics">Metrics</label>
            </div>
            <div class="chip">
              <input type="checkbox" id="evRepro" />
              <label for="evRepro">Repro</label>
            </div>
            <div class="chip">
              <input type="checkbox" id="evOther" />
              <label for="evOther">Other</label>
            </div>
          </div>
        </div>
        <div class="grid cols-2">
          <div class="field">
            <label for="proof">What proves a deviation exists?</label>
            <small>Examples: alerts, error messages, metric spikes/drops, log lines, screenshots, reproducible steps.</small>
            <textarea id="proof" placeholder=""></textarea>
          </div>
          <div class="field">
            <label for="objectPrefill">What is the specific object being affected?</label>
            <small>Hardware name and model, Function/Module/Method, Container/Service/API, datastore/volume/bucket/table, network element, identity/policy/role, pipeline/job.</small>
            <textarea id="objectPrefill" placeholder=""></textarea>
          </div>
        </div>
      </div>

      <div class="card" id="baseline-current">
        <h3>Baseline vs Current</h3>
        <div class="grid cols-2">
          <div class="field">
            <label id="labelHealthy" for="healthy">What does healthy look like here?</label>
            <small>What was the expected behavior?</small>
            <textarea id="healthy" placeholder=""></textarea>
          </div>
          <div class="field">
            <label id="labelNow" for="now">What is happening now?</label>
            <small>What has been verified and measured vs same baseline (same metrics as above)? What symptom is being presented?</small>
            <textarea id="now" placeholder=""></textarea>
          </div>
        </div>
      </div>
    </section>
    <!-- [section:preface] end -->

    <!-- [subtitle] start -->
    <h2 id="docSubtitle">Describe The Problem</h2>
    <!-- [subtitle] end -->

    <!-- [section:impact] start -->
    <div class="card impact">
      <h3>Impact</h3>
      <div class="grid cols-3 containment-grid">
        <fieldset class="field contain-status">
          <legend>Containment Status</legend>
          <div class="containment-radios" role="radiogroup" aria-label="Containment Status">
            <div class="radio-option">
              <input type="radio" id="containNone" name="containStatus" value="none" />
              <label for="containNone">No action yet</label>
            </div>
            <div class="radio-option">
              <input type="radio" id="containMitigation" name="containStatus" value="mitigation" />
              <label for="containMitigation">Temporary mitigation applied</label>
            </div>
            <div class="radio-option">
              <input type="radio" id="containRestore" name="containStatus" value="restore" />
              <label for="containRestore">Full restoration in progress</label>
            </div>
          </div>
        </fieldset>
        <div class="field">
          <label for="containDesc">Containment Description</label>
          <input type="text" id="containDesc" placeholder="What immediate step reduces risk?" />
        </div>
      </div>
      <div class="grid cols-3 gap-24">
        <div class="field">
          <h3>Current Impact</h3>
          <label for="impactNow">Current Impact</label>
          <small>Who/what is affected now? Quantify: users/tenants/regions, transactions failing, SLI/SLO deltas (avail %, p95/p99, error %), data at risk (loss/corruption/exposure), workarounds.</small>
          <textarea id="impactNow" placeholder=""></textarea>
        </div>
        <div class="field">
          <h3>Future Impact</h3>
          <label for="impactFuture">Future Impact</label>
          <small>If unresolved what happens? Blast radius growth, SLO/SLA breach, revenue/penalties, compliance, backlog/consumer lag, churn, on-call fatigue.</small>
          <textarea id="impactFuture" placeholder=""></textarea>
        </div>
        <div class="field">
          <h3>Timeframe</h3>
          <label for="impactTime">Timeframe</label>
          <small>When will the Future Impact become Current Impact? (Best Estimate). What deadlines/SLAs do we need to be aware of?</small>
          <textarea id="impactTime" placeholder=""></textarea>
        </div>
      </div>
    </div>
    <!-- [section:impact] end -->

    <div class="card" id="commControlsCard">
      <h3>Communication Cadence &amp; Log</h3>
      <fieldset class="field" id="communication-cadence">
        <legend id="commCadenceLegend">Communication cadence</legend>
        <div class="cadence-group" id="commCadenceGroup" role="radiogroup" aria-labelledby="commCadenceLegend">
          <label class="cadence-option">
            <input type="radio" name="commCadence" value="10" />
            <span>10 min</span>
          </label>
          <label class="cadence-option">
            <input type="radio" name="commCadence" value="15" />
            <span>15 min</span>
          </label>
          <label class="cadence-option">
            <input type="radio" name="commCadence" value="20" />
            <span>20 min</span>
          </label>
          <label class="cadence-option">
            <input type="radio" name="commCadence" value="30" />
            <span>30 min</span>
          </label>
          <label class="cadence-option">
            <input type="radio" name="commCadence" value="60" />
            <span>Hourly</span>
          </label>
        </div>
        <small>Pick how often updates should be broadcast. Logging a communication restarts the timer and reminder.</small>
      </fieldset>
      <div class="inline comm-actions">
        <button type="button" class="btn-mini" id="commInternalStampBtn" aria-label="Log internal communication">Log internal update</button>
        <button type="button" class="btn-mini" id="commExternalStampBtn" aria-label="Log external communication">Log external update</button>
        <button type="button" class="btn-mini" id="generateAiSummaryBtn" aria-label="Generate AI Summary">Generate AI Summary</button>
        <button type="button" class="btn-mini" id="commAIPromptBtn" aria-label="Use AI to draft communications">Use AI to create comms</button>
        <span class="countdown" id="commCountdown" aria-live="polite"></span>
      </div>
      <div class="comm-alert" id="commDueAlert" role="alert" hidden></div>
      <div class="grid comm-grid comm-grid--single">
        <div class="field">
          <label for="commNextUpdateTime">Next update scheduled for</label>
          <input type="time" id="commNextUpdateTime" />
        </div>
      </div>
      <div class="field" id="communication-log">
        <label for="commLogList">Communication log</label>
        <ul id="commLogList" class="comm-log" aria-live="polite" aria-label="Communication log"></ul>
        <button type="button" class="btn-mini comm-log-toggle" id="commLogToggleBtn" hidden aria-expanded="false">Show all</button>
      </div>
    </div>

    <!-- [section:table] start -->
    <p class="subtle" id="kt-is-is-not">Problem Analysis</p>

    <table id="ktTable" aria-label="KT IS / IS NOT intake table">
<colgroup>
  <col style="width:18%;">
  <col style="width:21%;">
  <col style="width:21%;">
  <col style="width:20%;">
  <col style="width:20%;">
</colgroup>

      <thead>
        <tr>
          <th scope="col">KT Question</th>
          <th scope="col">IS <span class="subtle">â€” facts only</span></th>
          <th scope="col">IS NOT <span class="subtle">â€” similar &amp; reasonable and could be but is not occuring</span></th>
          <th scope="col">Distinctions <span class="subtle">â€” Unique characteristics about the IS</span></th>
          <th scope="col">Changes <span class="subtle">â€” Changes that happened in on around or about each Distinction</span></th>
        </tr>
      </thead>
      <tbody id="tbody"></tbody>
    </table>
    <!-- [section:table] end -->


    <div id="possible-causes" tabindex="-1"></div>
    <div class="card" id="possibleCausesCard">
      <h3>Possible Causes</h3>
      <p class="caption">Capture hypotheses and pressure test them against the KT IS / IS NOT evidence. Start with the suspect, accusation, and impact; then walk each cause through the table.</p>
      <div id="causeList" class="cause-list" aria-live="polite"></div>
      <div class="cause-controls">
        <button type="button" class="btn-mini" id="addCauseBtn">Add Possible Cause</button>
      </div>
    </div>


    <!-- [section:summary] start -->
    <div class="card" id="summaryCard" style="display:none;">
      <h3>Copy &amp; Paste Summary</h3>
      <pre id="summaryPre" style="white-space:pre-wrap;font:13px/1.6 monospace;margin:0;"></pre>
    </div>
    <!-- [section:summary] end -->

  </div>

  <div id="toast" class="toast" role="status" aria-live="polite"></div>

<!-- [script] start -->
<script>
/* [rows] start */
/* =================== Core data & prompts (KT Problem Analysis) =================== */
/* Use {OBJECT} / {DEVIATION} tokens anywhere you want auto-fill. */
const ROWS = [
  { band: "WHAT", note: "Define the problem precisely (Object & Deviation)." },

  {
    q: "WHAT â€” Specific Object/Thing is having the {DEVIATION}",
    isPH:
      "What specific object has {DEVIATION}?",
    notPH:
      "What similar objects could reasonably have, but do NOT have {DEVIATION}?"
  },
  {
    q: "WHAT â€” Specific Deviation does the {OBJECT} have?",
    isPH:
      "What exactly is the deviation that has been confirmed?",
    notPH:
      "What reasonable symptoms could the {OBJECT} have had, but we have verified are NOT present?"
  },

  { band: "WHERE", note: "Locate the problem (geography/topology and on the object)." },

  {
    q: "WHERE â€” is the {OBJECT} geographically/topology when the {DEVIATION} occurs?",
    isPH:
      "Where is {OBJECT} when {DEVIATION} occurs?",
    notPH:
      "Where would you reasonably expect the {OBJECT} could have been when the {DEVIATION} was observed but we do NOT see it?"
  },
  {
    q: "WHERE â€” On the {OBJECT} is the {DEVIATION} observed?",
    isPH:
      "Where on {OBJECT} is {DEVIATION} observed?",
    notPH:
      "What neighboring parts on the {OBJECT} do NOT show {DEVIATION}?"
  },

  { band: "WHEN", note: "Timing and Description" },

  {
    q: "WHEN â€” Was the {DEVIATION} First observed for {OBJECT}",
    isPH:
      "When was {DEVIATION} first observed for {OBJECT}? (date/time/zone)",
    notPH:
      "When was the last known good for {OBJECT}? When reasonably could we have observed other {DEVIATION} on {OBJECT} but we did not?"
  },
  {
    q: "WHEN â€” Since was the first time has {DEVIATION} been logged? What Pattern?",
    isPH:
      "Since first occurrence, when does {DEVIATION} re-occur?\nâ€¢ What Pattern (continuous/periodic/sporadic/one time)",
    notPH:
      "What Similar windows/patterns of times is the {OBJECT} not having {DEVIATION}?"
  },
  {
    q: "WHEN â€” Describe using words When the {DEVIATION} was first seen",
    isPH:
      "At what point in {OBJECT}â€™s life-cycle did {DEVIATION} appear?\nâ€¢ Use words like before, during, or after to describe these times and consider multiple lifecycles",
    notPH:
      "What Adjacent life-cycle moments could we have reasonably caught or observed the {DEVIATION} but we did not?"
  },

  { band: "EXTENT", note: "How big is it? Magnitude, count, scope, trend." },

  {
    q: "EXTENT â€” What is the population or size of {OBJECT} affected?",
    isPH:
      "How many {OBJECT}s have {DEVIATION}?\nTrend (â†‘/â†“/stable)?",
    notPH:
      "What population or Comparable object sets have not been affected"
  },
  {
    q: "EXTENT â€” What is the size of a single {DEVIATION}?",
    isPH:
      "How big is a single {DEVIATION} on {OBJECT}?\nTrend (â†‘/â†“/stable)?",
    notPH:
      "What sizes could the {DEVIATION} reasonably have been but were not?"
  },
  {
    q: "EXTENT â€” How many {DEVIATION} are occuring on each {OBJECT}?",
    isPH:
      "How many instances of {DEVIATION} per {OBJECT}?\nTrend (â†‘/â†“/stable)?",
    notPH:
      "Reasonably, how many instances of {DEVIATION} could have occured per {OBJECT} but did not?"
  },
];

/* [rows] end */

/* [script:table-build] start */
/* =================== Build table & dynamic tokens =================== */
const tbody = document.getElementById('tbody');
const rowsBuilt = [];
let possibleCauses = [];
let objectIS = null;     // first WHAT â†’ IS
let deviationIS = null;  // second WHAT â†’ IS
let objectISDirty = false;
let deviationISDirty = false;

function mkBand(title, note){
  const tr = document.createElement('tr'); tr.className='band';
  const th = document.createElement('th'); th.colSpan = 5; th.innerHTML = `${title} <span>â€” ${note}</span>`;
  tr.appendChild(th); return tr;
}
function mkRow(def, i){
  const tr = document.createElement('tr'); tr.dataset.row = i;
  const th = document.createElement('th'); th.scope='row'; th.textContent = fillTokens(def.q);

  const tdIS = document.createElement('td');
  const tdNOT = document.createElement('td');
  const tdDIST = document.createElement('td');
  const tdCHG = document.createElement('td');

  const isTA  = document.createElement('textarea'); isTA.className='tableta';
  const notTA = document.createElement('textarea'); notTA.className='tableta';
  const distTA= document.createElement('textarea'); distTA.className='tableta';
  const chgTA = document.createElement('textarea'); chgTA.className='tableta';

  isTA.placeholder   = fillTokens(def.isPH || "");
  notTA.placeholder  = mkIsNotPH(fillTokens(def.notPH || ""), "");
  distTA.placeholder = mkDistPH("", "");
  chgTA.placeholder  = mkChangePH("");

  const refreshIsNotPH = ()=> notTA.placeholder = mkIsNotPH(fillTokens(def.notPH||""), isTA.value);
  const refreshDistPH  = ()=> distTA.placeholder = mkDistPH(isTA.value, notTA.value);
  const refreshChgPH   = ()=> chgTA.placeholder  = mkChangePH(distTA.value);

  [isTA,notTA,distTA,chgTA].forEach(t=>{
    autoResize(t);
    t.addEventListener('input', ()=>{
      autoResize(t);
      if(t===isTA){
        refreshIsNotPH();
        refreshDistPH();
      }else if(t===notTA){
        refreshDistPH();
      }else if(t===distTA){
        refreshChgPH();
      }
      saveToStorage();
      if(t===isTA || t===notTA){
        renderCauses();
      }else{
        updateCauseEvidencePreviews();
      }
    });
  });

  tdIS.appendChild(isTA); tdNOT.appendChild(notTA); tdDIST.appendChild(distTA); tdCHG.appendChild(chgTA);
  tr.append(th, tdIS, tdNOT, tdDIST, tdCHG);

  rowsBuilt.push({tr, th, def, isTA, notTA, distTA, chgTA});
  return tr;
}
function initTable(){
  let dataRowCount = 0;
  ROWS.forEach((def)=>{
    if(def.band){ tbody.appendChild(mkBand(def.band, def.note||'')); }
    else{
      const tr = mkRow(def, ++dataRowCount);
      tbody.appendChild(tr);
      if(dataRowCount===1) objectIS   = rowsBuilt[rowsBuilt.length-1].isTA;  // first data row IS
      if(dataRowCount===2) deviationIS= rowsBuilt[rowsBuilt.length-1].isTA;  // second data row IS
    }
  });

  [objectIS, deviationIS].forEach(el=>{
    el.addEventListener('input', ()=>{
      if(el===objectIS) objectISDirty = true;
      if(el===deviationIS) deviationISDirty = true;
      refreshAllTokenizedText();
      updateTitlesAndLabels();
      saveToStorage();
    });
  });
}
/* [script:table-build] end */

/* [script:preface-refs] start */
/* =================== Preface helpers & H1/H2 =================== */
const oneLine = document.getElementById('oneLine');
const proof = document.getElementById('proof');
const objectPrefill = document.getElementById('objectPrefill');
const healthy = document.getElementById('healthy');
const now = document.getElementById('now');

const bridgeOpenedUtc = document.getElementById('bridgeOpenedUtc');
const bridgeSetNowBtn = document.getElementById('bridgeSetNowBtn');
const icName = document.getElementById('icName');
const bcName = document.getElementById('bcName');
const semOpsName = document.getElementById('semOpsName');
const severity = document.getElementById('severity');

const detectMonitoring = document.getElementById('detectMonitoring');
const detectUserReport = document.getElementById('detectUserReport');
const detectAutomation = document.getElementById('detectAutomation');
const detectOther = document.getElementById('detectOther');

const evScreenshot = document.getElementById('evScreenshot');
const evLogs = document.getElementById('evLogs');
const evMetrics = document.getElementById('evMetrics');
const evRepro = document.getElementById('evRepro');
const evOther = document.getElementById('evOther');

const labelHealthy = document.getElementById('labelHealthy');
const labelNow = document.getElementById('labelNow');

const docTitle = document.getElementById('docTitle');
const docSubtitle = document.getElementById('docSubtitle');

const impactNow = document.getElementById('impactNow');
const impactFuture = document.getElementById('impactFuture');
const impactTime = document.getElementById('impactTime');

const containNone = document.getElementById('containNone');
const containMitigation = document.getElementById('containMitigation');
const containRestore = document.getElementById('containRestore');
const containDesc = document.getElementById('containDesc');

const commInternalStampBtn = document.getElementById('commInternalStampBtn');
const commExternalStampBtn = document.getElementById('commExternalStampBtn');
const commNextUpdateTime = document.getElementById('commNextUpdateTime');
const commControlsCard = document.getElementById('commControlsCard');
const commCadenceGroup = document.getElementById('commCadenceGroup');
const commCadenceRadios = commCadenceGroup ? [...commCadenceGroup.querySelectorAll('input[name="commCadence"]')] : [];
const commCountdown = document.getElementById('commCountdown');
const commDueAlert = document.getElementById('commDueAlert');
const commLogList = document.getElementById('commLogList');
const commLogToggleBtn = document.getElementById('commLogToggleBtn');
const stepsPanel = document.getElementById('stepsPanel');
const stepsPanelContainer = document.getElementById('stepsPanelContainer');
const stepsPanelScrim = document.getElementById('stepsPanelScrim');
const stepsToggleBtn = document.getElementById('stepsToggleBtn');
const stepsProgressChip = document.getElementById('stepsProgressChip');
const stepsChipText = document.getElementById('stepsChipText');
const stepsChipBadge = document.getElementById('stepsChipBadge');
const stepsPanelCloseBtn = document.getElementById('stepsPanelCloseBtn');
const stepsPanelProgress = document.getElementById('stepsPanelProgress');
const stepsSearchInput = document.getElementById('stepsSearchInput');
const stepsTabChecklist = document.getElementById('stepsTabChecklist');
const stepsTabLog = document.getElementById('stepsTabLog');
const stepsChecklistPanel = document.getElementById('stepsChecklistPanel');
const stepsLogPanel = document.getElementById('stepsLogPanel');
const stepsListEl = document.getElementById('stepsList');
const stepsDetailsEl = document.getElementById('stepsDetails');
const stepsLogTypeFilter = document.getElementById('stepsLogTypeFilter');
const stepsLogStepFilter = document.getElementById('stepsLogStepFilter');
const stepsLogActorFilter = document.getElementById('stepsLogActorFilter');
const stepsLogList = document.getElementById('stepsLogList');
const stepsManualForm = document.getElementById('stepsManualForm');
const stepsManualNote = document.getElementById('stepsManualNote');
const stepsManualStepSelect = document.getElementById('stepsManualStepSelect');
const stepsManualActor = document.getElementById('stepsManualActor');
const stepsSuggestionBanner = document.getElementById('stepsSuggestionBanner');
const stepsSuggestionText = document.getElementById('stepsSuggestionText');
const stepsSuggestionAction = document.getElementById('stepsSuggestionAction');
const stepsSuggestionDismiss = document.getElementById('stepsSuggestionDismiss');
const stepsModal = document.getElementById('stepsModal');
const stepsModalTitle = document.getElementById('stepsModalTitle');
const stepsModalBody = document.getElementById('stepsModalBody');
const stepsModalActions = document.getElementById('stepsModalActions');
let causeList = document.getElementById('causeList');
let addCauseBtn = document.getElementById('addCauseBtn');

let commLog = [];
let commCadence = '';
let commNextDueIso = '';
let cadenceTimerId = null;
let dueToastShown = false;
let commShowAll = false;

[oneLine, proof, objectPrefill, healthy, now].forEach(el=>{
  el.addEventListener('input', ()=>{
    // If the table fields are empty, seed them from preface
    if(el===objectPrefill && objectIS && !objectIS.value.trim()){
      objectIS.value = el.value.trim(); autoResize(objectIS);
      refreshAllTokenizedText();
    }
    if(el===now && deviationIS && !deviationIS.value.trim()){
      deviationIS.value = el.value.trim(); autoResize(deviationIS);
      refreshAllTokenizedText();
    }
    if(el===oneLine && deviationIS && !deviationIS.value.trim()){
      deviationIS.value = el.value.trim(); autoResize(deviationIS);
      refreshAllTokenizedText();
    }
    updateTitlesAndLabels();
    saveToStorage();
  });
  el.addEventListener('keyup', syncMirror);
  el.addEventListener('change', ()=>syncMirror(true));
});

[icName, bcName, semOpsName].forEach(el=>{
  if(el){ el.addEventListener('input', saveToStorage); }
});
[severity].forEach(el=>{
  if(el){ el.addEventListener('change', saveToStorage); }
});

if(commNextUpdateTime){
  commNextUpdateTime.addEventListener('change', ()=>{
    applyManualDueValue(commNextUpdateTime.value);
    saveToStorage();
  });
}

if(commCadenceRadios.length){
  commCadenceRadios.forEach(radio=>{
    radio.addEventListener('change', ()=>{
      if(!radio.checked) return;
      commCadence = radio.value;
      dueToastShown = false;
      if(commLog.length){
        const lastIso = commLog[0]?.ts;
        if(lastIso){
          const base = new Date(lastIso);
          if(!Number.isNaN(base.valueOf())){
            const mins = getCadenceMinutes();
            if(mins){
              base.setMinutes(base.getMinutes() + mins);
              setNextDue(base);
            }
          }
        }
      }
      scheduleCadenceTick();
      saveToStorage();
    });
  });
}

[
  detectMonitoring,
  detectUserReport,
  detectAutomation,
  detectOther,
  evScreenshot,
  evLogs,
  evMetrics,
  evRepro,
  evOther,
  containNone,
  containMitigation,
  containRestore
].forEach(el=>{ if(el){ el.addEventListener('change', saveToStorage); } });

if(containDesc){ containDesc.addEventListener('input', saveToStorage); }

if(bridgeSetNowBtn){
  bridgeSetNowBtn.addEventListener('click', ()=>{
    bridgeOpenedUtc.value = new Date().toISOString();
    saveToStorage();
    bridgeOpenedUtc.focus();
  });
}

if(commInternalStampBtn){
  commInternalStampBtn.addEventListener('click', ()=>logCommunication('internal'));
}

if(commExternalStampBtn){
  commExternalStampBtn.addEventListener('click', ()=>logCommunication('external'));
}

if(commLogToggleBtn){
  commLogToggleBtn.addEventListener('click', ()=>{
    commShowAll = !commShowAll;
    updateCommLogUI();
  });
}

updateCommLogUI();
scheduleCadenceTick();
/* [script:preface-refs] end */

/* ===== Steps Checklist & Activity Log ===== */
const STEPS_VERSION = 1;
const STEPS_STORAGE_KEY = 'kt-steps-v1';
const STEP_PHASE_LABELS = {
  A: 'Activate & Frame',
  B: 'Hypothesize, Test & Communicate',
  C: 'Evaluate & Decide',
  D: 'Restore, Validate & Close Comms Loop',
  E: 'Handover & Close'
};
const STEP_LINK_LABELS = {
  'problem-summary': 'Problem Summary',
  'evidence-objects': 'Evidence & Objects',
  'baseline-current': 'Baseline & Monitoring',
  'communication-cadence': 'Communication Cadence',
  'communication-log': 'Communication Log',
  'kt-is-is-not': 'KT IS / IS NOT',
  'possible-causes': 'Possible Causes'
};
const STEPS_DEFINITIONS = [
  { id:1, phase:'A', label:'Pre-analysis Completed', fullText:'Complete the KT intake pre-analysis to ensure baseline facts are captured before activation.', required:true, links:[] },
  { id:2, phase:'A', label:'Incident Commander Assigned', fullText:'Assign an Incident Commander and document ownership for the bridge.', required:true, links:[] },
  { id:3, phase:'A', label:'Step 1 Reviewed by BC', fullText:'Have the Bridge Coordinator review the initial intake and confirm priorities.', required:true, links:[] },
  { id:4, phase:'A', label:'Problem Statement Created', fullText:'Create and align on a precise problem statement for the incident.', required:true, links:['problem-summary'] },
  { id:5, phase:'A', label:'Bridge Options Considered', fullText:'Evaluate bridge options and choose the right channel for responders.', required:true, links:[] },
  { id:6, phase:'A', label:'Bridges Opened / Responders Invited', fullText:'Open the bridge and invite the right responders to participate.', required:true, links:[] },
  { id:7, phase:'A', label:'Bridge Etiquette/Roles/Guidelines Outlined', fullText:'Outline etiquette, roles, and guidelines so participants know expectations.', required:true, links:[] },
  { id:8, phase:'A', label:'Actions (Who/What/When) Documented', fullText:'Document current actions with explicit Who/What/When ownership.', required:true, links:[] },
  { id:9, phase:'A', label:'Quick Spec Answers Captured', fullText:'Capture quick specification answers and environment details that frame the incident.', required:true, links:['evidence-objects'] },
  { id:10, phase:'A', label:'Last Changes/Monitoring/Dependencies Investigated', fullText:'Investigate last changes, monitoring signals, and dependency health for context.', required:true, links:['baseline-current'] },
  { id:11, phase:'A', label:'Attendees Optimized', fullText:'Optimize bridge attendees to keep the right people engaged.', required:true, links:[] },
  { id:12, phase:'B', label:'Possible Causes Developed', fullText:'Develop possible causes grounded in collected evidence.', required:true, links:[] },
  { id:13, phase:'B', label:'Actions (Who/What/When) Documented', fullText:'Document planned actions (Who/What/When) for hypothesis testing.', required:true, links:[] },
  { id:14, phase:'B', label:'Micro-experiments/Tests Conducted', fullText:'Run micro-experiments or tests and capture the outcomes.', required:true, links:[] },
  { id:15, phase:'B', label:'Containment Options Identified', fullText:'Identify containment options and record the recommendation.', required:true, links:[] },
  { id:16, phase:'B', label:'Comms Written/Reviewed/Sent', fullText:'Draft, review, and send communications to stakeholders.', required:true, links:['communication-cadence','communication-log'] },
  { id:17, phase:'B', label:'Attendees Optimized for Next Action', fullText:'Adjust attendees for the next action or experiment.', required:true, links:[] },
  { id:18, phase:'C', label:'Possible Causes Evaluated / Distinctions Identified', fullText:'Evaluate possible causes and record key distinctions from KT analysis.', required:true, links:['kt-is-is-not'] },
  { id:19, phase:'C', label:'MPC Identified', fullText:'Identify the most probable cause and document why it fits.', required:true, links:['possible-causes'] },
  { id:20, phase:'C', label:'Restoration/Rollback/Workaround Selected', fullText:'Select the restoration, rollback, or workaround path and capture rationale.', required:true, links:['possible-causes'] },
  { id:21, phase:'C', label:'Attendees Optimized', fullText:'Ensure attendees align with the decision path and execution plan.', required:true, links:['possible-causes'] },
  { id:22, phase:'C', label:'Verification/Risk Plan Created', fullText:'Create a verification and risk plan before restoration proceeds.', required:true, links:['possible-causes'] },
  { id:23, phase:'D', label:'Actions (Who/What/When) Documented', fullText:'Document restoration or validation actions with Who/What/When clarity.', required:true, links:[] },
  { id:24, phase:'D', label:'Service Validated (Internal/External)', fullText:'Validate service internally and externally to confirm recovery.', required:true, links:[] },
  { id:25, phase:'D', label:'Restoration Comms Sent', fullText:'Send restoration communications to stakeholders and confirm distribution.', required:true, links:['communication-log','communication-cadence'] },
  { id:26, phase:'E', label:'Handover Template Prepared (PIR/Problem)', fullText:'Prepare the handover template or PIR/problem record with essential details.', required:true, links:[] },
  { id:27, phase:'E', label:'Downstream Issues from Fix Assessed', fullText:'Assess downstream issues that may result from the fix.', required:true, links:[] },
  { id:28, phase:'E', label:'Participants Released / Bridge Closed', fullText:'Release participants, close the bridge, and confirm follow-up tasks.', required:true, links:[] },
];

function createStep(def){
  return {
    id: def.id,
    phase: def.phase,
    label: def.label,
    fullText: def.fullText,
    required: def.required !== false,
    links: Array.isArray(def.links) ? def.links.slice() : [],
    checked: false,
    tsIso: null,
    assignee: null,
    note: '',
    history: [],
    skippedReason: ''
  };
}

function generateStepsLogId(){
  if(typeof crypto !== 'undefined' && crypto.randomUUID){
    return crypto.randomUUID();
  }
  return 'log-' + Math.random().toString(36).slice(2,10) + '-' + Date.now().toString(36);
}

function nowIso(){
  return new Date().toISOString();
}

function formatLocalDateTime(iso){
  if(!iso) return '';
  const d = new Date(iso);
  if(Number.isNaN(d.valueOf())) return iso;
  return d.toLocaleString([], { hour12:false, year:'numeric', month:'2-digit', day:'2-digit', hour:'2-digit', minute:'2-digit' });
}

function normalizeStepRecord(def, record){
  const base = createStep(def);
  if(record && typeof record === 'object'){
    base.checked = !!record.checked;
    base.tsIso = typeof record.tsIso === 'string' ? record.tsIso : null;
    base.assignee = typeof record.assignee === 'string' && record.assignee.trim() ? record.assignee.trim() : null;
    base.note = typeof record.note === 'string' ? record.note : '';
    if(Array.isArray(record.history)){
      base.history = record.history.filter(item=>typeof item === 'string').slice(0,3);
    }
    base.skippedReason = typeof record.skippedReason === 'string' ? record.skippedReason : '';
    if(base.skippedReason && !base.checked){
      base.checked = true;
    }
  }
  return base;
}

function normalizeLogEntry(entry){
  if(!entry || typeof entry !== 'object') return null;
  const type = typeof entry.type === 'string' ? entry.type : '';
  if(!type) return null;
  const ts = typeof entry.tsIso === 'string' ? entry.tsIso : (typeof entry.ts === 'string' ? entry.ts : null);
  if(!ts) return null;
  return {
    id: typeof entry.id === 'string' ? entry.id : generateStepsLogId(),
    tsIso: ts,
    type,
    actor: typeof entry.actor === 'string' && entry.actor.trim() ? entry.actor.trim() : null,
    stepId: Number.isFinite(entry.stepId) ? Number(entry.stepId) : (typeof entry.stepId === 'number' && !Number.isNaN(entry.stepId) ? entry.stepId : undefined),
    title: typeof entry.title === 'string' ? entry.title : '',
    note: typeof entry.note === 'string' ? entry.note : '',
    metadata: entry.metadata && typeof entry.metadata === 'object' ? entry.metadata : {}
  };
}

function buildStepsState(raw){
  const state = { version: STEPS_VERSION, steps: [], log: [] };
  const rawSteps = Array.isArray(raw?.steps) ? raw.steps : [];
  const map = new Map();
  rawSteps.forEach(item=>{
    if(item && typeof item.id === 'number'){ map.set(item.id, item); }
  });
  state.steps = STEPS_DEFINITIONS.map(def=>normalizeStepRecord(def, map.get(def.id)));
  if(Array.isArray(raw?.log)){
    raw.log.forEach(entry=>{
      const normalized = normalizeLogEntry(entry);
      if(normalized){ state.log.push(normalized); }
    });
  }
  return state;
}

function exportStepsState(){
  return {
    version: STEPS_VERSION,
    steps: stepsState.steps.map(step=>({
      id: step.id,
      checked: !!step.checked,
      tsIso: step.tsIso,
      assignee: step.assignee,
      note: step.note,
      history: step.history.slice(0,3),
      skippedReason: step.skippedReason
    })),
    log: stepsState.log.map(entry=>({
      id: entry.id,
      tsIso: entry.tsIso,
      type: entry.type,
      actor: entry.actor,
      stepId: entry.stepId,
      title: entry.title,
      note: entry.note,
      metadata: entry.metadata
    }))
  };
}

let stepsState = buildStepsState(JSON.parse(localStorage.getItem(STEPS_STORAGE_KEY) || 'null') || {});
let stepsSearchTerm = '';
let selectedStepId = (stepsState.steps.find(step=>step.required && !step.checked) || stepsState.steps[0] || {}).id || null;
let stepsPanelOpen = false;
let stepsLogFilters = { type:'all', step:'all', actor:'all' };
let stepsSuggestionTarget = null;
let stepsSaveTimer = null;
let stepsCommDue = false;
let stepsModalResolver = null;
let stepsModalReturnFocus = null;
let stepsKeyboardRows = [];
let stepsPanelReturnFocus = null;

function scheduleStepsSave(){
  if(stepsSaveTimer){ clearTimeout(stepsSaveTimer); }
  stepsSaveTimer = setTimeout(()=>{
    try{
      localStorage.setItem(STEPS_STORAGE_KEY, JSON.stringify(exportStepsState()));
    }catch(err){
      console.warn('Failed to persist steps state', err);
    }
  }, 150);
}

function getStepById(id){
  return stepsState.steps.find(step=>step.id === id) || null;
}

function importStepsState(raw){
  if(!raw) return;
  const incoming = buildStepsState(raw);
  let changed = false;
  if(incoming.steps.some(step=>step.checked || step.note || step.assignee || step.skippedReason)){
    stepsState.steps = incoming.steps;
    changed = true;
  }
  if(incoming.log.length && incoming.log.length >= stepsState.log.length){
    stepsState.log = incoming.log;
    changed = true;
  }
  if(changed){
    refreshManualStepOptions();
    refreshStepsFilters();
    renderStepsList();
    renderStepDetails();
    renderStepsLog();
    updateStepsProgressUI();
  }
}

function hideStepsSuggestion(){
  if(stepsSuggestionBanner){ stepsSuggestionBanner.hidden = true; }
  stepsSuggestionTarget = null;
}

function showStepsSuggestion(step, message){
  if(!stepsSuggestionBanner || !stepsSuggestionText || !step) return;
  stepsSuggestionTarget = { stepId: step.id };
  stepsSuggestionText.textContent = message;
  stepsSuggestionBanner.hidden = false;
}

const STEP_LOG_KIND = {
  STEP_CHECKED: 'step_checked',
  STEP_UNCHECKED: 'step_unchecked',
  STEP_UPDATED: 'step_updated',
  MANUAL: 'manual',
  COMMS: 'comms_logged'
};

function defaultStepLogTitle(type, step, extra){
  if(type === STEP_LOG_KIND.MANUAL){
    if(extra?.stepId && step){
      return `Manual entry â€“ Step ${step.id}: ${step.label}`;
    }
    return 'Manual entry';
  }
  if(type === STEP_LOG_KIND.COMMS){
    const commType = (extra?.metadata?.commType || '').toString().toLowerCase();
    const label = commType === 'external' ? 'External comms' : commType === 'internal' ? 'Internal comms' : 'Communication';
    return `${label} logged`;
  }
  if(step){
    if(type === STEP_LOG_KIND.STEP_CHECKED){ return `Step ${step.id} checked: ${step.label}`; }
    if(type === STEP_LOG_KIND.STEP_UNCHECKED){ return `Step ${step.id} unchecked: ${step.label}`; }
    if(type === STEP_LOG_KIND.STEP_UPDATED){ return `Step ${step.id} updated: ${step.label}`; }
  }
  return 'Activity logged';
}

function addStepsLogEntry(type, step, extra={}){
  if(!stepsState || !Array.isArray(stepsState.log)){
    stepsState.log = [];
  }
  const entry = {
    id: generateStepsLogId(),
    tsIso: nowIso(),
    type,
    actor: typeof extra.actor === 'string' && extra.actor.trim() ? extra.actor.trim() : (step?.assignee || null),
    stepId: extra.stepId !== undefined ? extra.stepId : step?.id,
    title: typeof extra.title === 'string' && extra.title.trim() ? extra.title : defaultStepLogTitle(type, step, extra),
    note: extra.note !== undefined ? extra.note : (step ? step.note : ''),
    metadata: extra.metadata && typeof extra.metadata === 'object' ? extra.metadata : {}
  };
  stepsState.log.unshift(entry);
  if(stepsState.log.length > 400){ stepsState.log.length = 400; }
  scheduleStepsSave();
  renderStepsLog();
  refreshStepsFilters();
}

function isStepsModalOpen(){
  return stepsModal && !stepsModal.hidden;
}

function closeStepsModal(result=null){
  if(!stepsModal) return;
  stepsModal.hidden = true;
  stepsModal.removeAttribute('data-open');
  const resolver = stepsModalResolver;
  stepsModalResolver = null;
  if(stepsModalReturnFocus && typeof stepsModalReturnFocus.focus === 'function'){
    stepsModalReturnFocus.focus();
  }
  stepsModalReturnFocus = null;
  if(typeof resolver === 'function'){
    resolver(result);
  }
}

function openStepsModal({ title, render, actions }={}){
  return new Promise(resolve=>{
    if(!stepsModal || !stepsModalTitle || !stepsModalBody || !stepsModalActions){
      resolve(null);
      return;
    }
    stepsModalResolver = value=>resolve(value);
    stepsModalTitle.textContent = title || 'Steps';
    stepsModalBody.innerHTML = '';
    let focusTarget = null;
    if(typeof render === 'function'){
      focusTarget = render(stepsModalBody) || null;
    }else if(typeof render === 'string'){
      const p = document.createElement('p');
      p.textContent = render;
      stepsModalBody.appendChild(p);
    }
    stepsModalActions.innerHTML = '';
    (actions || []).forEach(action=>{
      const btn = document.createElement('button');
      btn.type = 'button';
      btn.textContent = action.label;
      let cls = 'btn-secondary';
      if(action.variant === 'primary'){ cls = 'btn-primary'; }
      else if(action.variant === 'danger'){ cls = 'btn-danger'; }
      btn.className = cls;
      btn.addEventListener('click', ()=>{
        if(typeof action.onClick === 'function'){
          const res = action.onClick();
          if(res === false){ return; }
          closeStepsModal(res);
        }else{
          closeStepsModal(action.value);
        }
      });
      stepsModalActions.appendChild(btn);
    });
    stepsModal.hidden = false;
    stepsModal.setAttribute('data-open', 'true');
    if(!stepsModal.hasAttribute('tabindex')){ stepsModal.setAttribute('tabindex', '-1'); }
    stepsModalReturnFocus = document.activeElement instanceof HTMLElement ? document.activeElement : null;
    setTimeout(()=>{
      stepsModal.focus({ preventScroll:true });
      if(focusTarget && typeof focusTarget.focus === 'function'){
        focusTarget.focus();
      }
    }, 10);
  });
}

function parseWWWNote(note){
  const defaults = { who:'', what:'', when:'' };
  if(typeof note !== 'string' || !note.trim()) return defaults;
  note.split(/\r?\n/).forEach(line=>{
    const [rawKey, ...rest] = line.split(':');
    if(!rawKey) return;
    const key = rawKey.trim().toLowerCase();
    const value = rest.join(':').trim();
    if(key.startsWith('who')){ defaults.who = value; }
    if(key.startsWith('what')){ defaults.what = value; }
    if(key.startsWith('when')){ defaults.when = value; }
  });
  return defaults;
}

function formatWWWNote({ who, what, when }){
  return `Who: ${who}\nWhat: ${what}\nWhen: ${when}`;
}

async function promptWWW(step){
  const existing = parseWWWNote(step?.note || '');
  let whoInput, whatInput, whenInput;
  const result = await openStepsModal({
    title: 'WWW checkpoint',
    render(body){
      const intro = document.createElement('p');
      intro.textContent = 'Capture Who, What, and When before marking this step complete.';
      body.appendChild(intro);
      const makeField = (labelText, value, id)=>{
        const field = document.createElement('div'); field.className = 'steps-modal__field';
        const label = document.createElement('label'); label.setAttribute('for', id); label.textContent = labelText;
        const input = document.createElement('input'); input.type = 'text'; input.id = id; input.value = value || '';
        field.appendChild(label); field.appendChild(input); body.appendChild(field);
        return input;
      };
      whoInput = makeField('Who', existing.who, 'stepsWWWWho');
      whatInput = makeField('What', existing.what, 'stepsWWWWhat');
      whenInput = makeField('When', existing.when, 'stepsWWWWhen');
      return whoInput;
    },
    actions:[
      { label:'Cancel', value:null },
      {
        label:'Save',
        variant:'primary',
        onClick(){
          const who = (whoInput?.value || '').trim();
          const what = (whatInput?.value || '').trim();
          const when = (whenInput?.value || '').trim();
          if(!who){ whoInput.focus(); return false; }
          if(!what){ whatInput.focus(); return false; }
          if(!when){ whenInput.focus(); return false; }
          return { who, what, when };
        }
      }
    ]
  });
  return result && typeof result === 'object' ? result : null;
}

async function promptStep28Warning(missingStep){
  const result = await openStepsModal({
    title: 'Finish checklist?',
    render(body){
      const intro = document.createElement('p');
      intro.textContent = 'Some required steps are still open. Confirm before closing the bridge.';
      body.appendChild(intro);
      if(missingStep){
        const detail = document.createElement('p');
        detail.textContent = `First missing step: ${missingStep.id} â€” ${missingStep.label}`;
        body.appendChild(detail);
      }
    },
    actions:[
      { label:'Cancel', value:'cancel' },
      { label: missingStep ? `Go to Step ${missingStep.id}` : 'Review missing steps', value:'goto' },
      { label:'Mark Step 28 complete', variant:'primary', value:'continue' }
    ]
  });
  return result;
}

async function promptSkipReason(step){
  let textarea;
  const existing = typeof step?.skippedReason === 'string' ? step.skippedReason : '';
  const result = await openStepsModal({
    title: existing ? 'Update skip reason' : 'Skip step with reason',
    render(body){
      const intro = document.createElement('p');
      intro.textContent = 'Explain why this step is being treated as completed via skip.';
      body.appendChild(intro);
      const field = document.createElement('div'); field.className = 'steps-modal__field';
      const label = document.createElement('label'); label.setAttribute('for', 'stepsSkipReason'); label.textContent = 'Reason';
      textarea = document.createElement('textarea');
      textarea.id = 'stepsSkipReason';
      textarea.value = existing;
      field.appendChild(label);
      field.appendChild(textarea);
      body.appendChild(field);
      return textarea;
    },
    actions:[
      { label:'Cancel', value:null },
      {
        label: existing ? 'Update skip reason' : 'Skip step',
        variant:'primary',
        onClick(){
          const reason = (textarea?.value || '').trim();
          if(!reason){ textarea.focus(); return false; }
          return reason;
        }
      }
    ]
  });
  return typeof result === 'string' ? result : null;
}

async function confirmClearSkip(step){
  const result = await openStepsModal({
    title: 'Clear skip reason',
    render(body){
      const p = document.createElement('p');
      p.textContent = `Remove the skip reason for Step ${step.id}?`;
      body.appendChild(p);
    },
    actions:[
      { label:'Cancel', value:false },
      { label:'Clear skip', variant:'danger', value:true }
    ]
  });
  return result === true;
}

function updateStep(stepId, patch={}, { log=true, metadata }={}){
  const step = getStepById(stepId);
  if(!step) return;
  const previous = {
    assignee: step.assignee,
    note: step.note,
    skippedReason: step.skippedReason,
    checked: step.checked,
    tsIso: step.tsIso
  };
  let changed = false;
  if(Object.prototype.hasOwnProperty.call(patch, 'assignee')){
    const value = typeof patch.assignee === 'string' && patch.assignee.trim() ? patch.assignee.trim() : null;
    if((step.assignee || null) !== value){ step.assignee = value; changed = true; }
  }
  if(Object.prototype.hasOwnProperty.call(patch, 'note')){
    const value = typeof patch.note === 'string' ? patch.note : '';
    if(step.note !== value){ step.note = value; changed = true; }
  }
  if(Object.prototype.hasOwnProperty.call(patch, 'skippedReason')){
    const value = typeof patch.skippedReason === 'string' ? patch.skippedReason : '';
    if(step.skippedReason !== value){ step.skippedReason = value; changed = true; }
    if(value && !step.checked){
      step.checked = true;
      step.tsIso = step.tsIso || nowIso();
    }else if(!value && !patch.keepCompletion){
      // preserve current checked state but allow manual control elsewhere
    }
  }
  if(Object.prototype.hasOwnProperty.call(patch, 'checked')){
    const value = !!patch.checked;
    if(step.checked !== value){ step.checked = value; changed = true; }
  }
  if(Object.prototype.hasOwnProperty.call(patch, 'tsIso')){
    const value = typeof patch.tsIso === 'string' ? patch.tsIso : null;
    if(step.tsIso !== value){ step.tsIso = value; changed = true; }
  }
  if(!changed) return;
  scheduleStepsSave();
  updateStepsProgressUI();
  renderStepsList();
  renderStepDetails();
  if(log){
    addStepsLogEntry(STEP_LOG_KIND.STEP_UPDATED, step, {
      note: step.note,
      actor: step.assignee,
      metadata: Object.assign({ previous }, metadata || {})
    });
  }
  refreshManualStepOptions();
  saveToStorage();
}

async function setStepChecked(stepId, checked, { fromSuggestion=false }={}){
  const step = getStepById(stepId);
  if(!step || step.checked === checked) return;
  if(checked){
    if([8,13,23].includes(step.id)){
      const www = await promptWWW(step);
      if(!www) return;
      updateStep(step.id, { note: formatWWWNote(www), skippedReason:'' });
    }
    if(step.id === 28){
      const missing = firstRequiredIncomplete(step.id);
      if(missing){
        const decision = await promptStep28Warning(missing);
        if(decision === 'goto'){
          selectStep(missing.id, { focus:true });
          openStepsPanel(true);
          return;
        }
        if(decision !== 'continue'){ return; }
      }
    }
    step.checked = true;
    step.skippedReason = step.skippedReason || '';
    step.tsIso = nowIso();
  }else{
    if(step.tsIso){
      const history = [step.tsIso, ...(step.history || [])].filter(Boolean).slice(0,3);
      step.history = history;
    }
    step.checked = false;
    step.tsIso = null;
    step.skippedReason = '';
  }
  scheduleStepsSave();
  updateStepsProgressUI();
  renderStepsList();
  renderStepDetails();
  addStepsLogEntry(checked ? STEP_LOG_KIND.STEP_CHECKED : STEP_LOG_KIND.STEP_UNCHECKED, step, {
    note: step.note,
    actor: step.assignee,
    metadata: { fromSuggestion, history: step.history.slice(0,3) }
  });
  if(fromSuggestion){ hideStepsSuggestion(); }
  if(!checked && stepsSuggestionTarget && stepsSuggestionTarget.stepId === step.id){ hideStepsSuggestion(); }
  refreshManualStepOptions();
  saveToStorage();
}

function stepMatchesSearch(step){
  if(!stepsSearchTerm) return true;
  const haystack = [
    step.label,
    step.fullText,
    step.note,
    step.assignee,
    step.skippedReason
  ]
    .map(value=> (value || '').toString().toLowerCase())
    .join(' ');
  return haystack.includes(stepsSearchTerm);
}

function getVisibleSteps(){
  return stepsState.steps.filter(step=>stepMatchesSearch(step));
}

function focusStepRowByIndex(index){
  if(index < 0 || index >= stepsKeyboardRows.length) return;
  const row = stepsKeyboardRows[index];
  if(row){
    stepsKeyboardRows.forEach(r=>{ if(r !== row) r.tabIndex = -1; });
    row.tabIndex = 0;
    row.focus();
  }
}

function focusStepRowByStepId(stepId){
  const index = stepsKeyboardRows.findIndex(row=>Number(row.dataset.stepId) === stepId);
  if(index >= 0){ focusStepRowByIndex(index); }
}

function createStepRow(step){
  const row = document.createElement('div');
  row.className = 'step-row';
  row.dataset.stepId = String(step.id);
  row.setAttribute('role', 'checkbox');
  row.setAttribute('aria-checked', step.checked ? 'true' : 'false');
  if(step.checked){ row.setAttribute('data-checked', 'true'); } else { row.removeAttribute('data-checked'); }
  if(step.id === selectedStepId){ row.setAttribute('data-selected', 'true'); row.tabIndex = 0; }
  else{ row.removeAttribute('data-selected'); row.tabIndex = -1; }

  const checkbox = document.createElement('div');
  checkbox.className = 'step-row__checkbox';
  checkbox.textContent = step.checked ? 'âœ“' : '';
  checkbox.setAttribute('aria-hidden', 'true');

  const main = document.createElement('div');
  main.className = 'step-row__main';

  const label = document.createElement('div');
  label.className = 'step-row__label';
  label.textContent = step.label;

  const meta = document.createElement('div');
  meta.className = 'step-row__meta';

  if(step.assignee){
    const chip = document.createElement('span');
    chip.className = 'chip';
    chip.textContent = step.assignee;
    meta.appendChild(chip);
  }
  if(step.skippedReason){
    const chip = document.createElement('span');
    chip.className = 'chip';
    chip.textContent = 'Skipped';
    meta.appendChild(chip);
  }
  if(step.tsIso){
    const time = document.createElement('span');
    time.className = 'step-row__timestamp';
    time.textContent = formatLocalDateTime(step.tsIso);
    meta.appendChild(time);
  }
  if(step.note && !step.skippedReason){
    const preview = document.createElement('span');
    preview.className = 'step-row__note-preview';
    const trimmed = step.note.length > 80 ? `${step.note.slice(0,77)}â€¦` : step.note;
    preview.textContent = trimmed;
    meta.appendChild(preview);
  }
  if(!step.checked && step.history && step.history.length){
    const last = step.history[0];
    if(last){
      const prev = document.createElement('span');
      prev.className = 'step-row__timestamp';
      prev.textContent = `Last: ${formatLocalDateTime(last)}`;
      meta.appendChild(prev);
    }
  }

  main.appendChild(label);
  if(meta.children.length){ main.appendChild(meta); }
  row.appendChild(checkbox);
  row.appendChild(main);

  row.addEventListener('click', event=>{
    if(event.target.closest('.step-row__checkbox')){
      event.preventDefault();
      setStepChecked(step.id, !step.checked);
      return;
    }
    selectStep(step.id, { focus:false });
  });

  row.addEventListener('keydown', event=>{
    const key = event.key;
    if(key === 'ArrowDown' || key === 'Down'){
      event.preventDefault();
      focusStepRowByIndex(stepsKeyboardRows.indexOf(row) + 1);
      return;
    }
    if(key === 'ArrowUp' || key === 'Up'){
      event.preventDefault();
      focusStepRowByIndex(stepsKeyboardRows.indexOf(row) - 1);
      return;
    }
    if(key === ' ' || key === 'Spacebar'){
      event.preventDefault();
      setStepChecked(step.id, !step.checked);
      return;
    }
    if(key === 'Enter'){
      event.preventDefault();
      selectStep(step.id, { focus:false });
    }
  });

  return row;
}

function renderStepsList(){
  if(!stepsListEl) return;
  stepsListEl.innerHTML = '';
  stepsKeyboardRows = [];
  const visible = getVisibleSteps();
  if(visible.length && !visible.some(step=>step.id === selectedStepId)){
    selectedStepId = visible[0].id;
  }
  if(!visible.length){
    const empty = document.createElement('div');
    empty.className = 'steps-empty';
    empty.textContent = stepsSearchTerm ? 'No steps match your search.' : 'No steps available.';
    stepsListEl.appendChild(empty);
    return;
  }
  const grouped = new Map();
  visible.forEach(step=>{
    if(!grouped.has(step.phase)){ grouped.set(step.phase, []); }
    grouped.get(step.phase).push(step);
  });
  const phaseOrder = ['A','B','C','D','E'];
  phaseOrder.forEach(phase=>{
    if(!grouped.has(phase)) return;
    const steps = grouped.get(phase);
    const groupEl = document.createElement('div');
    groupEl.className = 'steps-phase';
    const title = document.createElement('div');
    title.className = 'steps-phase__title';
    const label = STEP_PHASE_LABELS[phase] || '';
    title.textContent = label ? `${phase}) ${label}` : `Phase ${phase}`;
    groupEl.appendChild(title);
    steps.forEach(step=>{
      const row = createStepRow(step);
      groupEl.appendChild(row);
      stepsKeyboardRows.push(row);
    });
    stepsListEl.appendChild(groupEl);
  });
}

function selectStep(stepId, { focus=false }={}){
  const step = getStepById(stepId);
  if(!step) return;
  const changed = selectedStepId !== stepId;
  selectedStepId = stepId;
  if(changed){
    renderStepsList();
  }
  renderStepDetails();
  if(focus){ focusStepRowByStepId(stepId); }
}

function renderStepDetails(){
  if(!stepsDetailsEl) return;
  const step = getStepById(selectedStepId);
  if(!step){
    stepsDetailsEl.textContent = 'Select a step to view details.';
    return;
  }
  stepsDetailsEl.innerHTML = '';
  const header = document.createElement('div');
  header.className = 'steps-details__header';
  const title = document.createElement('div'); title.className = 'steps-details__title'; title.textContent = `Step ${step.id}: ${step.label}`;
  const subtitle = document.createElement('div'); subtitle.className = 'steps-details__subtitle'; subtitle.textContent = step.fullText;
  header.appendChild(title); header.appendChild(subtitle);
  stepsDetailsEl.appendChild(header);

  const status = document.createElement('div'); status.className = 'steps-details__status';
  const statusLine = step.checked ? `Completed ${step.tsIso ? formatLocalDateTime(step.tsIso) : ''}` : 'Not completed';
  const statusSpan = document.createElement('span'); statusSpan.textContent = statusLine.trim(); status.appendChild(statusSpan);
  if(step.skippedReason){
    const skipSpan = document.createElement('span'); skipSpan.textContent = `Skipped: ${step.skippedReason}`;
    status.appendChild(skipSpan);
  }
  stepsDetailsEl.appendChild(status);

  const assigneeField = document.createElement('div'); assigneeField.className = 'steps-details__field';
  const assigneeLabel = document.createElement('label'); assigneeLabel.setAttribute('for', 'stepsDetailAssignee'); assigneeLabel.textContent = 'Assignee';
  const assigneeInput = document.createElement('input'); assigneeInput.type = 'text'; assigneeInput.id = 'stepsDetailAssignee'; assigneeInput.placeholder = 'IC / BC / initials'; assigneeInput.value = step.assignee || '';
  assigneeField.appendChild(assigneeLabel); assigneeField.appendChild(assigneeInput);
  stepsDetailsEl.appendChild(assigneeField);

  const noteField = document.createElement('div'); noteField.className = 'steps-details__field';
  const noteLabel = document.createElement('label'); noteLabel.setAttribute('for', 'stepsDetailNote'); noteLabel.textContent = 'Note';
  const noteTextarea = document.createElement('textarea'); noteTextarea.id = 'stepsDetailNote'; noteTextarea.placeholder = 'Add context or status notes'; noteTextarea.value = step.note || '';
  noteField.appendChild(noteLabel); noteField.appendChild(noteTextarea);
  stepsDetailsEl.appendChild(noteField);

  if(step.links && step.links.length){
    const linksField = document.createElement('div'); linksField.className = 'steps-details__field';
    const linksLabel = document.createElement('label'); linksLabel.textContent = 'Deep links'; linksField.appendChild(linksLabel);
    const linkWrap = document.createElement('div'); linkWrap.className = 'steps-links';
    step.links.forEach(linkId=>{
      const btn = document.createElement('button');
      btn.type = 'button';
      btn.className = 'steps-link-btn';
      btn.dataset.link = linkId;
      btn.textContent = STEP_LINK_LABELS[linkId] || linkId;
      btn.addEventListener('click', ()=>{
        const target = document.getElementById(linkId);
        if(target){
          target.scrollIntoView({ behavior:'smooth', block:'start' });
          if(typeof target.focus === 'function'){
            if(!target.hasAttribute('tabindex')){ target.setAttribute('tabindex','-1'); }
            target.focus({ preventScroll:true });
          }
        }
      });
      linkWrap.appendChild(btn);
    });
    linksField.appendChild(linkWrap);
    stepsDetailsEl.appendChild(linksField);
  }

  if(step.history && step.history.length){
    const history = document.createElement('div'); history.className = 'steps-history';
    const histTitle = document.createElement('div'); histTitle.textContent = 'Recent completions'; history.appendChild(histTitle);
    step.history.slice(0,3).forEach(item=>{
      const entry = document.createElement('div'); entry.className = 'steps-history__item'; entry.textContent = formatLocalDateTime(item);
      history.appendChild(entry);
    });
    stepsDetailsEl.appendChild(history);
  }

  const actions = document.createElement('div'); actions.className = 'steps-details__actions';
  const toggleBtn = document.createElement('button'); toggleBtn.type = 'button'; toggleBtn.className = 'btn-mini'; toggleBtn.dataset.action = 'toggle'; toggleBtn.textContent = step.checked ? 'Mark incomplete' : 'Mark complete';
  actions.appendChild(toggleBtn);
  if(step.skippedReason){
    const editSkip = document.createElement('button'); editSkip.type = 'button'; editSkip.className = 'steps-details__skip'; editSkip.dataset.action = 'edit-skip'; editSkip.textContent = 'Edit skip reason';
    const clearSkip = document.createElement('button'); clearSkip.type = 'button'; clearSkip.className = 'steps-details__skip'; clearSkip.dataset.action = 'clear-skip'; clearSkip.textContent = 'Clear skip';
    actions.appendChild(editSkip);
    actions.appendChild(clearSkip);
  }else{
    const skipBtn = document.createElement('button'); skipBtn.type = 'button'; skipBtn.className = 'steps-details__skip'; skipBtn.dataset.action = 'skip'; skipBtn.textContent = 'Mark as skipped';
    actions.appendChild(skipBtn);
  }
  stepsDetailsEl.appendChild(actions);

  assigneeInput.addEventListener('input', ()=>{ step.assignee = assigneeInput.value.trim() || null; scheduleStepsSave(); });
  assigneeInput.addEventListener('change', ()=>{ updateStep(step.id, { assignee: assigneeInput.value }, { log:true }); refreshManualStepOptions(); });
  noteTextarea.addEventListener('input', ()=>{ step.note = noteTextarea.value; scheduleStepsSave(); });
  noteTextarea.addEventListener('change', ()=>{ updateStep(step.id, { note: noteTextarea.value }, { log:true }); });

  actions.addEventListener('click', async event=>{
    const action = event.target?.dataset?.action;
    if(!action) return;
    if(action === 'toggle'){
      setStepChecked(step.id, !step.checked);
    }else if(action === 'skip'){
      const reason = await promptSkipReason(step);
      if(reason){ updateStep(step.id, { skippedReason: reason }, { metadata:{ skipped:true } }); refreshManualStepOptions(); }
    }else if(action === 'edit-skip'){
      const reason = await promptSkipReason(step);
      if(reason){ updateStep(step.id, { skippedReason: reason }, { metadata:{ skipped:true } }); refreshManualStepOptions(); }
    }else if(action === 'clear-skip'){
      const confirmed = await confirmClearSkip(step);
      if(confirmed){ updateStep(step.id, { skippedReason:'', keepCompletion:true }, { metadata:{ skipCleared:true } }); refreshManualStepOptions(); }
    }
  });
}

function logTypeIcon(type){
  if(type === STEP_LOG_KIND.MANUAL) return 'âœï¸';
  if(type === STEP_LOG_KIND.COMMS) return 'ðŸ“£';
  if(type === STEP_LOG_KIND.STEP_UNCHECKED) return 'â†º';
  if(type === STEP_LOG_KIND.STEP_UPDATED) return 'âœŽ';
  return 'ðŸ§©';
}

function logMatchesFilters(entry){
  if(!entry) return false;
  if(stepsLogFilters.type === 'step'){
    if(![STEP_LOG_KIND.STEP_CHECKED, STEP_LOG_KIND.STEP_UNCHECKED, STEP_LOG_KIND.STEP_UPDATED].includes(entry.type)) return false;
  }else if(stepsLogFilters.type === 'manual'){
    if(entry.type !== STEP_LOG_KIND.MANUAL) return false;
  }else if(stepsLogFilters.type === 'comms'){
    if(entry.type !== STEP_LOG_KIND.COMMS) return false;
  }
  if(stepsLogFilters.step !== 'all'){
    const targetId = Number(stepsLogFilters.step);
    if(entry.stepId !== targetId) return false;
  }
  if(stepsLogFilters.actor !== 'all'){
    const actor = entry.actor || '';
    if(actor.toLowerCase() !== stepsLogFilters.actor.toLowerCase()) return false;
  }
  return true;
}

function renderStepsLog(){
  if(!stepsLogList) return;
  stepsLogList.innerHTML = '';
  const allEntries = Array.isArray(stepsState.log) ? stepsState.log.slice() : [];
  const entries = allEntries.sort((a,b)=>{
    const aTime = new Date(a.tsIso).getTime();
    const bTime = new Date(b.tsIso).getTime();
    return bTime - aTime;
  }).filter(logMatchesFilters);
  if(!allEntries.length){
    const empty = document.createElement('div');
    empty.className = 'steps-empty';
    empty.textContent = 'No activity logged yet.';
    stepsLogList.appendChild(empty);
    return;
  }
  if(!entries.length){
    const empty = document.createElement('div');
    empty.className = 'steps-empty';
    empty.textContent = 'No activity matches the current filters.';
    stepsLogList.appendChild(empty);
    return;
  }
  entries.forEach(entry=>{
    const item = document.createElement('div');
    item.className = 'steps-log__item';
    if(entry.type === STEP_LOG_KIND.MANUAL){ item.classList.add('steps-log__item--manual'); }
    else if(entry.type === STEP_LOG_KIND.COMMS){ item.classList.add('steps-log__item--comms'); }
    else{ item.classList.add('steps-log__item--step'); }

    const meta = document.createElement('div'); meta.className = 'steps-log__meta';
    const icon = document.createElement('span'); icon.textContent = logTypeIcon(entry.type); meta.appendChild(icon);
    const time = document.createElement('span'); time.textContent = formatLocalDateTime(entry.tsIso); meta.appendChild(time);
    if(entry.actor){
      const actor = document.createElement('span'); actor.textContent = entry.actor; meta.appendChild(actor);
    }
    if(entry.stepId){
      const step = getStepById(entry.stepId);
      if(step){
        const stepLabel = document.createElement('span'); stepLabel.textContent = `Step ${step.id}: ${step.label}`;
        meta.appendChild(stepLabel);
      }
    }
    item.appendChild(meta);

    const title = document.createElement('div'); title.className = 'steps-log__title';
    const stepForTitle = entry.stepId ? getStepById(entry.stepId) : null;
    title.textContent = entry.title || defaultStepLogTitle(entry.type, stepForTitle, entry);
    item.appendChild(title);

    if(entry.note){
      const note = document.createElement('div'); note.className = 'steps-log__note'; note.textContent = entry.note;
      item.appendChild(note);
    }
    stepsLogList.appendChild(item);
  });
}

function refreshStepsFilters(){
  if(stepsLogStepFilter){
    const prev = stepsLogStepFilter.value;
    stepsLogStepFilter.innerHTML = '';
    const optionAll = document.createElement('option'); optionAll.value = 'all'; optionAll.textContent = 'All'; stepsLogStepFilter.appendChild(optionAll);
    stepsState.steps.forEach(step=>{
      const opt = document.createElement('option');
      opt.value = String(step.id);
      opt.textContent = `Step ${step.id}`;
      stepsLogStepFilter.appendChild(opt);
    });
    if(prev && [...stepsLogStepFilter.options].some(opt=>opt.value === prev)){
      stepsLogStepFilter.value = prev;
    }else{
      stepsLogStepFilter.value = 'all';
      stepsLogFilters.step = 'all';
    }
  }
  if(stepsLogActorFilter){
    const prevActor = stepsLogActorFilter.value;
    stepsLogActorFilter.innerHTML = '';
    const optionAllActor = document.createElement('option'); optionAllActor.value = 'all'; optionAllActor.textContent = 'All'; stepsLogActorFilter.appendChild(optionAllActor);
    const actors = new Set();
    stepsState.log.forEach(entry=>{ if(entry.actor){ actors.add(entry.actor); } });
    [...actors].sort().forEach(actor=>{
      const opt = document.createElement('option'); opt.value = actor; opt.textContent = actor; stepsLogActorFilter.appendChild(opt);
    });
    if(prevActor && prevActor !== 'all' && actors.has(prevActor)){
      stepsLogActorFilter.value = prevActor;
    }else{
      stepsLogActorFilter.value = 'all';
      stepsLogFilters.actor = 'all';
    }
  }
  if(stepsManualStepSelect){
    refreshManualStepOptions();
  }
}

function refreshManualStepOptions(){
  if(!stepsManualStepSelect) return;
  const prev = stepsManualStepSelect.value;
  stepsManualStepSelect.innerHTML = '';
  const none = document.createElement('option'); none.value = ''; none.textContent = 'None'; stepsManualStepSelect.appendChild(none);
  stepsState.steps.forEach(step=>{
    const opt = document.createElement('option');
    opt.value = String(step.id);
    const status = step.skippedReason ? ' (Skipped)' : step.checked ? ' (Done)' : '';
    opt.textContent = `Step ${step.id} â€” ${step.label}${status}`;
    stepsManualStepSelect.appendChild(opt);
  });
  if(prev && [...stepsManualStepSelect.options].some(opt=>opt.value === prev)){
    stepsManualStepSelect.value = prev;
  }else{
    stepsManualStepSelect.value = '';
  }
}

function handleManualLogSubmit(event){
  event.preventDefault();
  if(!stepsManualNote) return;
  const note = stepsManualNote.value.trim();
  if(!note){ stepsManualNote.focus(); return; }
  const stepValue = stepsManualStepSelect ? stepsManualStepSelect.value : '';
  const stepId = stepValue ? Number(stepValue) : undefined;
  const actor = stepsManualActor ? stepsManualActor.value.trim() : '';
  const step = Number.isFinite(stepId) ? getStepById(stepId) : null;
  addStepsLogEntry(STEP_LOG_KIND.MANUAL, step, {
    note,
    actor: actor || null,
    stepId: step ? step.id : undefined
  });
  stepsManualNote.value = '';
  if(stepsManualActor){ stepsManualActor.value = ''; }
  if(stepsManualStepSelect){ stepsManualStepSelect.value = ''; }
  scheduleStepsSave();
  saveToStorage();
}

function handleStepsSearchInput(){
  const value = stepsSearchInput ? stepsSearchInput.value.trim().toLowerCase() : '';
  stepsSearchTerm = value;
  renderStepsList();
  renderStepDetails();
}

function setStepsTab(tab){
  if(!stepsTabChecklist || !stepsTabLog || !stepsChecklistPanel || !stepsLogPanel) return;
  const isLog = tab === 'log';
  stepsTabChecklist.setAttribute('aria-selected', isLog ? 'false' : 'true');
  stepsChecklistPanel.dataset.active = isLog ? 'false' : 'true';
  stepsChecklistPanel.setAttribute('data-active', isLog ? 'false' : 'true');
  stepsTabLog.setAttribute('aria-selected', isLog ? 'true' : 'false');
  stepsLogPanel.dataset.active = isLog ? 'true' : 'false';
  stepsLogPanel.setAttribute('data-active', isLog ? 'true' : 'false');
  if(isLog){ renderStepsLog(); }
}

function openStepsPanel(focusSearch=false){
  if(!stepsPanel) return;
  if(stepsPanelOpen){
    if(focusSearch && stepsSearchInput){ stepsSearchInput.focus(); }
    return;
  }
  stepsPanelOpen = true;
  stepsPanelReturnFocus = document.activeElement instanceof HTMLElement ? document.activeElement : null;
  stepsPanel.setAttribute('aria-hidden', 'false');
  stepsPanel.setAttribute('data-open', 'true');
  renderStepsList();
  renderStepDetails();
  renderStepsLog();
  refreshStepsFilters();
  updateStepsProgressUI();
  if(focusSearch && stepsSearchInput){ setTimeout(()=>stepsSearchInput.focus(), 10); }
}

function closeStepsPanel(){
  if(!stepsPanelOpen || !stepsPanel) return;
  stepsPanelOpen = false;
  stepsPanel.setAttribute('aria-hidden', 'true');
  stepsPanel.removeAttribute('data-open');
  if(stepsPanelReturnFocus && typeof stepsPanelReturnFocus.focus === 'function'){
    stepsPanelReturnFocus.focus();
  }
  stepsPanelReturnFocus = null;
}

function toggleStepsPanel(force){
  if(force === true){ openStepsPanel(true); return; }
  if(force === false){ closeStepsPanel(); return; }
  if(stepsPanelOpen){ closeStepsPanel(); }
  else{ openStepsPanel(true); }
}

function handleStepsGlobalKeydown(event){
  if(event.altKey && (event.key === 's' || event.key === 'S')){
    event.preventDefault();
    toggleStepsPanel();
    return;
  }
  if(event.key === 'Escape'){
    if(isStepsModalOpen()){
      event.preventDefault();
      closeStepsModal(null);
      return;
    }
    if(stepsPanelOpen){
      event.preventDefault();
      closeStepsPanel();
    }
  }
}

function handleStepsCommunication(type){
  const isRestoration = !!containRestore?.checked;
  const stepId = isRestoration ? 25 : 16;
  const step = getStepById(stepId);
  const commType = type === 'external' ? 'external' : 'internal';
  addStepsLogEntry(STEP_LOG_KIND.COMMS, step, {
    metadata: { commType },
    note: commType === 'external' ? 'External communication logged.' : 'Internal communication logged.',
    title: `Communication logged (${commType === 'external' ? 'External' : 'Internal'})`
  });
  if(step && !step.checked){
    const message = stepId === 25 ? 'Restoration comms sent? Mark Step 25 complete.' : 'Comms sent? Mark Step 16 complete.';
    showStepsSuggestion(step, message);
  }
}

function initStepsFeature(){
  document.addEventListener('keydown', handleStepsGlobalKeydown);
  if(stepsToggleBtn){ stepsToggleBtn.addEventListener('click', ()=>toggleStepsPanel(true)); }
  if(stepsProgressChip){ stepsProgressChip.addEventListener('click', ()=>toggleStepsPanel(true)); }
  if(stepsPanelCloseBtn){ stepsPanelCloseBtn.addEventListener('click', ()=>toggleStepsPanel(false)); }
  if(stepsPanelScrim){ stepsPanelScrim.addEventListener('click', ()=>toggleStepsPanel(false)); }
  if(stepsSearchInput){ stepsSearchInput.addEventListener('input', handleStepsSearchInput); }
  if(stepsTabChecklist){ stepsTabChecklist.addEventListener('click', ()=>setStepsTab('checklist')); }
  if(stepsTabLog){ stepsTabLog.addEventListener('click', ()=>setStepsTab('log')); }
  if(stepsLogTypeFilter){ stepsLogTypeFilter.addEventListener('change', ()=>{ stepsLogFilters.type = stepsLogTypeFilter.value; renderStepsLog(); }); }
  if(stepsLogStepFilter){ stepsLogStepFilter.addEventListener('change', ()=>{ stepsLogFilters.step = stepsLogStepFilter.value; renderStepsLog(); }); }
  if(stepsLogActorFilter){ stepsLogActorFilter.addEventListener('change', ()=>{ stepsLogFilters.actor = stepsLogActorFilter.value; renderStepsLog(); }); }
  if(stepsManualForm){ stepsManualForm.addEventListener('submit', handleManualLogSubmit); }
  if(stepsSuggestionAction){
    stepsSuggestionAction.addEventListener('click', ()=>{
      if(stepsSuggestionTarget){
        setStepChecked(stepsSuggestionTarget.stepId, true, { fromSuggestion:true });
        hideStepsSuggestion();
      }
    });
  }
  if(stepsSuggestionDismiss){ stepsSuggestionDismiss.addEventListener('click', hideStepsSuggestion); }
  if(stepsModal){
    stepsModal.addEventListener('click', event=>{
      if(event.target === stepsModal){ closeStepsModal(null); }
    });
  }
  refreshStepsFilters();
  renderStepsList();
  renderStepDetails();
  renderStepsLog();
  updateStepsProgressUI();
  setStepsTab('checklist');
}

function firstRequiredIncomplete(excludeId){
  return stepsState.steps.find(step=>step.required && !step.checked && step.id !== excludeId) || null;
}

function computeStepsTone(completed, total){
  if(!total) return 'low';
  const ratio = completed / total;
  if(ratio >= 0.7) return 'high';
  if(ratio >= 0.3) return 'mid';
  return 'low';
}

function updateStepsProgressUI(){
  const total = stepsState.steps.length;
  const completed = stepsState.steps.filter(step=>step.checked).length;
  const text = `Steps Â· ${completed}/${total} âœ“`;
  if(stepsChipText){ stepsChipText.textContent = text; }
  if(stepsPanelProgress){ stepsPanelProgress.textContent = `${completed}/${total} âœ“`; }
  if(stepsProgressChip){
    stepsProgressChip.setAttribute('data-tone', computeStepsTone(completed, total));
    stepsProgressChip.setAttribute('aria-label', `Steps progress ${completed} of ${total} completed`);
  }
  updateStepsCommBadge();
}

function updateStepsCommBadge(){
  if(!stepsChipBadge) return;
  stepsChipBadge.hidden = !stepsCommDue;
}

function setStepsCommDue(isDue){
  stepsCommDue = !!isDue;
  updateStepsCommBadge();
}

function getCadenceMinutes(){
  const mins = parseInt(commCadence, 10);
  return Number.isFinite(mins) ? mins : null;
}

function updateCadenceRadios(){
  if(!commCadenceRadios.length) return;
  commCadenceRadios.forEach(radio=>{
    radio.checked = radio.value === commCadence;
  });
}

function toTimeValue(date){
  if(!(date instanceof Date) || Number.isNaN(date.valueOf())) return '';
  const h = String(date.getHours()).padStart(2,'0');
  const m = String(date.getMinutes()).padStart(2,'0');
  return `${h}:${m}`;
}

function isoFromTimeValue(value){
  if(!value) return '';
  const parts = value.split(':');
  if(parts.length < 2) return '';
  const [hh, mm] = parts.map(Number);
  if(Number.isNaN(hh) || Number.isNaN(mm)) return '';
  const now = new Date();
  const candidate = new Date(now);
  candidate.setHours(hh, mm, 0, 0);
  if(candidate.getTime() <= now.getTime()){
    candidate.setDate(candidate.getDate() + 1);
  }
  return candidate.toISOString();
}

function toggleCommDue(isDue){
  if(commControlsCard){
    commControlsCard.classList.toggle('communication-due', !!isDue);
  }
  if(commDueAlert){
    if(isDue){
      commDueAlert.textContent = 'Next communication is due now. Reconfirm updates.';
      commDueAlert.hidden = false;
    }else{
      commDueAlert.textContent = '';
      commDueAlert.hidden = true;
    }
  }
  setStepsCommDue(!!isDue);
}

function formatCountdown(ms){
  const totalSeconds = Math.max(0, Math.round(ms/1000));
  const mins = Math.floor(totalSeconds/60);
  const secs = totalSeconds % 60;
  if(mins >= 60){
    const hours = Math.floor(mins/60);
    const rem = mins % 60;
    return `${hours}h ${rem}m`;
  }
  if(mins > 0){
    return `${mins}m ${String(secs).padStart(2,'0')}s`;
  }
  return `${secs}s`;
}

function updateCommLogUI(){
  if(!commLogList) return;
  commLogList.innerHTML = '';
  if(!commLog.length){
    const li = document.createElement('li');
    li.className = 'comm-log__empty';
    li.textContent = 'No communications logged yet.';
    commLogList.appendChild(li);
    if(commLogToggleBtn){
      commLogToggleBtn.hidden = true;
      commLogToggleBtn.setAttribute('aria-expanded', 'false');
    }
    return;
  }
  const limit = 6;
  const entries = commShowAll ? commLog : commLog.slice(0, limit);
  entries.forEach(entry=>{
    const li = document.createElement('li');
    const typeSpan = document.createElement('span');
    typeSpan.className = 'comm-log__type';
    typeSpan.textContent = entry.type === 'external' ? 'External' : 'Internal';
    const timeEl = document.createElement('time');
    timeEl.className = 'comm-log__time';
    if(entry.ts){
      const d = new Date(entry.ts);
      if(!Number.isNaN(d.valueOf())){
        timeEl.dateTime = entry.ts;
        timeEl.textContent = d.toLocaleString([], { hour:'2-digit', minute:'2-digit', second:'2-digit', hour12:false });
      }else{
        timeEl.textContent = entry.ts;
      }
    }
    li.appendChild(typeSpan);
    li.appendChild(timeEl);
    commLogList.appendChild(li);
  });
  if(commLogToggleBtn){
    const hasExtra = commLog.length > limit;
    commLogToggleBtn.hidden = !hasExtra;
    if(hasExtra){
      commLogToggleBtn.textContent = commShowAll ? 'Show less' : 'Show all';
      commLogToggleBtn.setAttribute('aria-expanded', commShowAll ? 'true' : 'false');
    }else{
      commLogToggleBtn.setAttribute('aria-expanded', 'false');
    }
  }
}

function setNextDue(date){
  if(!(date instanceof Date) || Number.isNaN(date.valueOf())) return;
  commNextDueIso = date.toISOString();
  const val = toTimeValue(date);
  if(commNextUpdateTime){ commNextUpdateTime.value = val; }
  dueToastShown = false;
  scheduleCadenceTick();
}

function applyManualDueValue(value){
  if(!value){
    commNextDueIso = '';
    dueToastShown = false;
    if(commNextUpdateTime){ commNextUpdateTime.value = ''; }
    toggleCommDue(false);
    if(commCountdown){ commCountdown.textContent = ''; }
    return;
  }
  const iso = isoFromTimeValue(value);
  if(!iso) return;
  commNextDueIso = iso;
  if(commNextUpdateTime){ commNextUpdateTime.value = value; }
  toggleCommDue(false);
  dueToastShown = false;
  scheduleCadenceTick();
  updateCadenceState();
}

function updateCadenceState(){
  if(!commCountdown) return;
  if(!commNextDueIso){
    commCountdown.textContent = '';
    toggleCommDue(false);
    return;
  }
  const now = new Date();
  const due = new Date(commNextDueIso);
  if(Number.isNaN(due.valueOf())){
    commCountdown.textContent = '';
    toggleCommDue(false);
    return;
  }
  const diff = due.getTime() - now.getTime();
  if(diff <= 0){
    commCountdown.textContent = 'Due now';
    toggleCommDue(true);
    if(!dueToastShown){
      dueToastShown = true;
      if(typeof showToast === 'function'){ showToast('Next communication is due now.'); }
    }
    return;
  }
  commCountdown.textContent = `Next in ${formatCountdown(diff)}`;
  toggleCommDue(false);
}

function scheduleCadenceTick(){
  if(cadenceTimerId){ clearInterval(cadenceTimerId); }
  cadenceTimerId = setInterval(updateCadenceState, 15000);
  updateCadenceState();
}

function logCommunication(type){
  const now = new Date();
  const iso = now.toISOString();
  commLog.unshift({ type, ts: iso });
  commLog = commLog.slice(0, 20);
  commShowAll = false;
  updateCommLogUI();
  const mins = getCadenceMinutes();
  if(mins){
    const due = new Date(now);
    due.setMinutes(due.getMinutes() + mins);
    setNextDue(due);
  }
  handleStepsCommunication(type);
  saveToStorage();
}

/* ===== Possible causes (hypotheses) ===== */
const CAUSE_FINDING_MODES = {
  ASSUMPTION: 'assumption',
  YES: 'yes',
  FAIL: 'fail'
};
const CAUSE_FINDING_MODE_VALUES = Object.values(CAUSE_FINDING_MODES);

function isValidFindingMode(mode){
  return typeof mode === 'string' && CAUSE_FINDING_MODE_VALUES.includes(mode);
}
function normalizeFindingEntry(entry){
  const normalized = { mode:'', note:'' };
  if(entry && typeof entry === 'object'){
    if(typeof entry.mode === 'string'){
      const mode = entry.mode.trim().toLowerCase();
      if(isValidFindingMode(mode)){ normalized.mode = mode; }
    }
    if(typeof entry.note === 'string'){
      normalized.note = entry.note;
    }else if(typeof entry.note === 'number'){
      normalized.note = String(entry.note);
    }
    const explainIs = typeof entry.explainIs === 'string' ? entry.explainIs.trim() : '';
    const explainNot = typeof entry.explainNot === 'string' ? entry.explainNot.trim() : '';
    if(!normalized.mode && (explainIs || explainNot)){
      normalized.mode = CAUSE_FINDING_MODES.YES;
      normalized.note = [explainIs, explainNot].filter(Boolean).join('\n');
    }else if(normalized.mode && !normalized.note && (explainIs || explainNot)){
      normalized.note = [explainIs, explainNot].filter(Boolean).join('\n');
    }
  }else if(typeof entry === 'string'){
    normalized.mode = CAUSE_FINDING_MODES.YES;
    normalized.note = entry;
  }
  return normalized;
}
function findingMode(entry){
  if(!entry || typeof entry !== 'object') return '';
  const mode = typeof entry.mode === 'string' ? entry.mode : '';
  return isValidFindingMode(mode) ? mode : '';
}
function findingNote(entry){
  if(!entry || typeof entry !== 'object') return '';
  return typeof entry.note === 'string' ? entry.note : '';
}
function findingIsComplete(entry){
  const mode = findingMode(entry);
  if(!mode) return false;
  const note = findingNote(entry).trim();
  if(!note) return false;
  return true;
}
function peekCauseFinding(cause, key){
  if(!cause || !cause.findings || typeof cause.findings !== 'object') return null;
  const existing = cause.findings[key];
  if(!existing) return null;
  const normalized = normalizeFindingEntry(existing);
  cause.findings[key] = normalized;
  return normalized;
}
function causeHasFailure(cause){
  if(!cause) return false;
  const indexes = evidencePairIndexes();
  if(!indexes.length) return false;
  for(let i=0;i<indexes.length;i++){
    const entry = peekCauseFinding(cause, getRowKeyByIndex(indexes[i]));
    if(entry && findingMode(entry) === CAUSE_FINDING_MODES.FAIL){
      return true;
    }
  }
  return false;
}
function countCauseAssumptions(cause){
  if(!cause) return 0;
  const indexes = evidencePairIndexes();
  let total = 0;
  indexes.forEach(idx=>{
    const entry = peekCauseFinding(cause, getRowKeyByIndex(idx));
    if(entry && findingMode(entry) === CAUSE_FINDING_MODES.ASSUMPTION){ total++; }
  });
  return total;
}
function substituteEvidenceTokens(template, isText, notText){
  if(typeof template !== 'string') return '';
  const safeIs = (isText || '').trim() || 'IS column';
  const safeNot = (notText || '').trim() || 'IS NOT column';
  return template
    .replace(/<is\s+not>/gi, safeNot)
    .replace(/<is>/gi, safeIs);
}
function generateCauseId(){
  return 'cause-' + Math.random().toString(36).slice(2,8) + '-' + Date.now().toString(36);
}
function createEmptyCause(){
  return {
    id: generateCauseId(),
    suspect: '',
    accusation: '',
    impact: '',
    findings: {},
    editing: true,
    testingOpen: false
  };
}
function hasCompleteHypothesis(cause){
  if(!cause) return false;
  return ['suspect','accusation','impact'].every(key=>typeof cause[key]==='string' && cause[key].trim().length);
}
function buildHypothesisSentence(cause){
  if(!cause) return '';
  const suspect = (cause.suspect||'').trim();
  const accusation = (cause.accusation||'').trim();
  const impact = (cause.impact||'').trim();
  if(!suspect && !accusation && !impact){
    return 'Add suspect, accusation, and impact to craft a strong hypothesis.';
  }
  const fallback = text=> (text && text.trim()) ? text.trim() : 'â€¦';
  return `We suspect ${fallback(suspect)} because ${fallback(accusation)}, which results in ${fallback(impact)}.`;
}
function getRowKeyByIndex(index){
  const row = rowsBuilt[index];
  if(row && row.def && row.def.q){
    return row.def.q;
  }
  return `row-${index}`;
}
function ensureCauseFindings(cause){
  if(!cause.findings || typeof cause.findings !== 'object'){
    cause.findings = {};
  }
  return cause.findings;
}
function getCauseFinding(cause, key){
  const map = ensureCauseFindings(cause);
  map[key] = normalizeFindingEntry(map[key]);
  return map[key];
}
function setCauseFindingValue(cause, key, prop, value){
  const entry = getCauseFinding(cause, key);
  if(prop === 'mode'){
    const normalized = typeof value === 'string' ? value.trim().toLowerCase() : '';
    entry.mode = isValidFindingMode(normalized) ? normalized : '';
    if(!entry.mode){ entry.note = ''; }
  }else if(prop === 'note'){
    entry.note = typeof value === 'string' ? value : '';
  }else{
    entry[prop] = value;
  }
}
function rowHasEvidencePair(row){
  if(!row) return false;
  const isText = typeof row?.isTA?.value === 'string' ? row.isTA.value.trim() : '';
  const notText = typeof row?.notTA?.value === 'string' ? row.notTA.value.trim() : '';
  return Boolean(isText && notText);
}
function evidencePairIndexes(){
  const indexes = [];
  rowsBuilt.forEach((row, index)=>{
    if(rowHasEvidencePair(row)){
      indexes.push(index);
    }
  });
  return indexes;
}
function countCompletedEvidence(cause, eligibleIndexes){
  let count = 0;
  const indexes = Array.isArray(eligibleIndexes) ? eligibleIndexes : evidencePairIndexes();
  indexes.forEach(index=>{
    const key = getRowKeyByIndex(index);
    const entry = peekCauseFinding(cause, key);
    if(entry && findingIsComplete(entry)){ count++; }
  });
  return count;
}
function causeStatusState(cause, answered, total){
  if(!hasCompleteHypothesis(cause)) return 'draft';
  if(total === 0) return 'no-evidence';
  if(causeHasFailure(cause)) return 'failed';
  if(answered === 0) return 'not-tested';
  if(answered < total) return 'testing';
  return 'explained';
}
function causeStatusLabel(cause){
  const eligibleIndexes = evidencePairIndexes();
  const total = eligibleIndexes.length;
  const answered = countCompletedEvidence(cause, eligibleIndexes);
  if(cause?.editing) return 'Editing hypothesis';
  if(!hasCompleteHypothesis(cause)) return 'Draft hypothesis';
  if(total === 0) return rowsBuilt.length ? 'Waiting for KT evidence pairs' : 'Ready to test';
  if(causeHasFailure(cause)) return 'Failed testing';
  if(answered === 0) return 'Not tested yet';
  if(answered < total) return 'Testing in progress';
  return 'Explains all evidence';
}
function updateCauseProgressChip(chip, cause){
  if(!chip || !cause) return;
  const eligibleIndexes = evidencePairIndexes();
  const total = eligibleIndexes.length;
  const answered = countCompletedEvidence(cause, eligibleIndexes);
  chip.textContent = total ? `${answered}/${total} evidence checks` : 'No KT evidence pairs yet';
  const status = causeStatusState(cause, answered, total);
  chip.dataset.status = status;
}
function updateCauseStatusLabel(el, cause){
  if(!el) return;
  el.textContent = causeStatusLabel(cause);
}
function updateCauseCardIndicators(card, cause){
  if(!card || !cause) return;
  const failureEl = card.querySelector('.cause-card__failure');
  const assumptionEl = card.querySelector('.cause-card__assumptions');
  const failed = causeHasFailure(cause);
  if(failureEl){ failureEl.hidden = !failed; }
  if(failed){
    card.dataset.failed = 'true';
  }else{
    delete card.dataset.failed;
  }
  if(assumptionEl){
    const count = countCauseAssumptions(cause);
    if(count > 0){
      assumptionEl.hidden = false;
      assumptionEl.textContent = count === 1 ? '1 assumption' : `${count} assumptions`;
    }else{
      assumptionEl.hidden = true;
    }
  }
}
function previewEvidenceText(value){
  const lines = splitLines(value);
  if(!lines.length) return 'â€”';
  return lines.map(line=>`â€¢ ${line}`).join('\n');
}
function makeRemoveButton(cause){
  const btn = document.createElement('button');
  btn.type = 'button';
  btn.className = 'btn-mini btn-ghost';
  btn.textContent = 'Remove';
  btn.addEventListener('click', ()=>{
    if(confirm('Remove this possible cause?')){
      possibleCauses = possibleCauses.filter(item=>item.id !== cause.id);
      renderCauses();
      saveToStorage();
    }
  });
  return btn;
}
function ensurePossibleCausesUI(){
  let card = document.getElementById('possibleCausesCard');
  if(!card){
    const wrap = document.querySelector('.wrap');
    if(!wrap) return;
    card = document.createElement('div');
    card.className = 'card';
    card.id = 'possibleCausesCard';
    const heading = document.createElement('h3');
    heading.textContent = 'Possible Causes';
    const caption = document.createElement('p');
    caption.className = 'caption';
    caption.textContent = 'Capture hypotheses and pressure test them against the KT IS / IS NOT evidence. Start with the suspect, accusation, and impact; then walk each cause through the table.';
    const list = document.createElement('div');
    list.className = 'cause-list';
    list.id = 'causeList';
    list.setAttribute('aria-live', 'polite');
    const controls = document.createElement('div');
    controls.className = 'cause-controls';
    const btn = document.createElement('button');
    btn.type = 'button';
    btn.className = 'btn-mini';
    btn.id = 'addCauseBtn';
    btn.textContent = 'Add Possible Cause';
    controls.appendChild(btn);
    card.append(heading, caption, list, controls);
    const summaryCard = document.getElementById('summaryCard');
    if(summaryCard?.parentNode){
      summaryCard.parentNode.insertBefore(card, summaryCard);
    }else if(wrap){
      wrap.appendChild(card);
    }
  }
  causeList = document.getElementById('causeList');
  addCauseBtn = document.getElementById('addCauseBtn');
  if(addCauseBtn && !addCauseBtn.dataset.bound){
    addCauseBtn.dataset.bound = 'true';
    addCauseBtn.addEventListener('click', ()=>{
      const newCause = createEmptyCause();
      possibleCauses.push(newCause);
      renderCauses();
      saveToStorage();
      focusFirstEditableCause();
    });
  }
}
function renderCauses(){
  if(!causeList){
    ensurePossibleCausesUI();
  }
  if(!causeList) return;
  causeList.innerHTML = '';
  if(!possibleCauses.length){
    const empty = document.createElement('div');
    empty.className = 'cause-empty';
    empty.textContent = 'No possible causes captured yet.';
    causeList.appendChild(empty);
    updateCauseEvidencePreviews();
    return;
  }
  possibleCauses.forEach((cause, index)=>{
    if(!cause.id){ cause.id = generateCauseId(); }
    const card = document.createElement('article');
    card.className = 'cause-card';
    card.dataset.causeId = cause.id;
    if(cause.editing){ card.dataset.editing = 'true'; }
    const header = document.createElement('div');
    header.className = 'cause-card__header';
    const meta = document.createElement('div');
    meta.className = 'cause-card__meta';
    const titleEl = document.createElement('span');
    titleEl.className = 'cause-card__title';
    titleEl.textContent = `Possible Cause ${index+1}`;
    const statusEl = document.createElement('span');
    statusEl.className = 'cause-card__status';
    meta.append(titleEl, statusEl);
    const indicators = document.createElement('div');
    indicators.className = 'cause-card__indicators';
    const failureTag = document.createElement('span');
    failureTag.className = 'cause-card__failure';
    failureTag.textContent = 'Failed Testing';
    failureTag.hidden = true;
    const chip = document.createElement('span');
    chip.className = 'cause-card__chip';
    const assumptionTag = document.createElement('span');
    assumptionTag.className = 'cause-card__assumptions';
    assumptionTag.hidden = true;
    indicators.append(failureTag, chip, assumptionTag);
    header.append(meta, indicators);
    card.append(header);
    updateCauseStatusLabel(statusEl, cause);
    updateCauseProgressChip(chip, cause);
    const summaryEl = document.createElement('p');
    summaryEl.className = 'cause-card__summary';
    summaryEl.dataset.role = 'hypothesis';
    summaryEl.textContent = buildHypothesisSentence(cause);
    card.append(summaryEl);
    if(cause.editing){
      const helper = document.createElement('small');
      helper.className = 'cause-card__helper subtle';
      helper.textContent = 'Answer the prompts to refine the hypothesis statement.';
      card.append(helper);
      const form = document.createElement('div');
      form.className = 'cause-card__form';
      const suspectField = document.createElement('div');
      suspectField.className = 'field';
      const suspectLabel = document.createElement('label');
      suspectLabel.textContent = 'What/Who is the Suspect?';
      const suspectInput = document.createElement('textarea');
      suspectInput.value = cause.suspect || '';
      suspectInput.placeholder = 'Name the component, service, team, or actor you believe is responsible.';
      suspectInput.setAttribute('data-min-height','120');
      suspectInput.addEventListener('input', e=>{
        cause.suspect = e.target.value;
        autoResize(suspectInput);
        summaryEl.textContent = buildHypothesisSentence(cause);
        updateCauseStatusLabel(statusEl, cause);
        updateCauseProgressChip(chip, cause);
        saveToStorage();
      });
      autoResize(suspectInput);
      suspectField.append(suspectLabel, suspectInput);
      const accusationField = document.createElement('div');
      accusationField.className = 'field';
      const accusationLabel = document.createElement('label');
      accusationLabel.textContent = 'What is the Accusation?';
      const accusationInput = document.createElement('textarea');
      accusationInput.value = cause.accusation || '';
      accusationInput.placeholder = 'Describe the behavior, change, or failure you believe is occurring.';
      accusationInput.setAttribute('data-min-height','120');
      accusationInput.addEventListener('input', e=>{
        cause.accusation = e.target.value;
        autoResize(accusationInput);
        summaryEl.textContent = buildHypothesisSentence(cause);
        updateCauseStatusLabel(statusEl, cause);
        updateCauseProgressChip(chip, cause);
        saveToStorage();
      });
      autoResize(accusationInput);
      accusationField.append(accusationLabel, accusationInput);
      const impactField = document.createElement('div');
      impactField.className = 'field';
      const impactLabel = document.createElement('label');
      impactLabel.textContent = 'So What? How does this create the problem?';
      const impactInput = document.createElement('textarea');
      impactInput.value = cause.impact || '';
      impactInput.placeholder = 'Clarify how this cause would produce the customer or system impact.';
      impactInput.setAttribute('data-min-height','120');
      impactInput.addEventListener('input', e=>{
        cause.impact = e.target.value;
        autoResize(impactInput);
        summaryEl.textContent = buildHypothesisSentence(cause);
        updateCauseStatusLabel(statusEl, cause);
        updateCauseProgressChip(chip, cause);
        saveToStorage();
      });
      autoResize(impactInput);
      impactField.append(impactLabel, impactInput);
      form.append(suspectField, accusationField, impactField);
      card.append(form);
      const controls = document.createElement('div');
      controls.className = 'cause-controls';
      const saveBtn = document.createElement('button');
      saveBtn.type = 'button';
      saveBtn.className = 'btn-mini';
      saveBtn.textContent = 'Save hypothesis';
      saveBtn.addEventListener('click', ()=>{
        if(!hasCompleteHypothesis(cause)){
          if(typeof showToast === 'function'){ showToast('Fill in all three prompts to save this possible cause.'); }
          return;
        }
        cause.editing = false;
        renderCauses();
        saveToStorage();
      });
      controls.append(saveBtn);
      controls.append(makeRemoveButton(cause));
      card.append(controls);
    }else{
      const controls = document.createElement('div');
      controls.className = 'cause-controls';
      const editBtn = document.createElement('button');
      editBtn.type = 'button';
      editBtn.className = 'btn-mini btn-ghost';
      editBtn.textContent = 'Edit';
      editBtn.addEventListener('click', ()=>{
        cause.editing = true;
        renderCauses();
        saveToStorage();
        focusFirstEditableCause();
      });
      const testBtn = document.createElement('button');
      testBtn.type = 'button';
      testBtn.className = 'btn-mini';
      testBtn.textContent = cause.testingOpen ? 'Hide testing' : 'Test this cause';
      testBtn.addEventListener('click', ()=>{
        cause.testingOpen = !cause.testingOpen;
        renderCauses();
        saveToStorage();
      });
      controls.append(editBtn, testBtn, makeRemoveButton(cause));
      card.append(controls);
      if(cause.testingOpen){
        card.append(buildCauseTestPanel(cause, chip, statusEl, card));
      }
    }
    causeList.appendChild(card);
    updateCauseCardIndicators(card, cause);
  });
  updateCauseEvidencePreviews();
}
function buildCauseTestPanel(cause, progressChip, statusEl, card){
  const panel = document.createElement('div');
  panel.className = 'cause-test';
  const intro = document.createElement('p');
  intro.className = 'cause-test__intro';
  intro.textContent = 'For each KT row, choose how this hypothesis handles the IS / IS NOT evidence and document your reasoning.';
  panel.appendChild(intro);
  if(!rowsBuilt.length){
    const empty = document.createElement('div');
    empty.className = 'cause-empty';
    empty.textContent = 'Add IS / IS NOT evidence first to begin testing this cause.';
    panel.appendChild(empty);
    return panel;
  }
  const eligibleIndexes = evidencePairIndexes();
  if(!eligibleIndexes.length){
    const empty = document.createElement('div');
    empty.className = 'cause-empty';
    empty.textContent = 'Add IS / IS NOT evidence pairs to begin testing this cause.';
    panel.appendChild(empty);
    return panel;
  }
  eligibleIndexes.forEach(index=>{
    const row = rowsBuilt[index];
    const rowKey = getRowKeyByIndex(index);
    const finding = getCauseFinding(cause, rowKey);
    const rowEl = document.createElement('section');
    rowEl.className = 'cause-eval-row';
    rowEl.dataset.rowIndex = index;
    rowEl.dataset.rowKey = rowKey;
    const qText = document.createElement('div');
    qText.className = 'cause-eval-question-text';
    qText.dataset.role = 'question';
    qText.textContent = row?.th?.textContent?.trim() || fillTokens(row?.def?.q || '');
    rowEl.appendChild(qText);
    const evidenceWrap = document.createElement('div');
    evidenceWrap.className = 'cause-evidence-wrap';
    const isBlock = document.createElement('div');
    isBlock.className = 'cause-evidence-block';
    isBlock.dataset.rowIndex = index;
    isBlock.dataset.type = 'is';
    const isLabel = document.createElement('span');
    isLabel.className = 'cause-evidence-label';
    isLabel.textContent = 'IS evidence';
    const isValue = document.createElement('div');
    isValue.className = 'cause-evidence-text';
    isValue.dataset.role = 'is-value';
    isValue.textContent = previewEvidenceText(row?.isTA?.value || '');
    isBlock.append(isLabel, isValue);
    const notBlock = document.createElement('div');
    notBlock.className = 'cause-evidence-block';
    notBlock.dataset.rowIndex = index;
    notBlock.dataset.type = 'not';
    const notLabel = document.createElement('span');
    notLabel.className = 'cause-evidence-label';
    notLabel.textContent = 'IS NOT evidence';
    const notValue = document.createElement('div');
    notValue.className = 'cause-evidence-text';
    notValue.dataset.role = 'not-value';
    notValue.textContent = previewEvidenceText(row?.notTA?.value || '');
    notBlock.append(notLabel, notValue);
    evidenceWrap.append(isBlock, notBlock);
    rowEl.appendChild(evidenceWrap);
    const inputsWrap = document.createElement('div');
    inputsWrap.className = 'cause-eval-inputs';
    const optionWrap = document.createElement('div');
    optionWrap.className = 'cause-eval-options';
    const noteField = document.createElement('div');
    noteField.className = 'field cause-eval-note';
    noteField.hidden = true;
    const noteLabel = document.createElement('label');
    noteLabel.dataset.role = 'note-label';
    const noteInput = document.createElement('textarea');
    noteInput.dataset.role = 'finding-note';
    noteInput.value = findingNote(finding);
    noteInput.placeholder = 'Select an option to describe this relationship.';
    noteInput.setAttribute('data-min-height','120');
    noteInput.disabled = true;
    noteInput.addEventListener('input', e=>{
      setCauseFindingValue(cause, rowKey, 'note', e.target.value);
      autoResize(noteInput);
      updateCauseProgressChip(progressChip, cause);
      updateCauseStatusLabel(statusEl, cause);
      updateCauseCardIndicators(card, cause);
      saveToStorage();
    });
    autoResize(noteInput);
    noteField.append(noteLabel, noteInput);
    inputsWrap.append(optionWrap, noteField);
    rowEl.appendChild(inputsWrap);

    const optionDefs = [
      {
        mode: CAUSE_FINDING_MODES.ASSUMPTION,
        buttonLabel: 'Explains Only ifâ€¦',
        noteLabel: 'What assumptions are necessary to explain why we see it on the <is> and not the <is not>?',
        placeholder: 'List the assumptions required so we observe <is> while avoiding <is not>.'
      },
      {
        mode: CAUSE_FINDING_MODES.YES,
        buttonLabel: 'Yes, becauseâ€¦',
        noteLabel: 'How does this naturally explain that we see <is> and that we don\'t see <is not>?',
        placeholder: 'Describe how this cause naturally creates <is> and avoids <is not>.'
      },
      {
        mode: CAUSE_FINDING_MODES.FAIL,
        buttonLabel: 'Does not explainâ€¦',
        noteLabel: 'Why can\'t we explain the <is> being present, but not the <is not>?',
        placeholder: 'Explain why this cause cannot produce <is> without contradicting <is not>.'
      }
    ];
    const buttons = [];
    const rawIs = row?.isTA?.value || '';
    const rawNot = row?.notTA?.value || '';

    function applyMode(newMode, opts={}){
      const active = isValidFindingMode(newMode) ? newMode : '';
      buttons.forEach(btn=>{
        btn.element.classList.toggle('is-selected', btn.mode === active);
      });
      if(active){
        const config = optionDefs.find(def=>def.mode === active);
        const labelTemplate = config?.noteLabel || '';
        const placeholderTemplate = config?.placeholder || '';
        noteLabel.textContent = substituteEvidenceTokens(labelTemplate, rawIs, rawNot);
        noteLabel.dataset.template = labelTemplate;
        noteInput.placeholder = substituteEvidenceTokens(placeholderTemplate, rawIs, rawNot);
        noteInput.dataset.placeholderTemplate = placeholderTemplate;
        noteInput.disabled = false;
        noteField.hidden = false;
      }else{
        noteLabel.textContent = '';
        delete noteLabel.dataset.template;
        noteInput.placeholder = 'Select an option to describe this relationship.';
        delete noteInput.dataset.placeholderTemplate;
        noteInput.value = '';
        noteInput.disabled = true;
        noteField.hidden = true;
        setCauseFindingValue(cause, rowKey, 'note', '');
      }
      autoResize(noteInput);
      if(!opts.silent){
        updateCauseProgressChip(progressChip, cause);
        updateCauseStatusLabel(statusEl, cause);
        updateCauseCardIndicators(card, cause);
        saveToStorage();
      }
    }

    optionDefs.forEach(def=>{
      const btn = document.createElement('button');
      btn.type = 'button';
      btn.className = 'cause-eval-option';
      btn.textContent = def.buttonLabel;
      btn.dataset.mode = def.mode;
      btn.addEventListener('click', ()=>{
        const entry = getCauseFinding(cause, rowKey);
        const current = findingMode(entry);
        if(current === def.mode){
          setCauseFindingValue(cause, rowKey, 'mode', '');
          applyMode('');
        }else{
          setCauseFindingValue(cause, rowKey, 'mode', def.mode);
          applyMode(def.mode);
        }
      });
      optionWrap.appendChild(btn);
      buttons.push({ element: btn, mode: def.mode });
    });

    const startingMode = findingMode(finding);
    noteInput.value = findingNote(finding);
    autoResize(noteInput);
    applyMode(startingMode, {silent:true});
    panel.appendChild(rowEl);
  });
  return panel;
}
function updateCauseEvidencePreviews(){
  if(!causeList) return;
  causeList.querySelectorAll('.cause-eval-row').forEach(rowEl=>{
    const index = parseInt(rowEl.dataset.rowIndex, 10);
    if(Number.isNaN(index) || !rowsBuilt[index]) return;
    const row = rowsBuilt[index];
    const questionEl = rowEl.querySelector('[data-role="question"]');
    if(questionEl){ questionEl.textContent = row?.th?.textContent?.trim() || fillTokens(row?.def?.q || ''); }
    const isValue = rowEl.querySelector('[data-role="is-value"]');
    const rawIs = row?.isTA?.value || '';
    const rawNot = row?.notTA?.value || '';
    if(isValue){ isValue.textContent = previewEvidenceText(rawIs); }
    const notValue = rowEl.querySelector('[data-role="not-value"]');
    if(notValue){ notValue.textContent = previewEvidenceText(rawNot); }
    const noteLabel = rowEl.querySelector('[data-role="note-label"]');
    if(noteLabel && noteLabel.dataset.template){
      noteLabel.textContent = substituteEvidenceTokens(noteLabel.dataset.template, rawIs, rawNot);
    }
    const noteInput = rowEl.querySelector('textarea[data-role="finding-note"]');
    if(noteInput && noteInput.dataset.placeholderTemplate){
      noteInput.placeholder = substituteEvidenceTokens(noteInput.dataset.placeholderTemplate, rawIs, rawNot);
    }
  });
  causeList.querySelectorAll('.cause-card').forEach(card=>{
    const id = card?.dataset?.causeId;
    if(!id) return;
    const cause = possibleCauses.find(item=>item.id === id);
    if(!cause) return;
    const chip = card.querySelector('.cause-card__chip');
    if(chip){ updateCauseProgressChip(chip, cause); }
    const statusEl = card.querySelector('.cause-card__status');
    if(statusEl){ updateCauseStatusLabel(statusEl, cause); }
    updateCauseCardIndicators(card, cause);
  });
}
function focusFirstEditableCause(){
  requestAnimationFrame(()=>{
    const target = causeList?.querySelector('[data-editing="true"] textarea');
    if(target){
      target.focus();
      const end = target.value.length;
      try{ target.setSelectionRange(end, end); }catch(_){ /* no-op */ }
    }
  });
}
function serializeCauses(){
  return possibleCauses.map(cause=>{
    const findings = {};
    if(cause.findings && typeof cause.findings === 'object'){
      Object.keys(cause.findings).forEach(key=>{
        const normalized = normalizeFindingEntry(cause.findings[key]);
        const mode = findingMode(normalized);
        const note = findingNote(normalized);
        if(mode || note.trim()){
          findings[key] = { mode, note };
          cause.findings[key] = normalized;
        }else{
          delete cause.findings[key];
        }
      });
    }
    return {
      id: cause.id || generateCauseId(),
      suspect: cause.suspect || '',
      accusation: cause.accusation || '',
      impact: cause.impact || '',
      findings,
      editing: !!cause.editing,
      testingOpen: !!cause.testingOpen
    };
  });
}
function deserializeCauses(rawList){
  if(!Array.isArray(rawList)) return [];
  return rawList.map(raw=>{
    const cause = {
      id: typeof raw.id === 'string' ? raw.id : generateCauseId(),
      suspect: typeof raw.suspect === 'string' ? raw.suspect : '',
      accusation: typeof raw.accusation === 'string' ? raw.accusation : '',
      impact: typeof raw.impact === 'string' ? raw.impact : '',
      findings: {},
      editing: !!raw.editing,
      testingOpen: !!raw.testingOpen
    };
    if(raw && raw.findings && typeof raw.findings === 'object'){
      Object.keys(raw.findings).forEach(key=>{
        const normalized = normalizeFindingEntry(raw.findings[key]);
        const mode = findingMode(normalized);
        const note = findingNote(normalized);
        if(mode || note.trim()){
          cause.findings[key] = normalized;
        }
      });
    }
    return cause;
  });
}

/* [script:tokens] start */
function firstSnippet(v){
  const s = (v||'').trim();
  if(!s) return '';
  // Return the first line or sentence, up to 120 chars (not just one char)
  const first = s.split(/\n|\. /)[0];
  return first.length > 120 ? first.slice(0,120) : first;
}
function compactOneLine(str, max=90){
  const s = (str||'').trim().replace(/\s+/g,' ');
  return s.length>max ? s.slice(0,max-1)+'â€¦' : s;
}
function getObjectFull(){
  return (objectPrefill.value || objectIS?.value || '').trim();
}
function getDeviationFull(){
  // Treat "What is happening now?" as the deviation for the problem statement.
  return (now.value || deviationIS?.value || '').trim();
}
function objectAnchor(){
  // Use a compact anchor for labels (not the full paragraph to keep labels readable)
  const src = getObjectFull() || 'the object';
  return compactOneLine(src, 80);
}
function fillTokens(text){
  const obj = firstSnippet(objectIS?.value)    || firstSnippet(getObjectFull()) || 'the object';
  const dev = firstSnippet(deviationIS?.value) || firstSnippet(getDeviationFull()) || 'the deviation';
  return (text||'').replace(/\{OBJECT\}/g, 'â€œ'+obj+'â€').replace(/\{DEVIATION\}/g, 'â€œ'+dev+'â€');
}
function mkIsNotPH(baseCopy, isVal){
  const base = (baseCopy||'').trim();
  const isSnippet = firstSnippet(isVal);
  if(isSnippet){
    const prompt = fillTokens(``);
    return base ? `${prompt}\n\n${base}` : prompt;
  }
  return base || fillTokens('');
}
function mkDistPH(isVal, notVal){
  const base = fillTokens('');
  const isSnippet = firstSnippet(isVal);
  const notSnippet = firstSnippet(notVal);
  const parts = [];
  if(isSnippet){ parts.push(`What is different, odd, special, or uniquely true about â€œ${isSnippet}â€?`); }
  if(notSnippet){ parts.push(`Only list traits that are not shared by â€œ${notSnippet}â€`); }
  const lead = parts.length ? parts.join(' ') + '' : '';
  return lead ? `${lead}\n${base}` : base;
}
function mkChangePH(distText){
  const base = fillTokens('');
  const distSnippet = firstSnippet(distText);
  if(distSnippet){
    return `What changed in, on, around, or about â€œ${distSnippet}â€, Ask this question for each distinction listed.\n${base}`;
  }
  return base;
}
function refreshAllTokenizedText(){
  rowsBuilt.forEach(({th, def, isTA, notTA})=>{
    th.textContent = fillTokens(def.q);
    isTA.placeholder  = fillTokens(def.isPH||"");
    notTA.placeholder = mkIsNotPH(fillTokens(def.notPH||""), isTA.value);
  });
  updateCauseEvidencePreviews();
}
function updateTitlesAndLabels(){
  const objFull = getObjectFull();
  const devFull = getDeviationFull();
  const objAnch = objectAnchor();

  if(objFull && devFull){
    // H1/H2 use the FULL text as requested (concatenated)
    docTitle.textContent = `${objFull} â€” ${devFull}`;
    docSubtitle.textContent = `What is happening now to ${objAnch}: ${devFull}`;
    document.title = `${compactOneLine(objFull, 50)} â€” ${compactOneLine(devFull, 50)} Â· KT Intake`;
  }else{
    docTitle.textContent = "KT Intake";
    docSubtitle.textContent = "Describe Problem";
    document.title = "KT Intake";
  }

  // Dynamic labels for Healthy/Now
  labelNow.textContent = objAnch ? `What is happening now to ${objAnch}?` : "What is happening now?";
  labelHealthy.textContent = objAnch ? `What does healthy look like here for ${objAnch}?` : "What does healthy look like?";

  // (Optional) adjust placeholders subtly to reflect anchor
  if(objAnch){
    now.placeholder = ``;
    healthy.placeholder = ``;
  }
}
/* [script:tokens] end */


/* ===== Mirror Sync (robust against extensions/overlays) ===== */
let _mirrorTick = null;
let _lastPrefObj = "";
let _lastPrefNow = "";
function syncMirror(force=false){
  try{
    const curObj = getObjectFull();
    const curNow = getDeviationFull();
    let changed = false;
    if(force || curObj !== _lastPrefObj){
      _lastPrefObj = curObj;
      if(objectIS && !objectISDirty){
        if(objectIS.value !== curObj){
          objectIS.value = curObj;
          autoResize(objectIS);
          changed = true;
        }
      }
    }
    if(force || curNow !== _lastPrefNow){
      _lastPrefNow = curNow;
      if(deviationIS && !deviationISDirty){
        if(deviationIS.value !== curNow){
          deviationIS.value = curNow;
          autoResize(deviationIS);
          changed = true;
        }
      }
    }
    if(changed || force){
      refreshAllTokenizedText();
      updateTitlesAndLabels();
      saveToStorage();
    }
  }catch(e){ /* no-op */ }
}
/* [script:init] start */
function autoResize(el){
  if(!el || el.tagName !== 'TEXTAREA') return;
  el.style.height = 'auto';
  const attr = parseInt(el.getAttribute('data-min-height') || '', 10);
  const varMin = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--ta-min-h'), 10);
  const fallback = Number.isFinite(varMin) ? varMin : 140;
  const minH = Number.isFinite(attr) ? attr : fallback;
  const base = Number.isFinite(attr) ? attr : 140;
  el.style.height = Math.max(minH, el.scrollHeight, base) + 'px';
}
function init(){
  initTable();
  ensurePossibleCausesUI();
  renderCauses();
  initStepsFeature();
  restoreFromStorage();
  if(bridgeOpenedUtc && !bridgeOpenedUtc.value.trim()){
    bridgeOpenedUtc.value = new Date().toISOString();
    saveToStorage();
  }
  refreshAllTokenizedText();
  updateTitlesAndLabels();
  // Kick off periodic sync to capture extension-driven edits (e.g., Grammarly)
  if(!_mirrorTick){ _mirrorTick = setInterval(syncMirror, 300); }
  // Do an immediate sync so existing values populate
  syncMirror(true);
}
init();
/* [script:init] end */

/* [script:export] start */

/* =================== Summary Export (executive style, chat-friendly) =================== */

function ensureSummaryCard(){
  let card = document.getElementById('summaryCard');
  if(!card){
    const wrap = document.querySelector('.wrap');
    card = document.createElement('div');
    card.className = 'card';
    card.id = 'summaryCard';
    const h = document.createElement('h3'); h.textContent = 'Copy & Paste Summary';
    const pre = document.createElement('pre'); pre.id='summaryPre'; pre.style.whiteSpace='pre-wrap'; pre.style.font='13px/1.6 monospace'; pre.style.margin='0';
    card.appendChild(h); card.appendChild(pre);
    wrap.appendChild(card);
  }
  return card;
}

// Normalize user text into a single logical string for table cells (weâ€™ll wrap visually in the table).
function inlineText(s){
  const v=(s||'').trim();
  if(!v) return 'â€”';
  return v
    .split(/\r?\n/)
    .map(x=>x.trim())
    .filter(Boolean)
    .join(' Â· ');
}

function inlineSummaryText(s){
  const lines = splitLines(s);
  if(!lines.length) return '';
  return lines.join(' Â· ');
}

function summaryLine(label, value){
  const text = inlineSummaryText(value);
  if(!text) return '';
  return `${label}: ${text}`;
}

function summaryLineRaw(label, value){
  const text = (value||'').trim();
  if(!text) return '';
  return `${label}: ${text}`;
}

function summaryBullet(label, value){
  const text = inlineSummaryText(value);
  if(!text) return '';
  return `â€¢ ${label}: ${text}`;
}

function summaryBulletRaw(label, value){
  const text = (value||'').trim();
  if(!text) return '';
  return `â€¢ ${label}: ${text}`;
}

function joinSummaryLines(lines){
  return lines.filter(line=>line && line.trim().length).join('\n');
}

function splitLines(text){
  const v=(text||'').trim();
  if(!v) return [];
  return v.split(/\r?\n/).map(line=>line.trim()).filter(Boolean);
}

function formatLabeledList(label, lines){
  if(!lines.length) return '';
  if(lines.length === 1) return `${label}: ${lines[0]}`;
  const bullets = lines.map(line=>`  â€¢ ${line}`).join('\n');
  return `${label}:\n${bullets}`;
}

function formatDistinctionChanges(distLines, changeLines){
  const len = Math.max(distLines.length, changeLines.length);
  if(len === 0) return '';
  if(len === 1){
    const left = distLines[0] || 'â€”';
    const right = changeLines[0] || 'â€”';
    return `Distinctions â†’ Changes: ${left} â†’ ${right}`;
  }
  const pairs = [];
  for(let i=0;i<len;i++){
    const left = distLines[i] || 'â€”';
    const right = changeLines[i] || 'â€”';
    pairs.push(`  â€¢ ${left} â†’ ${right}`);
  }
  return ['Distinctions â†’ Changes:', ...pairs].join('\n');
}

function formatChipsetSelections(list){
  const selected = list.filter(item=>item.el?.checked).map(item=>item.label);
  return selected.length ? selected.join(', ') : '';
}

function containmentStatusText(){
  const status = getContainmentStatus();
  if(status==='mitigation') return 'Temporary mitigation applied';
  if(status==='restore') return 'Full restoration in progress';
  if(status==='none') return 'No action yet';
  return '';
}

function latestCommEntry(type){
  if(!Array.isArray(commLog)) return null;
  return commLog.find(entry=>entry && entry.type === type && entry.ts);
}

function formatCommTimestamp(ts){
  if(!ts) return '';
  const d = new Date(ts);
  if(Number.isNaN(d.valueOf())) return ts;
  return d.toISOString();
}

function formatCommSummaryLine(type, label){
  const entry = latestCommEntry(type);
  if(!entry) return '';
  const ts = formatCommTimestamp(entry.ts);
  return ts ? `${label}: ${ts}` : '';
}

function nextUpdateSummaryLine(){
  if(commNextDueIso){
    const d = new Date(commNextDueIso);
    if(!Number.isNaN(d.valueOf())){
      return `Next Update: ${d.toISOString()}`;
    }
    return `Next Update: ${commNextDueIso}`;
  }
  if(commNextUpdateTime?.value){
    return `Next Update: ${commNextUpdateTime.value}`;
  }
  return '';
}

function causeProgressSummary(cause){
  const eligibleIndexes = evidencePairIndexes();
  const total = eligibleIndexes.length;
  if(total === 0) return 'No KT evidence pairs captured yet';
  const answered = countCompletedEvidence(cause, eligibleIndexes);
  if(causeHasFailure(cause)){
    return `${answered}/${total} evidence checks â€¢ Failed on at least one check`;
  }
  return `${answered}/${total} evidence checks complete`;
}

function formatCauseFindingsSummary(cause){
  if(!cause || !cause.findings) return '';
  const eligibleIndexes = evidencePairIndexes();
  if(!eligibleIndexes.length) return '';
  const sections = [];
  eligibleIndexes.forEach(index=>{
    const row = rowsBuilt[index];
    const key = getRowKeyByIndex(index);
    const entry = peekCauseFinding(cause, key);
    if(!entry) return;
    const mode = findingMode(entry);
    const note = findingNote(entry);
    if(!mode && !note.trim()) return;
    const label = row?.th?.textContent?.trim() || fillTokens(row?.def?.q || `Row ${index+1}`);
    const lines = [`  â€¢ ${label}`];
    if(mode === CAUSE_FINDING_MODES.ASSUMPTION){
      lines.push(`    - Assumptions needed: ${inlineText(note)}`);
    }else if(mode === CAUSE_FINDING_MODES.YES){
      lines.push(`    - Explains evidence: ${inlineText(note)}`);
    }else if(mode === CAUSE_FINDING_MODES.FAIL){
      lines.push(`    - Fails because: ${inlineText(note)}`);
    }else if(note.trim()){
      lines.push(`    - Notes: ${inlineText(note)}`);
    }
    sections.push(lines.join('\n'));
  });
  return sections.length ? ['Evidence walkthrough:', ...sections].join('\n') : '';
}

function formatPossibleCausesSummary(){
  if(!possibleCauses.length){
    return 'No possible causes captured.';
  }
  const blocks = possibleCauses.map((cause, index)=>{
    const header = `â€¢ Possible Cause ${index+1}: ${buildHypothesisSentence(cause)}`;
    const status = `  Status: ${causeStatusLabel(cause)}`;
    const progress = `  Progress: ${causeProgressSummary(cause)}`;
    const failureLine = causeHasFailure(cause) ? '  Result: Failed testing on at least one evidence check' : '';
    const assumptionCount = countCauseAssumptions(cause);
    const assumptionLine = assumptionCount ? `  Assumptions noted: ${assumptionCount}` : '';
    const evidence = formatCauseFindingsSummary(cause);
    return [header, status, progress, failureLine, assumptionLine, evidence].filter(Boolean).join('\n');
  });
  return blocks.join('\n\n');
}

function formatStepsSummary(){
  if(!stepsState || !Array.isArray(stepsState.steps)) return '';
  const total = stepsState.steps.length;
  const completed = stepsState.steps.filter(step=>step.checked).length;
  const lines = [`Completed: ${completed}/${total}`];
  const open = stepsState.steps.filter(step=>step.required && !step.checked);
  const skipped = stepsState.steps.filter(step=>step.skippedReason);
  if(open.length){
    lines.push('Open Items:');
    open.forEach(step=>{
      lines.push(`  â€¢ Step ${step.id} â€” ${step.label}`);
    });
  }
  if(skipped.length){
    lines.push('Skipped:');
    skipped.forEach(step=>{
      lines.push(`  â€¢ Step ${step.id} â€” ${step.label} (Reason: ${step.skippedReason})`);
    });
  }
  if(Array.isArray(stepsState.log) && stepsState.log.length){
    const sorted = stepsState.log.slice().sort((a,b)=> new Date(a.tsIso).getTime() - new Date(b.tsIso).getTime());
    lines.push('Activity Log:');
    sorted.forEach(entry=>{
      const parts = [formatLocalDateTime(entry.tsIso)];
      if(entry.actor){ parts.push(entry.actor); }
      let label = entry.type;
      if(entry.type === STEP_LOG_KIND.STEP_CHECKED) label = 'Checked';
      else if(entry.type === STEP_LOG_KIND.STEP_UNCHECKED) label = 'Unchecked';
      else if(entry.type === STEP_LOG_KIND.STEP_UPDATED) label = 'Updated';
      else if(entry.type === STEP_LOG_KIND.MANUAL) label = 'Manual';
      else if(entry.type === STEP_LOG_KIND.COMMS) label = 'Comms';
      parts.push(label);
      const step = entry.stepId ? getStepById(entry.stepId) : null;
      if(step){ parts.push(`Step ${step.id}: ${step.label}`); }
      let line = `  â€¢ ${parts.join(' â€” ')}`;
      if(entry.note){ line += ` â€” ${entry.note}`; }
      lines.push(line);
    });
  }
  return lines.join('\n');
}

/* ---------- Executive summary builder ---------- */
function buildSummaryText(){
  const title = document.getElementById('docTitle').textContent.trim();
  const subtitle = document.getElementById('docSubtitle').textContent.trim();

  const detectionSummary = formatChipsetSelections([
    {el: detectMonitoring, label: 'Monitoring'},
    {el: detectUserReport, label: 'User Report'},
    {el: detectAutomation, label: 'Automation'},
    {el: detectOther, label: 'Other'}
  ]);

  const evidenceSummary = formatChipsetSelections([
    {el: evScreenshot, label: 'Screenshot'},
    {el: evLogs, label: 'Logs'},
    {el: evMetrics, label: 'Metrics'},
    {el: evRepro, label: 'Repro'},
    {el: evOther, label: 'Other'}
  ]);

  // === Preface (inline answers) ===
  const prefaceLines = [
    summaryBullet('One-line', oneLine.value),
    summaryBullet('Evidence/Proof', proof.value),
    summaryBullet('Specific Object', objectPrefill.value || (objectIS?.value||'')),
    summaryBullet('Healthy Baseline', healthy.value),
    summaryBullet('Current State (What is happening now?)', now.value),
    summaryBulletRaw('Detection Source', detectionSummary),
    summaryBulletRaw('Evidence Collected', evidenceSummary)
  ];
  const preface = joinSummaryLines(prefaceLines);

  // === Impact (inline answers) ===
  const impactLines = [
    summaryLine('Current Impact', impactNow.value),
    summaryLine('Future Impact', impactFuture.value),
    summaryLine('Timeframe', impactTime.value)
  ];
  const imp = joinSummaryLines(impactLines);

  const containmentLines = [
    summaryLineRaw('Status', containmentStatusText()),
    summaryLine('Description', containDesc?.value)
  ];
  const containment = joinSummaryLines(containmentLines);

  const communications = joinSummaryLines([
    formatCommSummaryLine('internal', 'Last Internal Update'),
    formatCommSummaryLine('external', 'Last External Update'),
    nextUpdateSummaryLine()
  ]);

  // === KT Table as chat-friendly blocks per question ===
  const rowsOut = [];
  let pendingBand = '';

  [...tbody.querySelectorAll('tr')].forEach(tr=>{
    if(tr.classList.contains('band')){
      pendingBand = `== ${tr.textContent.trim()} ==`;
      return;
    }
    const q = tr.querySelector('th').textContent.trim();
    const t = tr.querySelectorAll('textarea');
    const isLines = splitLines(t[0].value);
    const notLines = splitLines(t[1].value);
    const distLines = splitLines(t[2].value);
    const changeLines = splitLines(t[3].value);

    // Question header
    const sections = [
      formatLabeledList('IS', isLines),
      formatLabeledList('IS NOT', notLines),
      formatDistinctionChanges(distLines, changeLines)
    ].filter(Boolean);
    if(!sections.length) return;
    if(pendingBand){
      rowsOut.push(pendingBand);
      pendingBand = '';
    }
    rowsOut.push(`Q: ${q}`);
    sections.forEach(section=>rowsOut.push(section));
  });

  const ktOut = rowsOut.filter(line=>line && line.trim().length).join('\n\n');

  // === Compose (minimal blank lines between major sections) ===
  const sectionsOut = [];
  if(title.trim()){ sectionsOut.push(title.trim()); }
  if(subtitle.trim()){ sectionsOut.push(subtitle.trim()); }
  function pushSection(label, body){
    const content = (body||'').trim();
    if(!content) return;
    if(sectionsOut.length){ sectionsOut.push(''); }
    sectionsOut.push(label);
    sectionsOut.push(content);
  }

  const bridgeLines = [
    summaryLineRaw('Bridge Opened (UTC)', bridgeOpenedUtc?.value),
    summaryLineRaw('Incident Commander', icName?.value),
    summaryLineRaw('Bridge Coordinator', bcName?.value),
    summaryLineRaw('SEM/Ops Lead', semOpsName?.value),
    summaryLineRaw('Severity', severity?.value)
  ];
  const bridge = joinSummaryLines(bridgeLines);

  pushSection('â€” Bridge Activation â€”', bridge);
  pushSection('â€” Preface â€”', preface);
  pushSection('â€” Containment â€”', containment);
  pushSection('â€” Impact â€”', imp);
  pushSection('â€” Communications â€”', communications);
  const stepsSummary = formatStepsSummary();
  if(stepsSummary.trim().length){
    pushSection('â€” Steps Checklist â€”', stepsSummary);
  }
  const causes = formatPossibleCausesSummary();
  if(causes.trim().length){
    pushSection('â€” Possible Causes â€”', causes);
  }
  if(ktOut.trim().length){
    pushSection('â€” KT IS / IS NOT â€”', ktOut);
  }

  return sectionsOut.join('\n');
}



const PROMPT_PREAMBLE = `You are ChatGPT acting as an incident communications specialist.
Following NIST SP 800-61, ISO/IEC 27035, and ITIL major incident best practices, craft two communication log entries:
one for internal stakeholders and one for external customers.
Each entry should include recommended tone, key talking points, risk framing, and next steps.
Use the incident context below to tailor the guidance.`;

/**
 * Unified summary generator.
 * @param {string} kind   - e.g., "summary" (reserved for extensibility)
 * @param {string} aiType - if "ai summary", prepend expert instructions
 */
async function generateSummary(kind='summary', aiType=''){
  void kind; // reserved for future use

  const baseText = buildSummaryText();

  let output = baseText;
  const normalizedType = typeof aiType === 'string' ? aiType.trim().toLowerCase() : '';
  if(normalizedType === 'ai summary'){
    const expertPrefix = `You are an expert in:

Incident Management (ITIL 4, ISO 20000-1, ISO 27001)

Major Incident communication (NIST SP 800-61 emergency comms best practices)

Kepner-Tregoe Situation Appraisal and IS / IS NOT problem analysis

Executive communication (clear, concise, jargon-free)

Your task is to take the information I paste after this prompt and produce two separate communication messages:

âœ… Output #1 â€” INTERNAL COMMUNICATION UPDATE (for leadership & technical teams)

Audience: internal â€” executives, stakeholders, engineering teams
Goal: alignment and clarity on what is known / unknown / next steps

Format using these headings:

Incident Name / Reference ID:
Current Status: (e.g., Major Incident Active â€“ Priority 1)
Situation Appraisal (KT format):

Concerns / issues identified

Priorities (what should be worked on first and why)

IS / IS NOT Analysis (KT format):

IS: (confirmed facts)

IS NOT: (ruled out variables)

What we know / What we donâ€™t know yet:
Immediate actions taken:
Next steps / owners / ETAs:
Decision / ask for leadership: (if relevant)
Planned internal update cadence: (e.g., every 30 mins)

Keep the tone concise, factual, non-emotional. Avoid speculation and blame.

âœ… Output #2 â€” EXTERNAL COMMUNICATION UPDATE (for customers / business users)

Audience: external â€” end users, customers, executives
Goal: confidence, clarity, and reduced anxiety â€” without technical noise

Format using these headings:

Status: (plain language, no acronyms)
Impact: (what users experience, scope of impact)
What we are doing: (reassurance + action)
What you need to do: (if anything)
Next update: (time commitment)

Follow these rules:

Do not include internal details or root cause speculation.

Be plain language. Example: instead of "database replication latency," say "our systems are not syncing data correctly."

Keep the update short, calm, and confident.

Tone guideline:

â€œClear, factual, and reassuring.â€

When generating both updates:

âœ” Apply KT thinking (no assumptions â€” separate Known vs. Unknown)
âœ” Apply ITIL/ISO/NIST best practices (clarity, ownership, cadence, impact)
âœ” Prioritize accuracy > completeness

I will paste all the known information next. Analyze it and reply with the two formatted communications. Do not ask clarifying questions; make reasonable assumptions and proceed.`;
    output = `${expertPrefix}\n\n${baseText}`;
  }else if(normalizedType === 'prompt preamble'){
    output = `${PROMPT_PREAMBLE}\n\n${baseText}`;
  }

  const card = ensureSummaryCard();
  const pre = document.getElementById('summaryPre');
  if(pre){ pre.textContent = output; }
  if(card){ card.style.display = 'block'; }

  try{
    if(window.isSecureContext && navigator.clipboard && navigator.clipboard.writeText){
      await navigator.clipboard.writeText(output);
      if(typeof showToast==='function'){ showToast('Summary updated & copied. Itâ€™s also shown below.'); }
    }else{
      if(typeof showToast==='function'){ showToast('Summary updated. Clipboard blocked â€” copy it from the bottom.'); }
    }
  }catch(_){
    if(typeof showToast==='function'){ showToast('Summary updated. Clipboard blocked â€” copy it from the bottom.'); }
  }
}

async function runSummaryFlow({usePromptPreamble=false}={}){
  const aiType = usePromptPreamble ? 'prompt preamble' : '';
  return generateSummary('summary', aiType);
}

async function onGenerateSummary(){
  return generateSummary('summary', '');
}

async function onGenerateAIPrompt(){
  return generateSummary('summary', 'prompt preamble');
}

document.addEventListener('DOMContentLoaded', function(){
  var btn = document.getElementById('genSummaryBtn');
  if(btn){ btn.addEventListener('click', onGenerateSummary); }
  var aiPromptBtn = document.getElementById('commAIPromptBtn');
  if(aiPromptBtn){ aiPromptBtn.addEventListener('click', onGenerateAIPrompt); }
  var aiSummaryBtn = document.getElementById('generateAiSummaryBtn');
  if(aiSummaryBtn){ aiSummaryBtn.addEventListener('click', function(){ generateSummary('summary', 'ai summary'); }); }
});

/* [script:export] end */

/* [script:storage] start */
/* =================== Autosave =================== */
const STORAGE_KEY='kt-intake-full-v2';
function getContainmentStatus(){
  if(containMitigation?.checked) return 'mitigation';
  if(containRestore?.checked) return 'restore';
  if(containNone?.checked) return 'none';
  return '';
}
function saveToStorage(){
  const data={ pre:{ oneLine:oneLine.value, proof:proof.value, objectPrefill:objectPrefill.value, healthy:healthy.value, now:now.value },
               impact:{ now:impactNow.value, future:impactFuture.value, time:impactTime.value },
               ops:{
                 bridgeOpenedUtc:bridgeOpenedUtc?.value||'',
                 icName:icName?.value||'',
                 bcName:bcName?.value||'',
                 semOpsName:semOpsName?.value||'',
                 severity:severity?.value||'',
                 detectMonitoring:!!detectMonitoring?.checked,
                 detectUserReport:!!detectUserReport?.checked,
                 detectAutomation:!!detectAutomation?.checked,
                 detectOther:!!detectOther?.checked,
                 evScreenshot:!!evScreenshot?.checked,
                 evLogs:!!evLogs?.checked,
                 evMetrics:!!evMetrics?.checked,
                 evRepro:!!evRepro?.checked,
                 evOther:!!evOther?.checked,
                 containStatus:getContainmentStatus(),
                 containDesc:containDesc?.value||'',
                 commNextUpdateTime:commNextUpdateTime?.value||'',
                 commCadence:commCadence||'',
                 commLog:commLog.slice(0,20),
                 commNextDueIso:commNextDueIso||''
               },
               table:[],
               causes: serializeCauses(),
               steps: exportStepsState() };
  [...tbody.querySelectorAll('tr')].forEach(tr=>{
    if(tr.classList.contains('band')){ data.table.push({band: tr.textContent.trim()}); return; }
    const t=tr.querySelectorAll('textarea');
    data.table.push({q: tr.querySelector('th').textContent.trim(), is:t[0].value, no:t[1].value, di:t[2].value, ch:t[3].value});
  });
  localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
}
function restoreFromStorage(){
  const raw = localStorage.getItem(STORAGE_KEY); if(!raw) return;
  const data = JSON.parse(raw);
  if(data.pre){
    oneLine.value=data.pre.oneLine||''; proof.value=data.pre.proof||'';
    objectPrefill.value=data.pre.objectPrefill||''; healthy.value=data.pre.healthy||'';
    now.value=data.pre.now||'';
    [oneLine,proof,objectPrefill,healthy,now].forEach(autoResize);
    if(objectPrefill.value && objectIS && !objectIS.value) { objectIS.value=objectPrefill.value; autoResize(objectIS); }
    if(now.value && deviationIS && !deviationIS.value) { deviationIS.value=now.value; autoResize(deviationIS); }
  }
  if(data.impact){
    impactNow.value=data.impact.now||''; impactFuture.value=data.impact.future||''; impactTime.value=data.impact.time||'';
    [impactNow,impactFuture,impactTime].forEach(autoResize);
  }
  if(data.ops){
    if(bridgeOpenedUtc){ bridgeOpenedUtc.value=data.ops.bridgeOpenedUtc||''; }
    if(icName){ icName.value=data.ops.icName||''; }
    if(bcName){ bcName.value=data.ops.bcName||''; }
    if(semOpsName){ semOpsName.value=data.ops.semOpsName||''; }
    if(severity){ severity.value=data.ops.severity||''; }
    if(detectMonitoring){ detectMonitoring.checked=!!data.ops.detectMonitoring; }
    if(detectUserReport){ detectUserReport.checked=!!data.ops.detectUserReport; }
    if(detectAutomation){ detectAutomation.checked=!!data.ops.detectAutomation; }
    if(detectOther){ detectOther.checked=!!data.ops.detectOther; }
    if(evScreenshot){ evScreenshot.checked=!!data.ops.evScreenshot; }
    if(evLogs){ evLogs.checked=!!data.ops.evLogs; }
    if(evMetrics){ evMetrics.checked=!!data.ops.evMetrics; }
    if(evRepro){ evRepro.checked=!!data.ops.evRepro; }
    if(evOther){ evOther.checked=!!data.ops.evOther; }
    if(containDesc){ containDesc.value=data.ops.containDesc||''; }
    if(typeof data.ops.containStatus==='string'){
      const status = data.ops.containStatus;
      if(containNone){ containNone.checked = status==='none'; }
      if(containMitigation){ containMitigation.checked = status==='mitigation'; }
      if(containRestore){ containRestore.checked = status==='restore'; }
    }
    if(commNextUpdateTime){ commNextUpdateTime.value=data.ops.commNextUpdateTime||''; }
    commCadence = typeof data.ops.commCadence==='string' ? data.ops.commCadence : commCadence;
    if(Array.isArray(data.ops.commLog)){
      commLog = data.ops.commLog.filter(entry=>entry && typeof entry.type==='string' && typeof entry.ts==='string');
    }
    commNextDueIso = typeof data.ops.commNextDueIso==='string' ? data.ops.commNextDueIso : commNextDueIso;
    dueToastShown = false;
    updateCadenceRadios();
    updateCommLogUI();
    if(commNextDueIso){
      const due = new Date(commNextDueIso);
      if(!Number.isNaN(due.valueOf())){
        const val = toTimeValue(due);
        if(val){
          if(commNextUpdateTime){ commNextUpdateTime.value = val; }
        }
      }
    }else if(commNextUpdateTime && commNextUpdateTime.value){
      applyManualDueValue(commNextUpdateTime.value);
    }else{
      updateCadenceState();
    }
  }
  if(Array.isArray(data.table)){
    let i=0;
    [...tbody.querySelectorAll('tr')].forEach(tr=>{
      if(tr.classList.contains('band')) return;
      const rec = data.table.find(d=>d.q===tr.querySelector('th').textContent.trim() && !d.band) || data.table[i++];
      if(!rec) return;
      const t = tr.querySelectorAll('textarea');
      t[0].value=rec.is||''; t[1].value=rec.no||''; t[2].value=rec.di||''; t[3].value=rec.ch||'';
      t.forEach(autoResize);
    });
  }
  if(Array.isArray(data.causes)){
    possibleCauses = deserializeCauses(data.causes);
  }else{
    possibleCauses = [];
  }
  ensurePossibleCausesUI();
  renderCauses();
  if(possibleCauses.some(cause=>cause && cause.editing)){
    focusFirstEditableCause();
  }
  updateCauseEvidencePreviews();
  scheduleCadenceTick();
  if(data.steps){
    importStepsState(data.steps);
  }
}
/* [script:storage] end */

/* [script:toast] start */
function showToast(msg){
  const toast = document.getElementById('toast');
  toast.textContent = msg;
  toast.className = 'toast show';
  setTimeout(()=>toast.classList.remove('show'), 2200);
}
/* [script:toast] end */
</script>
<!-- [script] end -->
</body>
</html>
