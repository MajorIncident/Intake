<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>KT Intake</title>

<!--
[contract] start
EDITING CONTRACT for ChatGPT & humans:
- Keep these anchors intact. Prefer unified diffs (*** Begin Patch / *** End Patch) that edit INSIDE the relevant anchors only.
- Do not remove tokens: {OBJECT} / {DEVIATION}.
- Keep function names/signatures for copy to ASCII intact.
- Avoid structural rewrites unless requested; keep single-file layout.
Anchors present:
  [styles] [vars] [header] [section:preface] [subtitle]
  [section:impact] [section:table]
  [script] [rows] [script:table-build] [script:preface-refs]
  [script:tokens] [script:init] [script:export] [script:storage] [script:toast]
[contract] end
-->

<!-- [styles] start -->
<style>
  /* [vars] start */
  :root{
    /* Apple-like daytime palette */
    --bg:#f5f7fb;
    --panel:#ffffff;
    --ink:#0c1220;
    --muted:#5b6475;
    --line:#e6eaf2;
    --band:#f6f8fc;
    --accent:#007aff;

    /* Layout */
    --qcol-w:10.5rem;     /* narrow KT Question column */
    --ta-fs:15px;         /* textarea font size */
    --ta-min-h:380px;     /* taller by default */
    --radius:14px;
    --shadow:0 8px 24px rgba(12,18,32,.08), 0 1px 0 rgba(255,255,255,.6) inset;
    --speed:.22s;
  }
  /* [vars] end */

  html,body{height:100%;}
  body{
    margin:0; background:var(--bg); color:var(--ink);
    font-family:"SF Pro Text","SF Pro Display",-apple-system,system-ui,"Segoe UI",Roboto,"Helvetica Neue",Arial,sans-serif;
    font-size:15px; line-height:1.6; letter-spacing:-0.01em;
  }
  header{
    max-width:1240px; margin:22px auto 8px; padding:0 12px;
    display:flex; gap:12px; align-items:center; justify-content:space-between;
  }
  h1#docTitle{font-size:22px; font-weight:800; margin:0; letter-spacing:-0.01em; white-space:pre-wrap;}
  .subtle{color:var(--muted); font-size:12px;}
  .btn{
    appearance:none; border:1px solid var(--line); background:var(--accent); color:#fff;
    padding:10px 14px; border-radius:12px; cursor:pointer; font-weight:600;
    transition:transform var(--speed), box-shadow var(--speed), border-color var(--speed);
    box-shadow:0 6px 18px rgba(0,122,255,.18);
  }
  .btn:hover{transform:translateY(-1px);}

  .wrap{max-width:1240px; margin:0 auto 40px; padding:0 12px;}
  h2#docSubtitle{margin:12px 0 8px; font-size:16px; font-weight:700; color:#2a3957; white-space:pre-wrap;}

  .card{
    background:var(--panel); border:1px solid var(--line); border-radius:var(--radius); box-shadow:var(--shadow);
    padding:20px 22px 24px; margin:0 0 32px;
  }
  .card h3{
    margin:0 0 16px;
    font-family:"SF Pro Display","SF Pro Text",-apple-system,system-ui,ui-sans-serif;
    font-size:15px; font-weight:700; letter-spacing:.32px; text-transform:uppercase; color:#1d2845;
  }
  .preface-stack{display:flex; flex-direction:column;}
  .grid{ display:grid; gap:12px; }
  .grid.cols-2{ grid-template-columns:1fr 1fr; }
  .grid.cols-3{ grid-template-columns:1fr 1fr 1fr; }
  .containment-grid .contain-status{ grid-column:span 2; }
  .containment-radios{ display:flex; flex-wrap:wrap; gap:12px; }
  .radio-option{ display:flex; align-items:center; gap:6px; }
  .comm-grid{ grid-template-columns:1fr 1fr auto; align-items:end; }
  .comm-grid .field{ margin:0; }
  .comm-grid .field label{ margin-bottom:4px; }
  .comm-grid.comm-grid--single{ grid-template-columns:1fr; }
  .comm-log-toggle{ margin-top:8px; align-self:flex-start; display:inline-flex; align-items:center; }
  .inline{ display:flex; align-items:center; gap:12px; flex-wrap:wrap; }
  .chipset{ display:flex; gap:8px; flex-wrap:wrap; }
  .chipset .chip{ position:relative; display:flex; align-items:center; gap:6px; }
  .chipset .chip label{ display:inline-flex; align-items:center; justify-content:center; padding:8px 12px; border-radius:999px; border:1px solid #dfe5f2; background:#f7f9ff; font-weight:600; font-size:13px; color:#1d2845; cursor:pointer; transition:border-color var(--speed), box-shadow var(--speed), background var(--speed); }
  .chipset .chip input[type="checkbox"]{ position:absolute; top:0; left:0; opacity:0; pointer-events:none; width:1px; height:1px; }
  .chipset .chip input[type="checkbox"]:focus + label{ border-color:var(--accent); box-shadow:0 0 0 3px rgba(0,122,255,.18); }
  .chipset .chip input[type="checkbox"]:checked + label{ border-color:var(--accent); background:rgba(0,122,255,.1); color:var(--accent); }
  .chip-label{ font-weight:700; color:#1d2845; min-width:150px; flex:0 0 auto; }
  .caption{ margin:-6px 0 16px; font-size:12px; color:var(--muted); }
  .gap-24{ gap:24px; }
  .field label{display:block; font-weight:700; margin-bottom:6px;}
  .field small{display:block; color:var(--muted); margin-top:4px;}
  fieldset.field{border:0; padding:0; margin:0;}
  fieldset.field legend{font-weight:700; margin-bottom:6px; font-size:14px; color:#1d2845;}
  .field textarea, .field input[type="text"]{
    width:100%; box-sizing:border-box;
    font:15px/1.55 ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
    color:var(--ink); background:#f9fbff;
    border:1px solid #dfe5f2; border-radius:12px; padding:12px 14px; outline:none;
    transition:border-color var(--speed), box-shadow var(--speed), background var(--speed);
  }
  .field textarea{min-height:140px; resize:vertical;}
  .field input[type="text"]{height:44px;}
  .field input[readonly]{background:#f4f6fb; color:#3b4962;}
  .field input[type="time"], .field select{
    width:100%; box-sizing:border-box; height:44px;
    font:15px/1.55 "SF Pro Text","SF Pro Display",-apple-system,system-ui,"Segoe UI",Roboto,"Helvetica Neue",Arial,sans-serif;
    color:var(--ink); background:#f9fbff;
    border:1px solid #dfe5f2; border-radius:12px; padding:8px 12px; outline:none;
    transition:border-color var(--speed), box-shadow var(--speed), background var(--speed);
  }
  .field input[type="time"]:focus, .field select:focus{border-color:var(--accent); box-shadow:0 0 0 4px rgba(0,122,255,.18); background:#fff;}
  .btn-mini{
    appearance:none; border:1px solid #dfe5f2; background:#eef3ff; color:var(--accent);
    padding:8px 12px; border-radius:10px; cursor:pointer; font-weight:600; font-size:13px;
    transition:transform var(--speed), box-shadow var(--speed), border-color var(--speed);
    box-shadow:0 4px 12px rgba(0,122,255,.12);
  }
  .btn-mini:hover{transform:translateY(-1px);}
  .btn-mini:focus{outline:none; border-color:var(--accent); box-shadow:0 0 0 4px rgba(0,122,255,.18);}
  .btn-mini.btn-ghost{
    background:#f7f9ff; color:#3b4962; border-color:#e2e7f3; box-shadow:none;
  }
  .btn-mini.btn-ghost:hover{background:#eef3ff;}
  .btn-mini.btn-danger{
    background:#ffeceb; color:#c0362c; border-color:#ffc3bb; box-shadow:0 4px 12px rgba(255,107,74,.12);
  }
  .btn-mini.btn-danger:hover{background:#ffdcd4;}
  .field textarea::placeholder, .field input::placeholder{color:#8b93a4;}
  .field textarea:focus, .field input:focus{border-color:var(--accent); box-shadow:0 0 0 4px rgba(0,122,255,.18); background:#fff;}

  .card.communication-due{ border-color:#ff9a8a; background:linear-gradient(180deg,#fff4f2 0%,#ffffff 35%); box-shadow:0 10px 28px rgba(255,107,74,.18); }
  .communication-due .countdown{ color:#d91f11; }

  .cadence-group{ display:flex; gap:8px; flex-wrap:wrap; }
  .cadence-option{ position:relative; }
  .cadence-option input[type="radio"]{ position:absolute; inset:0; opacity:0; }
  .cadence-option span{ display:inline-flex; align-items:center; justify-content:center; padding:8px 14px; border-radius:999px; border:1px solid #dfe5f2; background:#f7f9ff; font-weight:600; font-size:13px; color:#1d2845; cursor:pointer; transition:border-color var(--speed), box-shadow var(--speed), background var(--speed); }
  .cadence-option input[type="radio"]:focus + span{ border-color:var(--accent); box-shadow:0 0 0 3px rgba(0,122,255,.18); }
  .cadence-option input[type="radio"]:checked + span{ border-color:var(--accent); background:rgba(0,122,255,.1); color:var(--accent); }

  .comm-actions{ gap:10px; justify-content:flex-start; }
  .comm-actions .countdown{ font-weight:600; color:#2a3957; min-width:96px; }

  .comm-alert{ margin-top:10px; padding:10px 12px; border-radius:12px; background:#fff2f0; border:1px solid #ffd0c7; color:#b71c1c; font-weight:600; display:flex; align-items:center; gap:8px; }

  .comm-log{ list-style:none; padding:0; margin:12px 0 0; display:flex; flex-direction:column; gap:8px; }
  .comm-log li{ display:flex; justify-content:space-between; align-items:center; gap:12px; padding:10px 12px; border-radius:12px; background:#f7f9ff; border:1px solid #e2e7f3; font-size:13px; }
  .comm-log__type{ font-weight:700; text-transform:uppercase; letter-spacing:.04em; color:#1d2845; }
  .comm-log__time{ font-variant-numeric:tabular-nums; color:#2a3957; }
  .comm-log__empty{ justify-content:flex-start; color:#7a8398; font-style:italic; }

  /* Impact strip */
  .impact{ padding:18px; }
  .impact > h3{
    margin:0 0 18px;
    font-size:17px;
    font-weight:700;
    letter-spacing:-0.02em;
    color:#1f2b40;
    font-family:"SF Pro Display","SF Pro Text",-apple-system,system-ui,"Segoe UI",Roboto,"Helvetica Neue",Arial,sans-serif;
  }
  .impact .field{padding:4px 0;}
  .impact .field h3{
    margin:0 0 6px;
    font-size:15px;
    font-weight:600;
    letter-spacing:-0.015em;
    color:#22324b;
    font-family:"SF Pro Display","SF Pro Text",-apple-system,system-ui,"Segoe UI",Roboto,"Helvetica Neue",Arial,sans-serif;
  }
  .impact .field label{
    font-size:13px;
    font-weight:600;
    letter-spacing:-0.01em;
    color:#3b4962;
    margin-bottom:8px;
  }
  .impact .field small{
    font-size:12px;
    line-height:1.55;
    letter-spacing:0;
  }
  .impact textarea{
    font-family:"SF Pro Text","SF Pro Display",-apple-system,system-ui,"Segoe UI",Roboto,"Helvetica Neue",Arial,sans-serif;
    font-size:14px;
    line-height:1.6;
    letter-spacing:-0.01em;
  }

  /* Table */
  table{
    table-layout:fixed;
    
    width:100%; border-collapse:separate; border-spacing:0; overflow:hidden; border-radius:var(--radius);
    background:var(--panel); border:1px solid var(--line); box-shadow:var(--shadow);
  }
  thead th{
    word-wrap:break-word;
    white-space:normal;
    
    position:sticky; top:0; z-index:3;
    background:linear-gradient(180deg, #ffffff, #fafbfe);
    color:#0c1220; text-align:left; font-size:12px; letter-spacing:.4px;
    padding:12px; border-bottom:1px solid var(--line);
  }
  tbody td, tbody th{
    border-bottom:1px solid var(--line); vertical-align:top; padding:10px 8px; transition:background-color var(--speed);
  }
  tbody tr:last-child td, tbody tr:last-child th{border-bottom:0;}
  tbody tr:hover td, tbody tr:hover th{background-color:#fafbfe;}
  tbody th{
    width:var(--qcol-w); max-width:var(--qcol-w); min-width:var(--qcol-w);
    white-space:normal; word-break:break-word; font-weight:700; color:#0c1220;
  }
  .cause-list{display:flex; flex-direction:column; gap:16px; margin-top:12px; margin-bottom:18px;}
  .cause-empty{padding:18px; border:1px dashed #dfe5f2; border-radius:12px; background:#f9fbff; color:#5b6475; font-style:italic;}
  .cause-card{
    border:1px solid #e2e7f3; border-radius:14px; background:linear-gradient(180deg,#ffffff 0%,#f8faff 100%);
    padding:18px 20px; display:flex; flex-direction:column; gap:12px; position:relative;
  }
  .cause-card[data-editing="true"]{border-color:var(--accent); box-shadow:0 0 0 4px rgba(0,122,255,.12);}
  .cause-card[data-failed="true"]{border-color:#ffb3a9; box-shadow:0 0 0 4px rgba(255,107,74,.16);}
  .cause-card__header{display:flex; justify-content:space-between; align-items:flex-start; gap:12px;}
  .cause-card__meta{display:flex; flex-direction:column; gap:4px;}
  .cause-card__title{font-weight:700; font-size:14px; color:#1d2845; letter-spacing:.02em;}
  .cause-card__status{font-size:12px; color:var(--muted); letter-spacing:.02em;}
  .cause-card__indicators{display:flex; flex-direction:column; align-items:flex-end; gap:6px;}
  .cause-card__chip{display:inline-flex; align-items:center; justify-content:center; padding:6px 12px; border-radius:999px; font-weight:600; font-size:12px; letter-spacing:.03em; text-transform:uppercase; border:1px solid transparent; background:#f2f4fb; color:#3b4962;}
  .cause-card__chip[data-status="not-tested"]{background:#f2f4fb; color:#3b4962; border-color:#dfe5f2;}
  .cause-card__chip[data-status="testing"]{background:#fff6e6; color:#7b4b00; border-color:#f3d2a2;}
  .cause-card__chip[data-status="explained"]{background:#e6f9ef; color:#0f5b2f; border-color:#b8e8cd;}
  .cause-card__chip[data-status="failed"]{background:#ffe8e6; color:#b71c1c; border-color:#ffb3a9;}
  .cause-card__chip[data-status="draft"]{background:#f5f7fb; color:#6b768a; border-color:#e2e7f3;}
  .cause-card__chip[data-status="no-evidence"]{background:#eef3ff; color:#1d2845; border-color:#d5def5;}
  .cause-card__failure{display:inline-flex; align-items:center; gap:6px; padding:4px 10px; border-radius:999px; font-weight:600; font-size:12px; letter-spacing:.02em; background:#ffe8e6; color:#b71c1c; border:1px solid #ffb3a9;}
  .cause-card__failure::before{content:'✕'; font-size:13px; line-height:1;}
  .cause-card__assumptions{display:inline-flex; align-items:center; gap:6px; padding:4px 10px; border-radius:999px; font-weight:600; font-size:12px; letter-spacing:.02em; background:#f1f4ff; color:#1d2845; border:1px solid #d5def5;}
  .cause-card__assumptions::before{content:'∑'; font-size:13px; line-height:1; color:#3b4d7a;}
  .cause-card__summary{margin:0; font-size:14px; line-height:1.6; color:#1f2b40;}
  .cause-card__helper{margin-top:-6px;}
  .cause-card__form{display:grid; gap:14px;}
  .cause-card__form .field textarea{min-height:120px;}
  .cause-controls{display:flex; gap:8px; flex-wrap:wrap; margin-top:4px;}
  .cause-test{border-top:1px solid #e2e7f3; padding-top:14px; display:flex; flex-direction:column; gap:12px;}
  .cause-test__intro{margin:0; font-size:13px; color:#3b4962;}
  .cause-eval-row{border:1px solid #e3e8f5; border-radius:12px; background:#f9fbff; padding:14px; display:flex; flex-direction:column; gap:12px;}
  .cause-eval-question-text{font-weight:600; font-size:13px; color:#1f2b40;}
  .cause-evidence-wrap{display:grid; gap:10px; grid-template-columns:repeat(auto-fit, minmax(180px,1fr));}
  .cause-evidence-block{display:flex; flex-direction:column; gap:4px; padding:10px; border-radius:10px; background:#ffffff; border:1px solid #e6ebf5;}
  .cause-evidence-label{font-size:11px; text-transform:uppercase; letter-spacing:.08em; color:#7a8398; font-weight:700;}
  .cause-evidence-text{font-size:13px; line-height:1.5; color:#22324b; white-space:pre-line;}
  .cause-eval-inputs{display:flex; flex-direction:column; gap:12px;}
  .cause-eval-options{display:flex; flex-wrap:wrap; gap:8px;}
  .cause-eval-option{appearance:none; border:1px solid #dfe5f2; background:#ffffff; color:#1d2845; font-weight:600; font-size:13px; padding:8px 14px; border-radius:999px; cursor:pointer; transition:background var(--speed), border-color var(--speed), color var(--speed), box-shadow var(--speed);}
  .cause-eval-option:hover{border-color:var(--accent);}
  .cause-eval-option:focus{outline:none; border-color:var(--accent); box-shadow:0 0 0 4px rgba(0,122,255,.18);}
  .cause-eval-option.is-selected{background:rgba(0,122,255,.12); border-color:var(--accent); color:var(--accent); box-shadow:0 6px 16px rgba(0,122,255,.12);}
  .cause-eval-note{display:flex; flex-direction:column; gap:6px;}
  .cause-eval-note[hidden]{display:none;}
  .cause-eval-inputs .field textarea{min-height:120px;}
  @media (max-width:720px){
    .cause-card{padding:16px;}
  }
  .band th{
    padding:12px; font-weight:800; color:#2a3957;
    background:linear-gradient(180deg, var(--band), #ffffff);
    border-top:1px solid var(--line); border-bottom:1px solid var(--line);
  }
  .band th span{opacity:.85; font-weight:600; color:#6b768a}
  textarea.tableta{
    width:100%; min-height:var(--ta-min-h); resize:vertical; box-sizing:border-box;
    font:var(--ta-fs)/1.55 ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
    color:var(--ink); background:#f9fbff;
    border:1px solid #dfe5f2; border-radius:12px; padding:12px 14px; outline:none;
    transition:border-color var(--speed), box-shadow var(--speed), background var(--speed);
  }
  textarea.tableta::placeholder{color:#8b93a4;}
  textarea.tableta:focus{border-color:var(--accent); box-shadow:0 0 0 4px rgba(0,122,255,.18); background:#ffffff;}

  /* Toast */
  .toast{
    position:fixed; right:18px; bottom:18px; background:#0f1a10; color:#dff5e1; border:1px solid #164f19;
    padding:10px 12px; border-radius:12px; opacity:0; transform:translateY(10px); transition:.25s; pointer-events:none; box-shadow:var(--shadow);
  }
  .toast.show{opacity:1; transform:translateY(0);}
</style>
<!-- [styles] end -->
</head>
<body>
  <!-- [header] start -->
  <header>
    <h1 id="docTitle">KT Intake</h1>
    <button class="btn" id="genSummaryBtn" onclick="onGenerateSummary()">Generate Summary</button>
  </header>
  <!-- [header] end -->

  <div class="wrap">
    <!-- [section:preface] start -->
    <section class="preface-stack">
      <div class="card">
        <h3>Bridge Activation</h3>
        <p class="caption">Capture only what’s needed to activate the bridge and set comms cadence.</p>
        <div class="grid cols-3">
          <div class="field">
            <label for="bridgeOpenedUtc">Bridge opened (UTC)</label>
            <div class="inline">
              <input type="text" id="bridgeOpenedUtc" readonly aria-readonly="true" />
              <button type="button" class="btn-mini" id="bridgeSetNowBtn" aria-label="Stamp bridge opened time">Set Now</button>
            </div>
          </div>
          <div class="field">
            <label for="icName">Incident Commander</label>
            <input type="text" id="icName" placeholder="" />
          </div>
          <div class="field">
            <label for="bcName">Bridge Coordinator</label>
            <input type="text" id="bcName" placeholder="" />
          </div>
        </div>
        <div class="grid cols-3">
          <div class="field">
            <label for="semOpsName">SEM/Ops Lead</label>
            <input type="text" id="semOpsName" placeholder="" />
          </div>
          <div class="field">
            <label for="severity">Severity</label>
            <select id="severity">
              <option value="">Select severity</option>
              <option value="S1">S1</option>
              <option value="S2">S2</option>
              <option value="S3">S3</option>
            </select>
          </div>
        </div>
      </div>

      <div class="card">
        <h3>Problem Summary</h3>
        <div class="grid">
          <div class="field">
            <label for="oneLine">In one sentence, what is broken for you right now?</label>
            <textarea id="oneLine" placeholder=""></textarea>
          </div>
        </div>
      </div>

      <div class="card">
        <h3>Evidence &amp; Object</h3>
        <div class="inline">
          <span class="chip-label">Detection Source</span>
          <div class="chipset" role="group" aria-label="Detection Source">
            <div class="chip">
              <input type="checkbox" id="detectMonitoring" />
              <label for="detectMonitoring">Monitoring</label>
            </div>
            <div class="chip">
              <input type="checkbox" id="detectUserReport" />
              <label for="detectUserReport">User Report</label>
            </div>
            <div class="chip">
              <input type="checkbox" id="detectAutomation" />
              <label for="detectAutomation">Automation</label>
            </div>
            <div class="chip">
              <input type="checkbox" id="detectOther" />
              <label for="detectOther">Other</label>
            </div>
          </div>
        </div>
        <div class="inline">
          <span class="chip-label">Evidence Collected</span>
          <div class="chipset" role="group" aria-label="Evidence Collected">
            <div class="chip">
              <input type="checkbox" id="evScreenshot" />
              <label for="evScreenshot">Screenshot</label>
            </div>
            <div class="chip">
              <input type="checkbox" id="evLogs" />
              <label for="evLogs">Logs</label>
            </div>
            <div class="chip">
              <input type="checkbox" id="evMetrics" />
              <label for="evMetrics">Metrics</label>
            </div>
            <div class="chip">
              <input type="checkbox" id="evRepro" />
              <label for="evRepro">Repro</label>
            </div>
            <div class="chip">
              <input type="checkbox" id="evOther" />
              <label for="evOther">Other</label>
            </div>
          </div>
        </div>
        <div class="grid cols-2">
          <div class="field">
            <label for="proof">What proves a deviation exists?</label>
            <small>Examples: alerts, error messages, metric spikes/drops, log lines, screenshots, reproducible steps.</small>
            <textarea id="proof" placeholder=""></textarea>
          </div>
          <div class="field">
            <label for="objectPrefill">What is the specific object being affected?</label>
            <small>Hardware name and model, Function/Module/Method, Container/Service/API, datastore/volume/bucket/table, network element, identity/policy/role, pipeline/job.</small>
            <textarea id="objectPrefill" placeholder=""></textarea>
          </div>
        </div>
      </div>

      <div class="card">
        <h3>Baseline vs Current</h3>
        <div class="grid cols-2">
          <div class="field">
            <label id="labelHealthy" for="healthy">What does healthy look like here?</label>
            <small>What was the expected behavior?</small>
            <textarea id="healthy" placeholder=""></textarea>
          </div>
          <div class="field">
            <label id="labelNow" for="now">What is happening now?</label>
            <small>What has been verified and measured vs same baseline (same metrics as above)? What symptom is being presented?</small>
            <textarea id="now" placeholder=""></textarea>
          </div>
        </div>
      </div>
    </section>
    <!-- [section:preface] end -->

    <!-- [subtitle] start -->
    <h2 id="docSubtitle">Describe The Problem</h2>
    <!-- [subtitle] end -->

    <!-- [section:impact] start -->
    <div class="card impact">
      <h3>Impact</h3>
      <div class="grid cols-3 containment-grid">
        <fieldset class="field contain-status">
          <legend>Containment Status</legend>
          <div class="containment-radios" role="radiogroup" aria-label="Containment Status">
            <div class="radio-option">
              <input type="radio" id="containNone" name="containStatus" value="none" />
              <label for="containNone">No action yet</label>
            </div>
            <div class="radio-option">
              <input type="radio" id="containMitigation" name="containStatus" value="mitigation" />
              <label for="containMitigation">Temporary mitigation applied</label>
            </div>
            <div class="radio-option">
              <input type="radio" id="containRestore" name="containStatus" value="restore" />
              <label for="containRestore">Full restoration in progress</label>
            </div>
          </div>
        </fieldset>
        <div class="field">
          <label for="containDesc">Containment Description</label>
          <input type="text" id="containDesc" placeholder="What immediate step reduces risk?" />
        </div>
      </div>
      <div class="grid cols-3 gap-24">
        <div class="field">
          <h3>Current Impact</h3>
          <label for="impactNow">Current Impact</label>
          <small>Who/what is affected now? Quantify: users/tenants/regions, transactions failing, SLI/SLO deltas (avail %, p95/p99, error %), data at risk (loss/corruption/exposure), workarounds.</small>
          <textarea id="impactNow" placeholder=""></textarea>
        </div>
        <div class="field">
          <h3>Future Impact</h3>
          <label for="impactFuture">Future Impact</label>
          <small>If unresolved what happens? Blast radius growth, SLO/SLA breach, revenue/penalties, compliance, backlog/consumer lag, churn, on-call fatigue.</small>
          <textarea id="impactFuture" placeholder=""></textarea>
        </div>
        <div class="field">
          <h3>Timeframe</h3>
          <label for="impactTime">Timeframe</label>
          <small>When will the Future Impact become Current Impact? (Best Estimate). What deadlines/SLAs do we need to be aware of?</small>
          <textarea id="impactTime" placeholder=""></textarea>
        </div>
      </div>
    </div>
    <!-- [section:impact] end -->

    <div class="card" id="commControlsCard">
      <h3>Communication Cadence &amp; Log</h3>
      <fieldset class="field">
        <legend id="commCadenceLegend">Communication cadence</legend>
        <div class="cadence-group" id="commCadenceGroup" role="radiogroup" aria-labelledby="commCadenceLegend">
          <label class="cadence-option">
            <input type="radio" name="commCadence" value="10" />
            <span>10 min</span>
          </label>
          <label class="cadence-option">
            <input type="radio" name="commCadence" value="15" />
            <span>15 min</span>
          </label>
          <label class="cadence-option">
            <input type="radio" name="commCadence" value="20" />
            <span>20 min</span>
          </label>
          <label class="cadence-option">
            <input type="radio" name="commCadence" value="30" />
            <span>30 min</span>
          </label>
          <label class="cadence-option">
            <input type="radio" name="commCadence" value="60" />
            <span>Hourly</span>
          </label>
        </div>
        <small>Pick how often updates should be broadcast. Logging a communication restarts the timer and reminder.</small>
      </fieldset>
      <div class="inline comm-actions">
        <button type="button" class="btn-mini" id="commInternalStampBtn" aria-label="Log internal communication">Log internal update</button>
        <button type="button" class="btn-mini" id="commExternalStampBtn" aria-label="Log external communication">Log external update</button>
        <span class="countdown" id="commCountdown" aria-live="polite"></span>
      </div>
      <div class="comm-alert" id="commDueAlert" role="alert" hidden></div>
      <div class="grid comm-grid comm-grid--single">
        <div class="field">
          <label for="commNextUpdateTime">Next update scheduled for</label>
          <input type="time" id="commNextUpdateTime" />
        </div>
      </div>
      <div class="field">
        <label for="commLogList">Communication log</label>
        <ul id="commLogList" class="comm-log" aria-live="polite" aria-label="Communication log"></ul>
        <button type="button" class="btn-mini comm-log-toggle" id="commLogToggleBtn" hidden aria-expanded="false">Show all</button>
      </div>
    </div>

    <!-- [section:table] start -->
    <p class="subtle">Problem Analysis</p>

    <table id="ktTable" aria-label="KT IS / IS NOT intake table">
<colgroup>
  <col style="width:18%;">
  <col style="width:21%;">
  <col style="width:21%;">
  <col style="width:20%;">
  <col style="width:20%;">
</colgroup>

      <thead>
        <tr>
          <th scope="col">KT Question</th>
          <th scope="col">IS <span class="subtle">— facts only</span></th>
          <th scope="col">IS NOT <span class="subtle">— similar &amp; reasonable and could be but is not occuring</span></th>
          <th scope="col">Distinctions <span class="subtle">— Unique characteristics about the IS</span></th>
          <th scope="col">Changes <span class="subtle">— Changes that happened in on around or about each Distinction</span></th>
        </tr>
      </thead>
      <tbody id="tbody"></tbody>
    </table>
    <!-- [section:table] end -->


    <div class="card" id="possibleCausesCard">
      <h3>Possible Causes</h3>
      <p class="caption">Capture hypotheses and pressure test them against the KT IS / IS NOT evidence. Start with the suspect, accusation, and impact; then walk each cause through the table.</p>
      <div id="causeList" class="cause-list" aria-live="polite"></div>
      <div class="cause-controls">
        <button type="button" class="btn-mini" id="addCauseBtn">Add Possible Cause</button>
      </div>
    </div>


    <!-- [section:summary] start -->
    <div class="card" id="summaryCard" style="display:none;">
      <h3>Copy &amp; Paste Summary</h3>
      <pre id="summaryPre" style="white-space:pre-wrap;font:13px/1.6 monospace;margin:0;"></pre>
    </div>
    <!-- [section:summary] end -->

  </div>

  <div id="toast" class="toast" role="status" aria-live="polite"></div>

<!-- [script] start -->
<script>
/* [rows] start */
/* =================== Core data & prompts (KT Problem Analysis) =================== */
/* Use {OBJECT} / {DEVIATION} tokens anywhere you want auto-fill. */
const ROWS = [
  { band: "WHAT", note: "Define the problem precisely (Object & Deviation)." },

  {
    q: "WHAT — Specific Object/Thing is having the {DEVIATION}",
    isPH:
      "What specific object has {DEVIATION}?",
    notPH:
      "What similar objects could reasonably have, but do NOT have {DEVIATION}?"
  },
  {
    q: "WHAT — Specific Deviation does the {OBJECT} have?",
    isPH:
      "What exactly is the deviation that has been confirmed?",
    notPH:
      "What reasonable symptoms could the {OBJECT} have had, but we have verified are NOT present?"
  },

  { band: "WHERE", note: "Locate the problem (geography/topology and on the object)." },

  {
    q: "WHERE — is the {OBJECT} geographically/topology when the {DEVIATION} occurs?",
    isPH:
      "Where is {OBJECT} when {DEVIATION} occurs?",
    notPH:
      "Where would you reasonably expect the {OBJECT} could have been when the {DEVIATION} was observed but we do NOT see it?"
  },
  {
    q: "WHERE — On the {OBJECT} is the {DEVIATION} observed?",
    isPH:
      "Where on {OBJECT} is {DEVIATION} observed?",
    notPH:
      "What neighboring parts on the {OBJECT} do NOT show {DEVIATION}?"
  },

  { band: "WHEN", note: "Timing and Description" },

  {
    q: "WHEN — Was the {DEVIATION} First observed for {OBJECT}",
    isPH:
      "When was {DEVIATION} first observed for {OBJECT}? (date/time/zone)",
    notPH:
      "When was the last known good for {OBJECT}? When reasonably could we have observed other {DEVIATION} on {OBJECT} but we did not?"
  },
  {
    q: "WHEN — Since was the first time has {DEVIATION} been logged? What Pattern?",
    isPH:
      "Since first occurrence, when does {DEVIATION} re-occur?\n• What Pattern (continuous/periodic/sporadic/one time)",
    notPH:
      "What Similar windows/patterns of times is the {OBJECT} not having {DEVIATION}?"
  },
  {
    q: "WHEN — Describe using words When the {DEVIATION} was first seen",
    isPH:
      "At what point in {OBJECT}’s life-cycle did {DEVIATION} appear?\n• Use words like before, during, or after to describe these times and consider multiple lifecycles",
    notPH:
      "What Adjacent life-cycle moments could we have reasonably caught or observed the {DEVIATION} but we did not?"
  },

  { band: "EXTENT", note: "How big is it? Magnitude, count, scope, trend." },

  {
    q: "EXTENT — What is the population or size of {OBJECT} affected?",
    isPH:
      "How many {OBJECT}s have {DEVIATION}?\nTrend (↑/↓/stable)?",
    notPH:
      "What population or Comparable object sets have not been affected"
  },
  {
    q: "EXTENT — What is the size of a single {DEVIATION}?",
    isPH:
      "How big is a single {DEVIATION} on {OBJECT}?\nTrend (↑/↓/stable)?",
    notPH:
      "What sizes could the {DEVIATION} reasonably have been but were not?"
  },
  {
    q: "EXTENT — How many {DEVIATION} are occuring on each {OBJECT}?",
    isPH:
      "How many instances of {DEVIATION} per {OBJECT}?\nTrend (↑/↓/stable)?",
    notPH:
      "Reasonably, how many instances of {DEVIATION} could have occured per {OBJECT} but did not?"
  },
];

/* [rows] end */

/* [script:table-build] start */
/* =================== Build table & dynamic tokens =================== */
const tbody = document.getElementById('tbody');
const rowsBuilt = [];
let possibleCauses = [];
let objectIS = null;     // first WHAT → IS
let deviationIS = null;  // second WHAT → IS
let objectISDirty = false;
let deviationISDirty = false;

function mkBand(title, note){
  const tr = document.createElement('tr'); tr.className='band';
  const th = document.createElement('th'); th.colSpan = 5; th.innerHTML = `${title} <span>— ${note}</span>`;
  tr.appendChild(th); return tr;
}
function mkRow(def, i){
  const tr = document.createElement('tr'); tr.dataset.row = i;
  const th = document.createElement('th'); th.scope='row'; th.textContent = fillTokens(def.q);

  const tdIS = document.createElement('td');
  const tdNOT = document.createElement('td');
  const tdDIST = document.createElement('td');
  const tdCHG = document.createElement('td');

  const isTA  = document.createElement('textarea'); isTA.className='tableta';
  const notTA = document.createElement('textarea'); notTA.className='tableta';
  const distTA= document.createElement('textarea'); distTA.className='tableta';
  const chgTA = document.createElement('textarea'); chgTA.className='tableta';

  isTA.placeholder   = fillTokens(def.isPH || "");
  notTA.placeholder  = mkIsNotPH(fillTokens(def.notPH || ""), "");
  distTA.placeholder = mkDistPH("", "");
  chgTA.placeholder  = mkChangePH("");

  const refreshIsNotPH = ()=> notTA.placeholder = mkIsNotPH(fillTokens(def.notPH||""), isTA.value);
  const refreshDistPH  = ()=> distTA.placeholder = mkDistPH(isTA.value, notTA.value);
  const refreshChgPH   = ()=> chgTA.placeholder  = mkChangePH(distTA.value);

  [isTA,notTA,distTA,chgTA].forEach(t=>{
    autoResize(t);
    t.addEventListener('input', ()=>{
      autoResize(t);
      if(t===isTA){
        refreshIsNotPH();
        refreshDistPH();
      }else if(t===notTA){
        refreshDistPH();
      }else if(t===distTA){
        refreshChgPH();
      }
      saveToStorage();
      if(t===isTA || t===notTA){
        renderCauses();
      }else{
        updateCauseEvidencePreviews();
      }
    });
  });

  tdIS.appendChild(isTA); tdNOT.appendChild(notTA); tdDIST.appendChild(distTA); tdCHG.appendChild(chgTA);
  tr.append(th, tdIS, tdNOT, tdDIST, tdCHG);

  rowsBuilt.push({tr, th, def, isTA, notTA, distTA, chgTA});
  return tr;
}
function initTable(){
  let dataRowCount = 0;
  ROWS.forEach((def)=>{
    if(def.band){ tbody.appendChild(mkBand(def.band, def.note||'')); }
    else{
      const tr = mkRow(def, ++dataRowCount);
      tbody.appendChild(tr);
      if(dataRowCount===1) objectIS   = rowsBuilt[rowsBuilt.length-1].isTA;  // first data row IS
      if(dataRowCount===2) deviationIS= rowsBuilt[rowsBuilt.length-1].isTA;  // second data row IS
    }
  });

  [objectIS, deviationIS].forEach(el=>{
    el.addEventListener('input', ()=>{
      if(el===objectIS) objectISDirty = true;
      if(el===deviationIS) deviationISDirty = true;
      refreshAllTokenizedText();
      updateTitlesAndLabels();
      saveToStorage();
    });
  });
}
/* [script:table-build] end */

/* [script:preface-refs] start */
/* =================== Preface helpers & H1/H2 =================== */
const oneLine = document.getElementById('oneLine');
const proof = document.getElementById('proof');
const objectPrefill = document.getElementById('objectPrefill');
const healthy = document.getElementById('healthy');
const now = document.getElementById('now');

const bridgeOpenedUtc = document.getElementById('bridgeOpenedUtc');
const bridgeSetNowBtn = document.getElementById('bridgeSetNowBtn');
const icName = document.getElementById('icName');
const bcName = document.getElementById('bcName');
const semOpsName = document.getElementById('semOpsName');
const severity = document.getElementById('severity');

const detectMonitoring = document.getElementById('detectMonitoring');
const detectUserReport = document.getElementById('detectUserReport');
const detectAutomation = document.getElementById('detectAutomation');
const detectOther = document.getElementById('detectOther');

const evScreenshot = document.getElementById('evScreenshot');
const evLogs = document.getElementById('evLogs');
const evMetrics = document.getElementById('evMetrics');
const evRepro = document.getElementById('evRepro');
const evOther = document.getElementById('evOther');

const labelHealthy = document.getElementById('labelHealthy');
const labelNow = document.getElementById('labelNow');

const docTitle = document.getElementById('docTitle');
const docSubtitle = document.getElementById('docSubtitle');

const impactNow = document.getElementById('impactNow');
const impactFuture = document.getElementById('impactFuture');
const impactTime = document.getElementById('impactTime');

const containNone = document.getElementById('containNone');
const containMitigation = document.getElementById('containMitigation');
const containRestore = document.getElementById('containRestore');
const containDesc = document.getElementById('containDesc');

const commInternalStampBtn = document.getElementById('commInternalStampBtn');
const commExternalStampBtn = document.getElementById('commExternalStampBtn');
const commNextUpdateTime = document.getElementById('commNextUpdateTime');
const commControlsCard = document.getElementById('commControlsCard');
const commCadenceGroup = document.getElementById('commCadenceGroup');
const commCadenceRadios = commCadenceGroup ? [...commCadenceGroup.querySelectorAll('input[name="commCadence"]')] : [];
const commCountdown = document.getElementById('commCountdown');
const commDueAlert = document.getElementById('commDueAlert');
const commLogList = document.getElementById('commLogList');
const commLogToggleBtn = document.getElementById('commLogToggleBtn');
let causeList = document.getElementById('causeList');
let addCauseBtn = document.getElementById('addCauseBtn');

let commLog = [];
let commCadence = '';
let commNextDueIso = '';
let cadenceTimerId = null;
let dueToastShown = false;
let commShowAll = false;

[oneLine, proof, objectPrefill, healthy, now].forEach(el=>{
  el.addEventListener('input', ()=>{
    // If the table fields are empty, seed them from preface
    if(el===objectPrefill && objectIS && !objectIS.value.trim()){
      objectIS.value = el.value.trim(); autoResize(objectIS);
      refreshAllTokenizedText();
    }
    if(el===now && deviationIS && !deviationIS.value.trim()){
      deviationIS.value = el.value.trim(); autoResize(deviationIS);
      refreshAllTokenizedText();
    }
    if(el===oneLine && deviationIS && !deviationIS.value.trim()){
      deviationIS.value = el.value.trim(); autoResize(deviationIS);
      refreshAllTokenizedText();
    }
    updateTitlesAndLabels();
    saveToStorage();
  });
  el.addEventListener('keyup', syncMirror);
  el.addEventListener('change', ()=>syncMirror(true));
});

[icName, bcName, semOpsName].forEach(el=>{
  if(el){ el.addEventListener('input', saveToStorage); }
});
[severity].forEach(el=>{
  if(el){ el.addEventListener('change', saveToStorage); }
});

if(commNextUpdateTime){
  commNextUpdateTime.addEventListener('change', ()=>{
    applyManualDueValue(commNextUpdateTime.value);
    saveToStorage();
  });
}

if(commCadenceRadios.length){
  commCadenceRadios.forEach(radio=>{
    radio.addEventListener('change', ()=>{
      if(!radio.checked) return;
      commCadence = radio.value;
      dueToastShown = false;
      if(commLog.length){
        const lastIso = commLog[0]?.ts;
        if(lastIso){
          const base = new Date(lastIso);
          if(!Number.isNaN(base.valueOf())){
            const mins = getCadenceMinutes();
            if(mins){
              base.setMinutes(base.getMinutes() + mins);
              setNextDue(base);
            }
          }
        }
      }
      scheduleCadenceTick();
      saveToStorage();
    });
  });
}

[
  detectMonitoring,
  detectUserReport,
  detectAutomation,
  detectOther,
  evScreenshot,
  evLogs,
  evMetrics,
  evRepro,
  evOther,
  containNone,
  containMitigation,
  containRestore
].forEach(el=>{ if(el){ el.addEventListener('change', saveToStorage); } });

if(containDesc){ containDesc.addEventListener('input', saveToStorage); }

if(bridgeSetNowBtn){
  bridgeSetNowBtn.addEventListener('click', ()=>{
    bridgeOpenedUtc.value = new Date().toISOString();
    saveToStorage();
    bridgeOpenedUtc.focus();
  });
}

if(commInternalStampBtn){
  commInternalStampBtn.addEventListener('click', ()=>logCommunication('internal'));
}

if(commExternalStampBtn){
  commExternalStampBtn.addEventListener('click', ()=>logCommunication('external'));
}

if(commLogToggleBtn){
  commLogToggleBtn.addEventListener('click', ()=>{
    commShowAll = !commShowAll;
    updateCommLogUI();
  });
}

updateCommLogUI();
scheduleCadenceTick();
/* [script:preface-refs] end */

function getCadenceMinutes(){
  const mins = parseInt(commCadence, 10);
  return Number.isFinite(mins) ? mins : null;
}

function updateCadenceRadios(){
  if(!commCadenceRadios.length) return;
  commCadenceRadios.forEach(radio=>{
    radio.checked = radio.value === commCadence;
  });
}

function toTimeValue(date){
  if(!(date instanceof Date) || Number.isNaN(date.valueOf())) return '';
  const h = String(date.getHours()).padStart(2,'0');
  const m = String(date.getMinutes()).padStart(2,'0');
  return `${h}:${m}`;
}

function isoFromTimeValue(value){
  if(!value) return '';
  const parts = value.split(':');
  if(parts.length < 2) return '';
  const [hh, mm] = parts.map(Number);
  if(Number.isNaN(hh) || Number.isNaN(mm)) return '';
  const now = new Date();
  const candidate = new Date(now);
  candidate.setHours(hh, mm, 0, 0);
  if(candidate.getTime() <= now.getTime()){
    candidate.setDate(candidate.getDate() + 1);
  }
  return candidate.toISOString();
}

function toggleCommDue(isDue){
  if(commControlsCard){
    commControlsCard.classList.toggle('communication-due', !!isDue);
  }
  if(commDueAlert){
    if(isDue){
      commDueAlert.textContent = 'Next communication is due now. Reconfirm updates.';
      commDueAlert.hidden = false;
    }else{
      commDueAlert.textContent = '';
      commDueAlert.hidden = true;
    }
  }
}

function formatCountdown(ms){
  const totalSeconds = Math.max(0, Math.round(ms/1000));
  const mins = Math.floor(totalSeconds/60);
  const secs = totalSeconds % 60;
  if(mins >= 60){
    const hours = Math.floor(mins/60);
    const rem = mins % 60;
    return `${hours}h ${rem}m`;
  }
  if(mins > 0){
    return `${mins}m ${String(secs).padStart(2,'0')}s`;
  }
  return `${secs}s`;
}

function updateCommLogUI(){
  if(!commLogList) return;
  commLogList.innerHTML = '';
  if(!commLog.length){
    const li = document.createElement('li');
    li.className = 'comm-log__empty';
    li.textContent = 'No communications logged yet.';
    commLogList.appendChild(li);
    if(commLogToggleBtn){
      commLogToggleBtn.hidden = true;
      commLogToggleBtn.setAttribute('aria-expanded', 'false');
    }
    return;
  }
  const limit = 6;
  const entries = commShowAll ? commLog : commLog.slice(0, limit);
  entries.forEach(entry=>{
    const li = document.createElement('li');
    const typeSpan = document.createElement('span');
    typeSpan.className = 'comm-log__type';
    typeSpan.textContent = entry.type === 'external' ? 'External' : 'Internal';
    const timeEl = document.createElement('time');
    timeEl.className = 'comm-log__time';
    if(entry.ts){
      const d = new Date(entry.ts);
      if(!Number.isNaN(d.valueOf())){
        timeEl.dateTime = entry.ts;
        timeEl.textContent = d.toLocaleString([], { hour:'2-digit', minute:'2-digit', second:'2-digit', hour12:false });
      }else{
        timeEl.textContent = entry.ts;
      }
    }
    li.appendChild(typeSpan);
    li.appendChild(timeEl);
    commLogList.appendChild(li);
  });
  if(commLogToggleBtn){
    const hasExtra = commLog.length > limit;
    commLogToggleBtn.hidden = !hasExtra;
    if(hasExtra){
      commLogToggleBtn.textContent = commShowAll ? 'Show less' : 'Show all';
      commLogToggleBtn.setAttribute('aria-expanded', commShowAll ? 'true' : 'false');
    }else{
      commLogToggleBtn.setAttribute('aria-expanded', 'false');
    }
  }
}

function setNextDue(date){
  if(!(date instanceof Date) || Number.isNaN(date.valueOf())) return;
  commNextDueIso = date.toISOString();
  const val = toTimeValue(date);
  if(commNextUpdateTime){ commNextUpdateTime.value = val; }
  dueToastShown = false;
  scheduleCadenceTick();
}

function applyManualDueValue(value){
  if(!value){
    commNextDueIso = '';
    dueToastShown = false;
    if(commNextUpdateTime){ commNextUpdateTime.value = ''; }
    toggleCommDue(false);
    if(commCountdown){ commCountdown.textContent = ''; }
    return;
  }
  const iso = isoFromTimeValue(value);
  if(!iso) return;
  commNextDueIso = iso;
  if(commNextUpdateTime){ commNextUpdateTime.value = value; }
  toggleCommDue(false);
  dueToastShown = false;
  scheduleCadenceTick();
  updateCadenceState();
}

function updateCadenceState(){
  if(!commCountdown) return;
  if(!commNextDueIso){
    commCountdown.textContent = '';
    toggleCommDue(false);
    return;
  }
  const now = new Date();
  const due = new Date(commNextDueIso);
  if(Number.isNaN(due.valueOf())){
    commCountdown.textContent = '';
    toggleCommDue(false);
    return;
  }
  const diff = due.getTime() - now.getTime();
  if(diff <= 0){
    commCountdown.textContent = 'Due now';
    toggleCommDue(true);
    if(!dueToastShown){
      dueToastShown = true;
      if(typeof showToast === 'function'){ showToast('Next communication is due now.'); }
    }
    return;
  }
  commCountdown.textContent = `Next in ${formatCountdown(diff)}`;
  toggleCommDue(false);
}

function scheduleCadenceTick(){
  if(cadenceTimerId){ clearInterval(cadenceTimerId); }
  cadenceTimerId = setInterval(updateCadenceState, 15000);
  updateCadenceState();
}

function logCommunication(type){
  const now = new Date();
  const iso = now.toISOString();
  commLog.unshift({ type, ts: iso });
  commLog = commLog.slice(0, 20);
  commShowAll = false;
  updateCommLogUI();
  const mins = getCadenceMinutes();
  if(mins){
    const due = new Date(now);
    due.setMinutes(due.getMinutes() + mins);
    setNextDue(due);
  }
  saveToStorage();
}

/* ===== Possible causes (hypotheses) ===== */
const CAUSE_FINDING_MODES = {
  ASSUMPTION: 'assumption',
  YES: 'yes',
  FAIL: 'fail'
};
const CAUSE_FINDING_MODE_VALUES = Object.values(CAUSE_FINDING_MODES);

function isValidFindingMode(mode){
  return typeof mode === 'string' && CAUSE_FINDING_MODE_VALUES.includes(mode);
}
function normalizeFindingEntry(entry){
  const normalized = { mode:'', note:'' };
  if(entry && typeof entry === 'object'){
    if(typeof entry.mode === 'string'){
      const mode = entry.mode.trim().toLowerCase();
      if(isValidFindingMode(mode)){ normalized.mode = mode; }
    }
    if(typeof entry.note === 'string'){
      normalized.note = entry.note;
    }else if(typeof entry.note === 'number'){
      normalized.note = String(entry.note);
    }
    const explainIs = typeof entry.explainIs === 'string' ? entry.explainIs.trim() : '';
    const explainNot = typeof entry.explainNot === 'string' ? entry.explainNot.trim() : '';
    if(!normalized.mode && (explainIs || explainNot)){
      normalized.mode = CAUSE_FINDING_MODES.YES;
      normalized.note = [explainIs, explainNot].filter(Boolean).join('\n');
    }else if(normalized.mode && !normalized.note && (explainIs || explainNot)){
      normalized.note = [explainIs, explainNot].filter(Boolean).join('\n');
    }
  }else if(typeof entry === 'string'){
    normalized.mode = CAUSE_FINDING_MODES.YES;
    normalized.note = entry;
  }
  return normalized;
}
function findingMode(entry){
  if(!entry || typeof entry !== 'object') return '';
  const mode = typeof entry.mode === 'string' ? entry.mode : '';
  return isValidFindingMode(mode) ? mode : '';
}
function findingNote(entry){
  if(!entry || typeof entry !== 'object') return '';
  return typeof entry.note === 'string' ? entry.note : '';
}
function findingIsComplete(entry){
  const mode = findingMode(entry);
  if(!mode) return false;
  const note = findingNote(entry).trim();
  if(!note) return false;
  return true;
}
function peekCauseFinding(cause, key){
  if(!cause || !cause.findings || typeof cause.findings !== 'object') return null;
  const existing = cause.findings[key];
  if(!existing) return null;
  const normalized = normalizeFindingEntry(existing);
  cause.findings[key] = normalized;
  return normalized;
}
function causeHasFailure(cause){
  if(!cause) return false;
  const indexes = evidencePairIndexes();
  for(let i=0;i<indexes.length;i++){
    const entry = peekCauseFinding(cause, getRowKeyByIndex(indexes[i]));
    if(entry && findingMode(entry) === CAUSE_FINDING_MODES.FAIL){
      return true;
    }
  }
  return false;
}
function countCauseAssumptions(cause){
  if(!cause) return 0;
  const indexes = evidencePairIndexes();
  let total = 0;
  indexes.forEach(idx=>{
    const entry = peekCauseFinding(cause, getRowKeyByIndex(idx));
    if(entry && findingMode(entry) === CAUSE_FINDING_MODES.ASSUMPTION){ total++; }
  });
  return total;
}
function substituteEvidenceTokens(template, isText, notText){
  if(typeof template !== 'string') return '';
  const safeIs = (isText || '').trim() || 'IS column';
  const safeNot = (notText || '').trim() || 'IS NOT column';
  return template
    .replace(/<is\s+not>/gi, safeNot)
    .replace(/<is>/gi, safeIs);
}
function generateCauseId(){
  return 'cause-' + Math.random().toString(36).slice(2,8) + '-' + Date.now().toString(36);
}
function createEmptyCause(){
  return {
    id: generateCauseId(),
    suspect: '',
    accusation: '',
    impact: '',
    findings: {},
    editing: true,
    testingOpen: false
  };
}
function hasCompleteHypothesis(cause){
  if(!cause) return false;
  return ['suspect','accusation','impact'].every(key=>typeof cause[key]==='string' && cause[key].trim().length);
}
function buildHypothesisSentence(cause){
  if(!cause) return '';
  const suspect = (cause.suspect||'').trim();
  const accusation = (cause.accusation||'').trim();
  const impact = (cause.impact||'').trim();
  if(!suspect && !accusation && !impact){
    return 'Add suspect, accusation, and impact to craft a strong hypothesis.';
  }
  const fallback = text=> (text && text.trim()) ? text.trim() : '…';
  return `We suspect ${fallback(suspect)} because ${fallback(accusation)}, which results in ${fallback(impact)}.`;
}
function getRowKeyByIndex(index){
  const row = rowsBuilt[index];
  if(row && row.def && row.def.q){
    return row.def.q;
  }
  return `row-${index}`;
}
function ensureCauseFindings(cause){
  if(!cause.findings || typeof cause.findings !== 'object'){
    cause.findings = {};
  }
  return cause.findings;
}
function getCauseFinding(cause, key){
  const map = ensureCauseFindings(cause);
  map[key] = normalizeFindingEntry(map[key]);
  return map[key];
}
function setCauseFindingValue(cause, key, prop, value){
  const entry = getCauseFinding(cause, key);
  if(prop === 'mode'){
    const normalized = typeof value === 'string' ? value.trim().toLowerCase() : '';
    entry.mode = isValidFindingMode(normalized) ? normalized : '';
    if(!entry.mode){ entry.note = ''; }
  }else if(prop === 'note'){
    entry.note = typeof value === 'string' ? value : '';
  }else{
    entry[prop] = value;
  }
}
function rowHasEvidencePair(row){
  if(!row) return false;
  const isText = typeof row?.isTA?.value === 'string' ? row.isTA.value.trim() : '';
  const notText = typeof row?.notTA?.value === 'string' ? row.notTA.value.trim() : '';
  return Boolean(isText && notText);
}
function evidencePairIndexes(){
  const indexes = [];
  rowsBuilt.forEach((row, index)=>{
    if(rowHasEvidencePair(row)){
      indexes.push(index);
    }
  });
  return indexes;
}
function countCompletedEvidence(cause, eligibleIndexes){
  let count = 0;
  const indexes = Array.isArray(eligibleIndexes) ? eligibleIndexes : evidencePairIndexes();
  indexes.forEach(index=>{
    const key = getRowKeyByIndex(index);
    const entry = peekCauseFinding(cause, key);
    if(entry && findingIsComplete(entry)){ count++; }
  });
  return count;
}
function causeStatusState(cause, answered, total){
  if(!hasCompleteHypothesis(cause)) return 'draft';
  if(total === 0) return 'no-evidence';
  if(causeHasFailure(cause)) return 'failed';
  if(answered === 0) return 'not-tested';
  if(answered < total) return 'testing';
  return 'explained';
}
function causeStatusLabel(cause){
  const eligibleIndexes = evidencePairIndexes();
  const total = eligibleIndexes.length;
  const answered = countCompletedEvidence(cause, eligibleIndexes);
  if(cause?.editing) return 'Editing hypothesis';
  if(!hasCompleteHypothesis(cause)) return 'Draft hypothesis';
  if(total === 0) return rowsBuilt.length ? 'Waiting for KT evidence pairs' : 'Ready to test';
  if(causeHasFailure(cause)) return 'Failed testing';
  if(answered === 0) return 'Not tested yet';
  if(answered < total) return 'Testing in progress';
  return 'Explains all evidence';
}
function updateCauseProgressChip(chip, cause){
  if(!chip || !cause) return;
  const eligibleIndexes = evidencePairIndexes();
  const total = eligibleIndexes.length;
  const answered = countCompletedEvidence(cause, eligibleIndexes);
  chip.textContent = total ? `${answered}/${total} evidence checks` : 'No KT evidence pairs yet';
  const status = causeStatusState(cause, answered, total);
  chip.dataset.status = status;
}
function updateCauseStatusLabel(el, cause){
  if(!el) return;
  el.textContent = causeStatusLabel(cause);
}
function updateCauseCardIndicators(card, cause){
  if(!card || !cause) return;
  const failureEl = card.querySelector('.cause-card__failure');
  const assumptionEl = card.querySelector('.cause-card__assumptions');
  const failed = causeHasFailure(cause);
  if(failureEl){ failureEl.hidden = !failed; }
  if(failed){
    card.dataset.failed = 'true';
  }else{
    delete card.dataset.failed;
  }
  if(assumptionEl){
    const count = countCauseAssumptions(cause);
    if(count > 0){
      assumptionEl.hidden = false;
      assumptionEl.textContent = count === 1 ? '1 assumption' : `${count} assumptions`;
    }else{
      assumptionEl.hidden = true;
    }
  }
}
function previewEvidenceText(value){
  const lines = splitLines(value);
  if(!lines.length) return '—';
  return lines.map(line=>`• ${line}`).join('\n');
}
function makeRemoveButton(cause){
  const btn = document.createElement('button');
  btn.type = 'button';
  btn.className = 'btn-mini btn-ghost';
  btn.textContent = 'Remove';
  btn.addEventListener('click', ()=>{
    if(confirm('Remove this possible cause?')){
      possibleCauses = possibleCauses.filter(item=>item.id !== cause.id);
      renderCauses();
      saveToStorage();
    }
  });
  return btn;
}
function ensurePossibleCausesUI(){
  let card = document.getElementById('possibleCausesCard');
  if(!card){
    const wrap = document.querySelector('.wrap');
    if(!wrap) return;
    card = document.createElement('div');
    card.className = 'card';
    card.id = 'possibleCausesCard';
    const heading = document.createElement('h3');
    heading.textContent = 'Possible Causes';
    const caption = document.createElement('p');
    caption.className = 'caption';
    caption.textContent = 'Capture hypotheses and pressure test them against the KT IS / IS NOT evidence. Start with the suspect, accusation, and impact; then walk each cause through the table.';
    const list = document.createElement('div');
    list.className = 'cause-list';
    list.id = 'causeList';
    list.setAttribute('aria-live', 'polite');
    const controls = document.createElement('div');
    controls.className = 'cause-controls';
    const btn = document.createElement('button');
    btn.type = 'button';
    btn.className = 'btn-mini';
    btn.id = 'addCauseBtn';
    btn.textContent = 'Add Possible Cause';
    controls.appendChild(btn);
    card.append(heading, caption, list, controls);
    const summaryCard = document.getElementById('summaryCard');
    if(summaryCard?.parentNode){
      summaryCard.parentNode.insertBefore(card, summaryCard);
    }else if(wrap){
      wrap.appendChild(card);
    }
  }
  causeList = document.getElementById('causeList');
  addCauseBtn = document.getElementById('addCauseBtn');
  if(addCauseBtn && !addCauseBtn.dataset.bound){
    addCauseBtn.dataset.bound = 'true';
    addCauseBtn.addEventListener('click', ()=>{
      const newCause = createEmptyCause();
      possibleCauses.push(newCause);
      renderCauses();
      saveToStorage();
      focusFirstEditableCause();
    });
  }
}
function renderCauses(){
  if(!causeList){
    ensurePossibleCausesUI();
  }
  if(!causeList) return;
  causeList.innerHTML = '';
  if(!possibleCauses.length){
    const empty = document.createElement('div');
    empty.className = 'cause-empty';
    empty.textContent = 'No possible causes captured yet.';
    causeList.appendChild(empty);
    updateCauseEvidencePreviews();
    return;
  }
  possibleCauses.forEach((cause, index)=>{
    if(!cause.id){ cause.id = generateCauseId(); }
    const card = document.createElement('article');
    card.className = 'cause-card';
    card.dataset.causeId = cause.id;
    if(cause.editing){ card.dataset.editing = 'true'; }
    const header = document.createElement('div');
    header.className = 'cause-card__header';
    const meta = document.createElement('div');
    meta.className = 'cause-card__meta';
    const titleEl = document.createElement('span');
    titleEl.className = 'cause-card__title';
    titleEl.textContent = `Possible Cause ${index+1}`;
    const statusEl = document.createElement('span');
    statusEl.className = 'cause-card__status';
    meta.append(titleEl, statusEl);
    const indicators = document.createElement('div');
    indicators.className = 'cause-card__indicators';
    const failureTag = document.createElement('span');
    failureTag.className = 'cause-card__failure';
    failureTag.textContent = 'Failed Testing';
    failureTag.hidden = true;
    const chip = document.createElement('span');
    chip.className = 'cause-card__chip';
    const assumptionTag = document.createElement('span');
    assumptionTag.className = 'cause-card__assumptions';
    assumptionTag.hidden = true;
    indicators.append(failureTag, chip, assumptionTag);
    header.append(meta, indicators);
    card.append(header);
    updateCauseStatusLabel(statusEl, cause);
    updateCauseProgressChip(chip, cause);
    const summaryEl = document.createElement('p');
    summaryEl.className = 'cause-card__summary';
    summaryEl.dataset.role = 'hypothesis';
    summaryEl.textContent = buildHypothesisSentence(cause);
    card.append(summaryEl);
    if(cause.editing){
      const helper = document.createElement('small');
      helper.className = 'cause-card__helper subtle';
      helper.textContent = 'Answer the prompts to refine the hypothesis statement.';
      card.append(helper);
      const form = document.createElement('div');
      form.className = 'cause-card__form';
      const suspectField = document.createElement('div');
      suspectField.className = 'field';
      const suspectLabel = document.createElement('label');
      suspectLabel.textContent = 'What/Who is the Suspect?';
      const suspectInput = document.createElement('textarea');
      suspectInput.value = cause.suspect || '';
      suspectInput.placeholder = 'Name the component, service, team, or actor you believe is responsible.';
      suspectInput.setAttribute('data-min-height','120');
      suspectInput.addEventListener('input', e=>{
        cause.suspect = e.target.value;
        autoResize(suspectInput);
        summaryEl.textContent = buildHypothesisSentence(cause);
        updateCauseStatusLabel(statusEl, cause);
        updateCauseProgressChip(chip, cause);
        saveToStorage();
      });
      autoResize(suspectInput);
      suspectField.append(suspectLabel, suspectInput);
      const accusationField = document.createElement('div');
      accusationField.className = 'field';
      const accusationLabel = document.createElement('label');
      accusationLabel.textContent = 'What is the Accusation?';
      const accusationInput = document.createElement('textarea');
      accusationInput.value = cause.accusation || '';
      accusationInput.placeholder = 'Describe the behavior, change, or failure you believe is occurring.';
      accusationInput.setAttribute('data-min-height','120');
      accusationInput.addEventListener('input', e=>{
        cause.accusation = e.target.value;
        autoResize(accusationInput);
        summaryEl.textContent = buildHypothesisSentence(cause);
        updateCauseStatusLabel(statusEl, cause);
        updateCauseProgressChip(chip, cause);
        saveToStorage();
      });
      autoResize(accusationInput);
      accusationField.append(accusationLabel, accusationInput);
      const impactField = document.createElement('div');
      impactField.className = 'field';
      const impactLabel = document.createElement('label');
      impactLabel.textContent = 'So What? How does this create the problem?';
      const impactInput = document.createElement('textarea');
      impactInput.value = cause.impact || '';
      impactInput.placeholder = 'Clarify how this cause would produce the customer or system impact.';
      impactInput.setAttribute('data-min-height','120');
      impactInput.addEventListener('input', e=>{
        cause.impact = e.target.value;
        autoResize(impactInput);
        summaryEl.textContent = buildHypothesisSentence(cause);
        updateCauseStatusLabel(statusEl, cause);
        updateCauseProgressChip(chip, cause);
        saveToStorage();
      });
      autoResize(impactInput);
      impactField.append(impactLabel, impactInput);
      form.append(suspectField, accusationField, impactField);
      card.append(form);
      const controls = document.createElement('div');
      controls.className = 'cause-controls';
      const saveBtn = document.createElement('button');
      saveBtn.type = 'button';
      saveBtn.className = 'btn-mini';
      saveBtn.textContent = 'Save hypothesis';
      saveBtn.addEventListener('click', ()=>{
        if(!hasCompleteHypothesis(cause)){
          if(typeof showToast === 'function'){ showToast('Fill in all three prompts to save this possible cause.'); }
          return;
        }
        cause.editing = false;
        renderCauses();
        saveToStorage();
      });
      controls.append(saveBtn);
      controls.append(makeRemoveButton(cause));
      card.append(controls);
    }else{
      const controls = document.createElement('div');
      controls.className = 'cause-controls';
      const editBtn = document.createElement('button');
      editBtn.type = 'button';
      editBtn.className = 'btn-mini btn-ghost';
      editBtn.textContent = 'Edit';
      editBtn.addEventListener('click', ()=>{
        cause.editing = true;
        renderCauses();
        saveToStorage();
        focusFirstEditableCause();
      });
      const testBtn = document.createElement('button');
      testBtn.type = 'button';
      testBtn.className = 'btn-mini';
      testBtn.textContent = cause.testingOpen ? 'Hide testing' : 'Test this cause';
      testBtn.addEventListener('click', ()=>{
        cause.testingOpen = !cause.testingOpen;
        renderCauses();
        saveToStorage();
      });
      controls.append(editBtn, testBtn, makeRemoveButton(cause));
      card.append(controls);
      if(cause.testingOpen){
        card.append(buildCauseTestPanel(cause, chip, statusEl, card));
      }
    }
    causeList.appendChild(card);
    updateCauseCardIndicators(card, cause);
  });
  updateCauseEvidencePreviews();
}
function buildCauseTestPanel(cause, progressChip, statusEl, card){
  const panel = document.createElement('div');
  panel.className = 'cause-test';
  const intro = document.createElement('p');
  intro.className = 'cause-test__intro';
  intro.textContent = 'For each KT row, choose how this hypothesis handles the IS / IS NOT evidence and document your reasoning.';
  panel.appendChild(intro);
  if(!rowsBuilt.length){
    const empty = document.createElement('div');
    empty.className = 'cause-empty';
    empty.textContent = 'Add IS / IS NOT evidence first to begin testing this cause.';
    panel.appendChild(empty);
    return panel;
  }
  const eligibleIndexes = evidencePairIndexes();
  if(!eligibleIndexes.length){
    const empty = document.createElement('div');
    empty.className = 'cause-empty';
    empty.textContent = 'Add IS / IS NOT evidence pairs to begin testing this cause.';
    panel.appendChild(empty);
    return panel;
  }
  eligibleIndexes.forEach(index=>{
    const row = rowsBuilt[index];
    const rowKey = getRowKeyByIndex(index);
    const finding = getCauseFinding(cause, rowKey);
    const rowEl = document.createElement('section');
    rowEl.className = 'cause-eval-row';
    rowEl.dataset.rowIndex = index;
    rowEl.dataset.rowKey = rowKey;
    const qText = document.createElement('div');
    qText.className = 'cause-eval-question-text';
    qText.dataset.role = 'question';
    qText.textContent = row?.th?.textContent?.trim() || fillTokens(row?.def?.q || '');
    rowEl.appendChild(qText);
    const evidenceWrap = document.createElement('div');
    evidenceWrap.className = 'cause-evidence-wrap';
    const isBlock = document.createElement('div');
    isBlock.className = 'cause-evidence-block';
    isBlock.dataset.rowIndex = index;
    isBlock.dataset.type = 'is';
    const isLabel = document.createElement('span');
    isLabel.className = 'cause-evidence-label';
    isLabel.textContent = 'IS evidence';
    const isValue = document.createElement('div');
    isValue.className = 'cause-evidence-text';
    isValue.dataset.role = 'is-value';
    isValue.textContent = previewEvidenceText(row?.isTA?.value || '');
    isBlock.append(isLabel, isValue);
    const notBlock = document.createElement('div');
    notBlock.className = 'cause-evidence-block';
    notBlock.dataset.rowIndex = index;
    notBlock.dataset.type = 'not';
    const notLabel = document.createElement('span');
    notLabel.className = 'cause-evidence-label';
    notLabel.textContent = 'IS NOT evidence';
    const notValue = document.createElement('div');
    notValue.className = 'cause-evidence-text';
    notValue.dataset.role = 'not-value';
    notValue.textContent = previewEvidenceText(row?.notTA?.value || '');
    notBlock.append(notLabel, notValue);
    evidenceWrap.append(isBlock, notBlock);
    rowEl.appendChild(evidenceWrap);
    const inputsWrap = document.createElement('div');
    inputsWrap.className = 'cause-eval-inputs';
    const optionWrap = document.createElement('div');
    optionWrap.className = 'cause-eval-options';
    const noteField = document.createElement('div');
    noteField.className = 'field cause-eval-note';
    noteField.hidden = true;
    const noteLabel = document.createElement('label');
    noteLabel.dataset.role = 'note-label';
    const noteInput = document.createElement('textarea');
    noteInput.dataset.role = 'finding-note';
    noteInput.value = findingNote(finding);
    noteInput.placeholder = 'Select an option to describe this relationship.';
    noteInput.setAttribute('data-min-height','120');
    noteInput.disabled = true;
    noteInput.addEventListener('input', e=>{
      setCauseFindingValue(cause, rowKey, 'note', e.target.value);
      autoResize(noteInput);
      updateCauseProgressChip(progressChip, cause);
      updateCauseStatusLabel(statusEl, cause);
      updateCauseCardIndicators(card, cause);
      saveToStorage();
    });
    autoResize(noteInput);
    noteField.append(noteLabel, noteInput);
    inputsWrap.append(optionWrap, noteField);
    rowEl.appendChild(inputsWrap);

    const optionDefs = [
      {
        mode: CAUSE_FINDING_MODES.ASSUMPTION,
        buttonLabel: 'Explains Only if…',
        noteLabel: 'What assumptions are necessary to explain why we see it on the <is> and not the <is not>?',
        placeholder: 'List the assumptions required so we observe <is> while avoiding <is not>.'
      },
      {
        mode: CAUSE_FINDING_MODES.YES,
        buttonLabel: 'Yes, because…',
        noteLabel: 'How does this naturally explain that we see <is> and that we don\'t see <is not>?',
        placeholder: 'Describe how this cause naturally creates <is> and avoids <is not>.'
      },
      {
        mode: CAUSE_FINDING_MODES.FAIL,
        buttonLabel: 'Does not explain…',
        noteLabel: 'Why can\'t we explain the <is> being present, but not the <is not>?',
        placeholder: 'Explain why this cause cannot produce <is> without contradicting <is not>.'
      }
    ];
    const buttons = [];
    const rawIs = row?.isTA?.value || '';
    const rawNot = row?.notTA?.value || '';

    function applyMode(newMode, opts={}){
      const active = isValidFindingMode(newMode) ? newMode : '';
      buttons.forEach(btn=>{
        btn.element.classList.toggle('is-selected', btn.mode === active);
      });
      if(active){
        const config = optionDefs.find(def=>def.mode === active);
        const labelTemplate = config?.noteLabel || '';
        const placeholderTemplate = config?.placeholder || '';
        noteLabel.textContent = substituteEvidenceTokens(labelTemplate, rawIs, rawNot);
        noteLabel.dataset.template = labelTemplate;
        noteInput.placeholder = substituteEvidenceTokens(placeholderTemplate, rawIs, rawNot);
        noteInput.dataset.placeholderTemplate = placeholderTemplate;
        noteInput.disabled = false;
        noteField.hidden = false;
      }else{
        noteLabel.textContent = '';
        delete noteLabel.dataset.template;
        noteInput.placeholder = 'Select an option to describe this relationship.';
        delete noteInput.dataset.placeholderTemplate;
        noteInput.value = '';
        noteInput.disabled = true;
        noteField.hidden = true;
        setCauseFindingValue(cause, rowKey, 'note', '');
      }
      autoResize(noteInput);
      if(!opts.silent){
        updateCauseProgressChip(progressChip, cause);
        updateCauseStatusLabel(statusEl, cause);
        updateCauseCardIndicators(card, cause);
        saveToStorage();
      }
    }

    optionDefs.forEach(def=>{
      const btn = document.createElement('button');
      btn.type = 'button';
      btn.className = 'cause-eval-option';
      btn.textContent = def.buttonLabel;
      btn.dataset.mode = def.mode;
      btn.addEventListener('click', ()=>{
        const entry = getCauseFinding(cause, rowKey);
        const current = findingMode(entry);
        if(current === def.mode){
          setCauseFindingValue(cause, rowKey, 'mode', '');
          applyMode('');
        }else{
          setCauseFindingValue(cause, rowKey, 'mode', def.mode);
          applyMode(def.mode);
        }
      });
      optionWrap.appendChild(btn);
      buttons.push({ element: btn, mode: def.mode });
    });

    const startingMode = findingMode(finding);
    noteInput.value = findingNote(finding);
    autoResize(noteInput);
    applyMode(startingMode, {silent:true});
    panel.appendChild(rowEl);
  });
  return panel;
}
function updateCauseEvidencePreviews(){
  if(!causeList) return;
  causeList.querySelectorAll('.cause-eval-row').forEach(rowEl=>{
    const index = parseInt(rowEl.dataset.rowIndex, 10);
    if(Number.isNaN(index) || !rowsBuilt[index]) return;
    const row = rowsBuilt[index];
    const questionEl = rowEl.querySelector('[data-role="question"]');
    if(questionEl){ questionEl.textContent = row?.th?.textContent?.trim() || fillTokens(row?.def?.q || ''); }
    const isValue = rowEl.querySelector('[data-role="is-value"]');
    const rawIs = row?.isTA?.value || '';
    const rawNot = row?.notTA?.value || '';
    if(isValue){ isValue.textContent = previewEvidenceText(rawIs); }
    const notValue = rowEl.querySelector('[data-role="not-value"]');
    if(notValue){ notValue.textContent = previewEvidenceText(rawNot); }
    const noteLabel = rowEl.querySelector('[data-role="note-label"]');
    if(noteLabel && noteLabel.dataset.template){
      noteLabel.textContent = substituteEvidenceTokens(noteLabel.dataset.template, rawIs, rawNot);
    }
    const noteInput = rowEl.querySelector('textarea[data-role="finding-note"]');
    if(noteInput && noteInput.dataset.placeholderTemplate){
      noteInput.placeholder = substituteEvidenceTokens(noteInput.dataset.placeholderTemplate, rawIs, rawNot);
    }
  });
  causeList.querySelectorAll('.cause-card').forEach(card=>{
    const id = card?.dataset?.causeId;
    if(!id) return;
    const cause = possibleCauses.find(item=>item.id === id);
    if(!cause) return;
    const chip = card.querySelector('.cause-card__chip');
    if(chip){ updateCauseProgressChip(chip, cause); }
    const statusEl = card.querySelector('.cause-card__status');
    if(statusEl){ updateCauseStatusLabel(statusEl, cause); }
    updateCauseCardIndicators(card, cause);
  });
}
function focusFirstEditableCause(){
  requestAnimationFrame(()=>{
    const target = causeList?.querySelector('[data-editing="true"] textarea');
    if(target){
      target.focus();
      const end = target.value.length;
      try{ target.setSelectionRange(end, end); }catch(_){ /* no-op */ }
    }
  });
}
function serializeCauses(){
  return possibleCauses.map(cause=>{
    const findings = {};
    if(cause.findings && typeof cause.findings === 'object'){
      Object.keys(cause.findings).forEach(key=>{
        const normalized = normalizeFindingEntry(cause.findings[key]);
        const mode = findingMode(normalized);
        const note = findingNote(normalized);
        if(mode || note.trim()){
          findings[key] = { mode, note };
          cause.findings[key] = normalized;
        }else{
          delete cause.findings[key];
        }
      });
    }
    return {
      id: cause.id || generateCauseId(),
      suspect: cause.suspect || '',
      accusation: cause.accusation || '',
      impact: cause.impact || '',
      findings,
      editing: !!cause.editing,
      testingOpen: !!cause.testingOpen
    };
  });
}
function deserializeCauses(rawList){
  if(!Array.isArray(rawList)) return [];
  return rawList.map(raw=>{
    const cause = {
      id: typeof raw.id === 'string' ? raw.id : generateCauseId(),
      suspect: typeof raw.suspect === 'string' ? raw.suspect : '',
      accusation: typeof raw.accusation === 'string' ? raw.accusation : '',
      impact: typeof raw.impact === 'string' ? raw.impact : '',
      findings: {},
      editing: !!raw.editing,
      testingOpen: !!raw.testingOpen
    };
    if(raw && raw.findings && typeof raw.findings === 'object'){
      Object.keys(raw.findings).forEach(key=>{
        const normalized = normalizeFindingEntry(raw.findings[key]);
        const mode = findingMode(normalized);
        const note = findingNote(normalized);
        if(mode || note.trim()){
          cause.findings[key] = normalized;
        }
      });
    }
    return cause;
  });
}

/* [script:tokens] start */
function firstSnippet(v){
  const s = (v||'').trim();
  if(!s) return '';
  // Return the first line or sentence, up to 120 chars (not just one char)
  const first = s.split(/\n|\. /)[0];
  return first.length > 120 ? first.slice(0,120) : first;
}
function compactOneLine(str, max=90){
  const s = (str||'').trim().replace(/\s+/g,' ');
  return s.length>max ? s.slice(0,max-1)+'…' : s;
}
function getObjectFull(){
  return (objectPrefill.value || objectIS?.value || '').trim();
}
function getDeviationFull(){
  // Treat "What is happening now?" as the deviation for the problem statement.
  return (now.value || deviationIS?.value || '').trim();
}
function objectAnchor(){
  // Use a compact anchor for labels (not the full paragraph to keep labels readable)
  const src = getObjectFull() || 'the object';
  return compactOneLine(src, 80);
}
function fillTokens(text){
  const obj = firstSnippet(objectIS?.value)    || firstSnippet(getObjectFull()) || 'the object';
  const dev = firstSnippet(deviationIS?.value) || firstSnippet(getDeviationFull()) || 'the deviation';
  return (text||'').replace(/\{OBJECT\}/g, '“'+obj+'”').replace(/\{DEVIATION\}/g, '“'+dev+'”');
}
function mkIsNotPH(baseCopy, isVal){
  const base = (baseCopy||'').trim();
  const isSnippet = firstSnippet(isVal);
  if(isSnippet){
    const prompt = fillTokens(``);
    return base ? `${prompt}\n\n${base}` : prompt;
  }
  return base || fillTokens('');
}
function mkDistPH(isVal, notVal){
  const base = fillTokens('');
  const isSnippet = firstSnippet(isVal);
  const notSnippet = firstSnippet(notVal);
  const parts = [];
  if(isSnippet){ parts.push(`What is different, odd, special, or uniquely true about “${isSnippet}”?`); }
  if(notSnippet){ parts.push(`Only list traits that are not shared by “${notSnippet}”`); }
  const lead = parts.length ? parts.join(' ') + '' : '';
  return lead ? `${lead}\n${base}` : base;
}
function mkChangePH(distText){
  const base = fillTokens('');
  const distSnippet = firstSnippet(distText);
  if(distSnippet){
    return `What changed in, on, around, or about “${distSnippet}”, Ask this question for each distinction listed.\n${base}`;
  }
  return base;
}
function refreshAllTokenizedText(){
  rowsBuilt.forEach(({th, def, isTA, notTA})=>{
    th.textContent = fillTokens(def.q);
    isTA.placeholder  = fillTokens(def.isPH||"");
    notTA.placeholder = mkIsNotPH(fillTokens(def.notPH||""), isTA.value);
  });
  updateCauseEvidencePreviews();
}
function updateTitlesAndLabels(){
  const objFull = getObjectFull();
  const devFull = getDeviationFull();
  const objAnch = objectAnchor();

  if(objFull && devFull){
    // H1/H2 use the FULL text as requested (concatenated)
    docTitle.textContent = `${objFull} — ${devFull}`;
    docSubtitle.textContent = `What is happening now to ${objAnch}: ${devFull}`;
    document.title = `${compactOneLine(objFull, 50)} — ${compactOneLine(devFull, 50)} · KT Intake`;
  }else{
    docTitle.textContent = "KT Intake";
    docSubtitle.textContent = "Describe Problem";
    document.title = "KT Intake";
  }

  // Dynamic labels for Healthy/Now
  labelNow.textContent = objAnch ? `What is happening now to ${objAnch}?` : "What is happening now?";
  labelHealthy.textContent = objAnch ? `What does healthy look like here for ${objAnch}?` : "What does healthy look like?";

  // (Optional) adjust placeholders subtly to reflect anchor
  if(objAnch){
    now.placeholder = ``;
    healthy.placeholder = ``;
  }
}
/* [script:tokens] end */


/* ===== Mirror Sync (robust against extensions/overlays) ===== */
let _mirrorTick = null;
let _lastPrefObj = "";
let _lastPrefNow = "";
function syncMirror(force=false){
  try{
    const curObj = getObjectFull();
    const curNow = getDeviationFull();
    let changed = false;
    if(force || curObj !== _lastPrefObj){
      _lastPrefObj = curObj;
      if(objectIS && !objectISDirty){
        if(objectIS.value !== curObj){
          objectIS.value = curObj;
          autoResize(objectIS);
          changed = true;
        }
      }
    }
    if(force || curNow !== _lastPrefNow){
      _lastPrefNow = curNow;
      if(deviationIS && !deviationISDirty){
        if(deviationIS.value !== curNow){
          deviationIS.value = curNow;
          autoResize(deviationIS);
          changed = true;
        }
      }
    }
    if(changed || force){
      refreshAllTokenizedText();
      updateTitlesAndLabels();
      saveToStorage();
    }
  }catch(e){ /* no-op */ }
}
/* [script:init] start */
function autoResize(el){
  if(!el || el.tagName !== 'TEXTAREA') return;
  el.style.height = 'auto';
  const attr = parseInt(el.getAttribute('data-min-height') || '', 10);
  const varMin = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--ta-min-h'), 10);
  const fallback = Number.isFinite(varMin) ? varMin : 140;
  const minH = Number.isFinite(attr) ? attr : fallback;
  const base = Number.isFinite(attr) ? attr : 140;
  el.style.height = Math.max(minH, el.scrollHeight, base) + 'px';
}
function init(){
  initTable();
  ensurePossibleCausesUI();
  renderCauses();
  restoreFromStorage();
  if(bridgeOpenedUtc && !bridgeOpenedUtc.value.trim()){
    bridgeOpenedUtc.value = new Date().toISOString();
    saveToStorage();
  }
  refreshAllTokenizedText();
  updateTitlesAndLabels();
  // Kick off periodic sync to capture extension-driven edits (e.g., Grammarly)
  if(!_mirrorTick){ _mirrorTick = setInterval(syncMirror, 300); }
  // Do an immediate sync so existing values populate
  syncMirror(true);
}
init();
/* [script:init] end */

/* [script:export] start */

/* =================== Summary Export (executive style, chat-friendly) =================== */

function ensureSummaryCard(){
  let card = document.getElementById('summaryCard');
  if(!card){
    const wrap = document.querySelector('.wrap');
    card = document.createElement('div');
    card.className = 'card';
    card.id = 'summaryCard';
    const h = document.createElement('h3'); h.textContent = 'Copy & Paste Summary';
    const pre = document.createElement('pre'); pre.id='summaryPre'; pre.style.whiteSpace='pre-wrap'; pre.style.font='13px/1.6 monospace'; pre.style.margin='0';
    card.appendChild(h); card.appendChild(pre);
    wrap.appendChild(card);
  }
  return card;
}

function valOrDash(s){ const v=(s||'').trim(); return v ? v : '—'; }
// Normalize user text into a single logical string for table cells (we’ll wrap visually in the table).
function inlineText(s){
  const v=(s||'').trim();
  if(!v) return '—';
  return v
    .split(/\r?\n/)
    .map(x=>x.trim())
    .filter(Boolean)
    .join(' · ');
}

function splitLines(text){
  const v=(text||'').trim();
  if(!v) return [];
  return v.split(/\r?\n/).map(line=>line.trim()).filter(Boolean);
}

function formatLabeledList(label, lines){
  if(!lines.length) return `${label}: —`;
  if(lines.length === 1) return `${label}: ${lines[0]}`;
  const bullets = lines.map(line=>`  • ${line}`).join('\n');
  return `${label}:\n${bullets}`;
}

function formatDistinctionChanges(distLines, changeLines){
  const len = Math.max(distLines.length, changeLines.length);
  if(len === 0) return 'Distinctions → Changes: —';
  if(len === 1){
    const left = distLines[0] || '—';
    const right = changeLines[0] || '—';
    return `Distinctions → Changes: ${left} → ${right}`;
  }
  const pairs = [];
  for(let i=0;i<len;i++){
    const left = distLines[i] || '—';
    const right = changeLines[i] || '—';
    pairs.push(`  • ${left} → ${right}`);
  }
  return ['Distinctions → Changes:', ...pairs].join('\n');
}

function formatChipsetSelections(list){
  const selected = list.filter(item=>item.el?.checked).map(item=>item.label);
  return selected.length ? selected.join(', ') : '—';
}

function containmentStatusText(){
  const status = getContainmentStatus();
  if(status==='mitigation') return 'Temporary mitigation applied';
  if(status==='restore') return 'Full restoration in progress';
  if(status==='none') return 'No action yet';
  return '—';
}

function latestCommEntry(type){
  if(!Array.isArray(commLog)) return null;
  return commLog.find(entry=>entry && entry.type === type && entry.ts);
}

function formatCommTimestamp(ts){
  if(!ts) return '';
  const d = new Date(ts);
  if(Number.isNaN(d.valueOf())) return ts;
  return d.toISOString();
}

function formatCommSummaryLine(type, label){
  const entry = latestCommEntry(type);
  if(!entry) return `${label}: —`;
  return `${label}: ${formatCommTimestamp(entry.ts)}`;
}

function nextUpdateSummaryLine(){
  if(commNextDueIso){
    const d = new Date(commNextDueIso);
    if(!Number.isNaN(d.valueOf())){
      return `Next Update: ${d.toISOString()}`;
    }
    return `Next Update: ${commNextDueIso}`;
  }
  if(commNextUpdateTime?.value){
    return `Next Update: ${commNextUpdateTime.value}`;
  }
  return 'Next Update: —';
}

function causeProgressSummary(cause){
  const eligibleIndexes = evidencePairIndexes();
  const total = eligibleIndexes.length;
  if(total === 0) return 'No KT evidence pairs captured yet';
  const answered = countCompletedEvidence(cause, eligibleIndexes);
  if(causeHasFailure(cause)){
    return `${answered}/${total} evidence checks • Failed on at least one check`;
  }
  return `${answered}/${total} evidence checks complete`;
}

function formatCauseFindingsSummary(cause){
  if(!cause || !cause.findings) return '';
  const eligibleIndexes = evidencePairIndexes();
  if(!eligibleIndexes.length) return '';
  const sections = [];
  eligibleIndexes.forEach(index=>{
    const row = rowsBuilt[index];
    const key = getRowKeyByIndex(index);
    const entry = peekCauseFinding(cause, key);
    if(!entry) return;
    const mode = findingMode(entry);
    const note = findingNote(entry);
    if(!mode && !note.trim()) return;
    const label = row?.th?.textContent?.trim() || fillTokens(row?.def?.q || `Row ${index+1}`);
    const lines = [`  • ${label}`];
    if(mode === CAUSE_FINDING_MODES.ASSUMPTION){
      lines.push(`    - Assumptions needed: ${inlineText(note)}`);
    }else if(mode === CAUSE_FINDING_MODES.YES){
      lines.push(`    - Explains evidence: ${inlineText(note)}`);
    }else if(mode === CAUSE_FINDING_MODES.FAIL){
      lines.push(`    - Fails because: ${inlineText(note)}`);
    }else if(note.trim()){
      lines.push(`    - Notes: ${inlineText(note)}`);
    }
    sections.push(lines.join('\n'));
  });
  return sections.length ? ['Evidence walkthrough:', ...sections].join('\n') : '';
}

function formatPossibleCausesSummary(){
  if(!possibleCauses.length){
    return 'No possible causes captured.';
  }
  const blocks = possibleCauses.map((cause, index)=>{
    const header = `• Possible Cause ${index+1}: ${buildHypothesisSentence(cause)}`;
    const status = `  Status: ${causeStatusLabel(cause)}`;
    const progress = `  Progress: ${causeProgressSummary(cause)}`;
    const failureLine = causeHasFailure(cause) ? '  Result: Failed testing on at least one evidence check' : '';
    const assumptionCount = countCauseAssumptions(cause);
    const assumptionLine = assumptionCount ? `  Assumptions noted: ${assumptionCount}` : '';
    const evidence = formatCauseFindingsSummary(cause);
    return [header, status, progress, failureLine, assumptionLine, evidence].filter(Boolean).join('\n');
  });
  return blocks.join('\n\n');
}

/* ---------- Executive summary builder ---------- */
function buildSummaryText(){
  const title = document.getElementById('docTitle').textContent.trim();
  const subtitle = document.getElementById('docSubtitle').textContent.trim();

  const bridge = [
    `Bridge Opened (UTC): ${valOrDash(bridgeOpenedUtc?.value)}`,
    `Incident Commander: ${valOrDash(icName?.value)}`,
    `Bridge Coordinator: ${valOrDash(bcName?.value)}`,
    `SEM/Ops Lead: ${valOrDash(semOpsName?.value)}`,
    `Severity: ${valOrDash(severity?.value)}`
  ].join('\n');

  const detectionSummary = formatChipsetSelections([
    {el: detectMonitoring, label: 'Monitoring'},
    {el: detectUserReport, label: 'User Report'},
    {el: detectAutomation, label: 'Automation'},
    {el: detectOther, label: 'Other'}
  ]);

  const evidenceSummary = formatChipsetSelections([
    {el: evScreenshot, label: 'Screenshot'},
    {el: evLogs, label: 'Logs'},
    {el: evMetrics, label: 'Metrics'},
    {el: evRepro, label: 'Repro'},
    {el: evOther, label: 'Other'}
  ]);

  // === Preface (inline answers) ===
  const prefaceLines = [
    `• One-line: ${valOrDash(oneLine.value)}`,
    `• Evidence/Proof: ${inlineText(proof.value)}`,
    `• Specific Object: ${inlineText(objectPrefill.value || (objectIS?.value||''))}`,
    `• Healthy Baseline: ${inlineText(healthy.value)}`,
    `• Current State (What is happening now?): ${inlineText(now.value)}`,
    `• Detection Source: ${detectionSummary}`,
    `• Evidence Collected: ${evidenceSummary}`
  ];
  const preface = prefaceLines.join('\n');

  // === Impact (inline answers) ===
  const imp = [
    `Current Impact: ${inlineText(impactNow.value)}`,
    `Future Impact: ${inlineText(impactFuture.value)}`,
    `Timeframe: ${inlineText(impactTime.value)}`
  ].join('\n');

  const containment = [
    `Status: ${containmentStatusText()}`,
    `Description: ${valOrDash(containDesc?.value)}`
  ].join('\n');

  const communications = [
    formatCommSummaryLine('internal', 'Last Internal Update'),
    formatCommSummaryLine('external', 'Last External Update'),
    nextUpdateSummaryLine()
  ].join('\n');

  // === KT Table as chat-friendly blocks per question ===
  const rowsOut = [];

  [...tbody.querySelectorAll('tr')].forEach(tr=>{
    if(tr.classList.contains('band')){
      rowsOut.push('');
      rowsOut.push(`== ${tr.textContent.trim()} ==`);
      return;
    }
    const q = tr.querySelector('th').textContent.trim();
    const t = tr.querySelectorAll('textarea');
    const isLines = splitLines(t[0].value);
    const notLines = splitLines(t[1].value);
    const distLines = splitLines(t[2].value);
    const changeLines = splitLines(t[3].value);

    // Question header
    rowsOut.push(`Q: ${q}`);
    rowsOut.push(formatLabeledList('IS', isLines));
    rowsOut.push(formatLabeledList('IS NOT', notLines));
    rowsOut.push(formatDistinctionChanges(distLines, changeLines));
  });

  const ktOut = rowsOut.join('\n\n'); // clear breathing room between tables

  // === Compose (minimal blank lines between major sections) ===
  return [
    title,
    subtitle,
    '',
    '— Bridge Activation —',
    bridge,
    '',
    '— Preface —',
    preface,
    '',
    '— Containment —',
    containment,
    '',
    '— Impact —',
    imp,
    '',
    '— Communications —',
    communications,
    '',
    '— Possible Causes —',
    formatPossibleCausesSummary(),
    '',
    '— KT IS / IS NOT —',
    ktOut
  ].join('\n');
}



async function onGenerateSummary(){
  const text = buildSummaryText();

  // Always render at bottom for manual copy
  const card = ensureSummaryCard();
  const pre = document.getElementById('summaryPre');
  pre.textContent = text;
  card.style.display = 'block';
  // Try clipboard copy (best effort)
  try{
    if(window.isSecureContext && navigator.clipboard && navigator.clipboard.writeText){
      await navigator.clipboard.writeText(text);
      if(typeof showToast==='function'){ showToast('Summary updated & copied. It’s also shown below.'); }
    }else{
      if(typeof showToast==='function'){ showToast('Summary updated. Clipboard blocked — copy it from the bottom.'); }
    }
  }catch(_){
    if(typeof showToast==='function'){ showToast('Summary updated. Clipboard blocked — copy it from the bottom.'); }
  }
}

document.addEventListener('DOMContentLoaded', function(){
  var btn = document.getElementById('genSummaryBtn');
  if(btn){ btn.addEventListener('click', onGenerateSummary); }
});

/* [script:export] end */

/* [script:storage] start */
/* =================== Autosave =================== */
const STORAGE_KEY='kt-intake-full-v2';
function getContainmentStatus(){
  if(containMitigation?.checked) return 'mitigation';
  if(containRestore?.checked) return 'restore';
  if(containNone?.checked) return 'none';
  return '';
}
function saveToStorage(){
  const data={ pre:{ oneLine:oneLine.value, proof:proof.value, objectPrefill:objectPrefill.value, healthy:healthy.value, now:now.value },
               impact:{ now:impactNow.value, future:impactFuture.value, time:impactTime.value },
               ops:{
                 bridgeOpenedUtc:bridgeOpenedUtc?.value||'',
                 icName:icName?.value||'',
                 bcName:bcName?.value||'',
                 semOpsName:semOpsName?.value||'',
                 severity:severity?.value||'',
                 detectMonitoring:!!detectMonitoring?.checked,
                 detectUserReport:!!detectUserReport?.checked,
                 detectAutomation:!!detectAutomation?.checked,
                 detectOther:!!detectOther?.checked,
                 evScreenshot:!!evScreenshot?.checked,
                 evLogs:!!evLogs?.checked,
                 evMetrics:!!evMetrics?.checked,
                 evRepro:!!evRepro?.checked,
                 evOther:!!evOther?.checked,
                 containStatus:getContainmentStatus(),
                 containDesc:containDesc?.value||'',
                 commNextUpdateTime:commNextUpdateTime?.value||'',
                 commCadence:commCadence||'',
                 commLog:commLog.slice(0,20),
                 commNextDueIso:commNextDueIso||''
               },
               table:[],
               causes: serializeCauses() };
  [...tbody.querySelectorAll('tr')].forEach(tr=>{
    if(tr.classList.contains('band')){ data.table.push({band: tr.textContent.trim()}); return; }
    const t=tr.querySelectorAll('textarea');
    data.table.push({q: tr.querySelector('th').textContent.trim(), is:t[0].value, no:t[1].value, di:t[2].value, ch:t[3].value});
  });
  localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
}
function restoreFromStorage(){
  const raw = localStorage.getItem(STORAGE_KEY); if(!raw) return;
  const data = JSON.parse(raw);
  if(data.pre){
    oneLine.value=data.pre.oneLine||''; proof.value=data.pre.proof||'';
    objectPrefill.value=data.pre.objectPrefill||''; healthy.value=data.pre.healthy||'';
    now.value=data.pre.now||'';
    [oneLine,proof,objectPrefill,healthy,now].forEach(autoResize);
    if(objectPrefill.value && objectIS && !objectIS.value) { objectIS.value=objectPrefill.value; autoResize(objectIS); }
    if(now.value && deviationIS && !deviationIS.value) { deviationIS.value=now.value; autoResize(deviationIS); }
  }
  if(data.impact){
    impactNow.value=data.impact.now||''; impactFuture.value=data.impact.future||''; impactTime.value=data.impact.time||'';
    [impactNow,impactFuture,impactTime].forEach(autoResize);
  }
  if(data.ops){
    if(bridgeOpenedUtc){ bridgeOpenedUtc.value=data.ops.bridgeOpenedUtc||''; }
    if(icName){ icName.value=data.ops.icName||''; }
    if(bcName){ bcName.value=data.ops.bcName||''; }
    if(semOpsName){ semOpsName.value=data.ops.semOpsName||''; }
    if(severity){ severity.value=data.ops.severity||''; }
    if(detectMonitoring){ detectMonitoring.checked=!!data.ops.detectMonitoring; }
    if(detectUserReport){ detectUserReport.checked=!!data.ops.detectUserReport; }
    if(detectAutomation){ detectAutomation.checked=!!data.ops.detectAutomation; }
    if(detectOther){ detectOther.checked=!!data.ops.detectOther; }
    if(evScreenshot){ evScreenshot.checked=!!data.ops.evScreenshot; }
    if(evLogs){ evLogs.checked=!!data.ops.evLogs; }
    if(evMetrics){ evMetrics.checked=!!data.ops.evMetrics; }
    if(evRepro){ evRepro.checked=!!data.ops.evRepro; }
    if(evOther){ evOther.checked=!!data.ops.evOther; }
    if(containDesc){ containDesc.value=data.ops.containDesc||''; }
    if(typeof data.ops.containStatus==='string'){
      const status = data.ops.containStatus;
      if(containNone){ containNone.checked = status==='none'; }
      if(containMitigation){ containMitigation.checked = status==='mitigation'; }
      if(containRestore){ containRestore.checked = status==='restore'; }
    }
    if(commNextUpdateTime){ commNextUpdateTime.value=data.ops.commNextUpdateTime||''; }
    commCadence = typeof data.ops.commCadence==='string' ? data.ops.commCadence : commCadence;
    if(Array.isArray(data.ops.commLog)){
      commLog = data.ops.commLog.filter(entry=>entry && typeof entry.type==='string' && typeof entry.ts==='string');
    }
    commNextDueIso = typeof data.ops.commNextDueIso==='string' ? data.ops.commNextDueIso : commNextDueIso;
    dueToastShown = false;
    updateCadenceRadios();
    updateCommLogUI();
    if(commNextDueIso){
      const due = new Date(commNextDueIso);
      if(!Number.isNaN(due.valueOf())){
        const val = toTimeValue(due);
        if(val){
          if(commNextUpdateTime){ commNextUpdateTime.value = val; }
        }
      }
    }else if(commNextUpdateTime && commNextUpdateTime.value){
      applyManualDueValue(commNextUpdateTime.value);
    }else{
      updateCadenceState();
    }
  }
  if(Array.isArray(data.table)){
    let i=0;
    [...tbody.querySelectorAll('tr')].forEach(tr=>{
      if(tr.classList.contains('band')) return;
      const rec = data.table.find(d=>d.q===tr.querySelector('th').textContent.trim() && !d.band) || data.table[i++];
      if(!rec) return;
      const t = tr.querySelectorAll('textarea');
      t[0].value=rec.is||''; t[1].value=rec.no||''; t[2].value=rec.di||''; t[3].value=rec.ch||'';
      t.forEach(autoResize);
    });
  }
  if(Array.isArray(data.causes)){
    possibleCauses = deserializeCauses(data.causes);
  }else{
    possibleCauses = [];
  }
  ensurePossibleCausesUI();
  renderCauses();
  if(possibleCauses.some(cause=>cause && cause.editing)){
    focusFirstEditableCause();
  }
  updateCauseEvidencePreviews();
  scheduleCadenceTick();
}
/* [script:storage] end */

/* [script:toast] start */
function showToast(msg){
  const toast = document.getElementById('toast');
  toast.textContent = msg;
  toast.className = 'toast show';
  setTimeout(()=>toast.classList.remove('show'), 2200);
}
/* [script:toast] end */
</script>
<!-- [script] end -->
</body>
</html>
