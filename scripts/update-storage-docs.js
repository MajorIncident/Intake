#!/usr/bin/env node
/**
 * @file CLI that materialises the latest storage schema into
 * `docs/storage-schema.md`, ensuring the documentation matches the current app
 * state migrations and field definitions.
 */
import { promises as fs } from 'node:fs';
import path from 'node:path';
import { fileURLToPath } from 'node:url';

import { APP_STATE_VERSION } from '../src/appStateVersion.js';
import { migrateAppState, MIGRATION_REGISTRY } from '../src/storage.js';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const repoRoot = path.resolve(__dirname, '..');
const docsDir = path.join(repoRoot, 'docs');
const outputPath = path.join(docsDir, 'storage-schema.md');

/**
 * Derives a human-readable type label for a given field value.
 * @param {unknown} value Value whose type should be described.
 * @returns {string} One of `array`, `null`, or the result of `typeof`.
 */
function describeType(value) {
  if (Array.isArray(value)) {
    return 'array';
  }
  if (value === null) {
    return 'null';
  }
  return typeof value;
}

/**
 * Collects flattened field descriptors for every nested property in a state.
 * @param {unknown} value The value to inspect for nested fields.
 * @param {string[]} [parts] The accumulated path components for recursion. Defaults to an empty array.
 * @param {Array<{ field: string, type: string }>} [acc] Aggregate results array. Defaults to an empty array.
 * @returns {Array<{ field: string, type: string }>} The provided accumulator with all discovered field descriptors.
 */
function collectFields(value, parts = [], acc = []) {
  if (parts.length > 0) {
    acc.push({
      field: parts.join('.'),
      type: describeType(value)
    });
  }
  if (value && typeof value === 'object' && !Array.isArray(value)) {
    const keys = Object.keys(value).sort();
    for (const key of keys) {
      collectFields(value[key], [...parts, key], acc);
    }
  }
  return acc;
}

/**
 * Builds lookup metadata linking fields to the migration version introducing them.
 * @returns {{ overrides: Map<string, number>, migrations: Array<[number, { introducedFields?: string[], name?: string }]> }} An object containing the lookup map and ordered registry entries.
 */
function buildIntroducedOverrides() {
  const overrides = new Map();
  const migrations = Array.from(MIGRATION_REGISTRY.entries()).sort((a, b) => a[0] - b[0]);
  for (const [fromVersion, migration] of migrations) {
    const targetVersion = fromVersion + 1;
    if (Array.isArray(migration?.introducedFields)) {
      for (const fieldPath of migration.introducedFields) {
        if (typeof fieldPath === 'string' && !overrides.has(fieldPath)) {
          overrides.set(fieldPath, targetVersion);
        }
      }
    }
  }
  return { overrides, migrations };
}

/**
 * Renders the migrations section for the documentation markdown file.
 * @param {Array<[number, { introducedFields?: string[], name?: string }]>} migrations Ordered migration entries from the registry.
 * @returns {string} Markdown representing the migrations table.
 */
function renderMigrationsTable(migrations) {
  if (!migrations.length) {
    return '## Migrations\n\n_No registered migrations. States start at the base schema._\n\n';
  }
  const lines = ['## Migrations', '', '| From version | Migrator |', '| --- | --- |'];
  for (const [fromVersion, migration] of migrations) {
    const name = typeof migration?.name === 'string' && migration.name ? migration.name : '(anonymous)';
    lines.push(`| ${fromVersion} | \`${name}\` |`);
  }
  lines.push('');
  return lines.join('\n') + '\n';
}

/**
 * Generates and writes the storage documentation markdown file.
 * @returns {Promise<void>} A promise that resolves when the file has been written to disk.
 */
async function writeStorageDocs() {
  const canonicalState = migrateAppState({});
  const fields = collectFields(canonicalState);
  if (!fields.some(entry => entry.field === 'actions')) {
    const actionDescriptors = collectFields({ analysisId: '', items: [] }, ['actions']);
    fields.push(...actionDescriptors);
  }
  fields.sort((a, b) => a.field.localeCompare(b.field));

  const { overrides, migrations } = buildIntroducedOverrides();

  const lines = [
    '# Storage Schema',
    '',
    '_Auto-generated by `scripts/update-storage-docs.js`. Do not edit this file manually._',
    '',
    `- Current \`APP_STATE_VERSION\`: ${APP_STATE_VERSION}`,
    `- Total tracked fields: ${fields.length}`,
    ''
  ];

  lines.push(renderMigrationsTable(migrations).trimEnd());
  lines.push('');
  lines.push('## Field definitions');
  lines.push('');
  lines.push('| Field | Type | Introduced |');
  lines.push('| --- | --- | --- |');
  for (const { field, type } of fields) {
    const introduced = overrides.get(field) ?? APP_STATE_VERSION;
    lines.push(`| \`${field}\` | ${type} | ${introduced} |`);
  }
  lines.push('');

  await fs.mkdir(docsDir, { recursive: true });
  await fs.writeFile(outputPath, lines.join('\n'));
}

writeStorageDocs().catch(error => {
  console.error('[update-storage-docs] Failed to generate documentation:', error);
  process.exitCode = 1;
});
