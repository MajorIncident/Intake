#!/usr/bin/env node
import { promises as fs } from 'node:fs';
import path from 'node:path';
import { fileURLToPath } from 'node:url';

import { APP_STATE_VERSION } from '../src/appStateVersion.js';
import { migrateAppState, MIGRATION_REGISTRY } from '../src/storage.js';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const repoRoot = path.resolve(__dirname, '..');
const docsDir = path.join(repoRoot, 'docs');
const outputPath = path.join(docsDir, 'storage-schema.md');

function describeType(value) {
  if (Array.isArray(value)) {
    return 'array';
  }
  if (value === null) {
    return 'null';
  }
  return typeof value;
}

function collectFields(value, parts = [], acc = []) {
  if (parts.length > 0) {
    acc.push({
      field: parts.join('.'),
      type: describeType(value)
    });
  }
  if (value && typeof value === 'object' && !Array.isArray(value)) {
    const keys = Object.keys(value).sort();
    for (const key of keys) {
      collectFields(value[key], [...parts, key], acc);
    }
  }
  return acc;
}

function buildIntroducedOverrides() {
  const overrides = new Map();
  const migrations = Array.from(MIGRATION_REGISTRY.entries()).sort((a, b) => a[0] - b[0]);
  for (const [fromVersion, migration] of migrations) {
    const targetVersion = fromVersion + 1;
    if (Array.isArray(migration?.introducedFields)) {
      for (const fieldPath of migration.introducedFields) {
        if (typeof fieldPath === 'string' && !overrides.has(fieldPath)) {
          overrides.set(fieldPath, targetVersion);
        }
      }
    }
  }
  return { overrides, migrations };
}

function renderMigrationsTable(migrations) {
  if (!migrations.length) {
    return '## Migrations\n\n_No registered migrations. States start at the base schema._\n\n';
  }
  const lines = ['## Migrations', '', '| From version | Migrator |', '| --- | --- |'];
  for (const [fromVersion, migration] of migrations) {
    const name = typeof migration?.name === 'string' && migration.name ? migration.name : '(anonymous)';
    lines.push(`| ${fromVersion} | \`${name}\` |`);
  }
  lines.push('');
  return lines.join('\n') + '\n';
}

async function writeStorageDocs() {
  const canonicalState = migrateAppState({});
  const fields = collectFields(canonicalState)
    .sort((a, b) => a.field.localeCompare(b.field));

  const { overrides, migrations } = buildIntroducedOverrides();

  const lines = [
    '# Storage Schema',
    '',
    '_Auto-generated by `scripts/update-storage-docs.js`. Do not edit this file manually._',
    '',
    `- Current \`APP_STATE_VERSION\`: ${APP_STATE_VERSION}`,
    `- Total tracked fields: ${fields.length}`,
    ''
  ];

  lines.push(renderMigrationsTable(migrations).trimEnd());
  lines.push('');
  lines.push('## Field definitions');
  lines.push('');
  lines.push('| Field | Type | Introduced |');
  lines.push('| --- | --- | --- |');
  for (const { field, type } of fields) {
    const introduced = overrides.get(field) ?? APP_STATE_VERSION;
    lines.push(`| \`${field}\` | ${type} | ${introduced} |`);
  }
  lines.push('');

  await fs.mkdir(docsDir, { recursive: true });
  await fs.writeFile(outputPath, lines.join('\n'));
}

writeStorageDocs().catch(error => {
  console.error('[update-storage-docs] Failed to generate documentation:', error);
  process.exitCode = 1;
});
